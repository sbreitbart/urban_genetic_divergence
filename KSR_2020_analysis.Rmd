---
title: "KSR_2020"
author: "Sophie Breitbart"
output:
  html_document:
    number_sections: true
    df_print: paged
    toc: yes
    toc_depth: 6
    toc_float:
      collapsed: yes
  pdf_document:
    toc: yes
    toc_depth: '2'
editor_options: 
  chunk_output_type: console

NOTES:
  -Still to do--
    -try to do an RDA (or PCA?) with all the traits
    -make a ReadMe file for each level
    -calculate heritability coefficients
    
WHEN TOTALLY DONE, type this:
renv::activate()
renv::snapshot()

---
# Set up notebook
## Load packages
```{r}
library(dplyr)
library(reshape)
library(reshape2)
library(DHARMa)
library(flextable)
library(glmmTMB)
library(redres)
library(tidyr)
library(broom.mixed)
library(tidyverse)
library(readxl)
library(broom)
library(knitr)
library(ggplot2)
library(ggExtra)
library("ggpubr")
library(devtools)
library(rpart)
library("tibble", lib.loc="~/R/win-library/3.5")
library(ISLR)
library(MASS)
library(car)
library(data.table)
library(plyr)
library(dplyr)
library(MuMIn)
library(ggplot2)
library(gridExtra)
library(Hmisc)
library(lme4)
library(nlme)
library(reshape)
library(lmerTest)
library(tidyverse)
library(vegan)
library(lindia)
library(e1071)
library(ggpubr)
library(forcats)
library(car)
library(multcomp)
library(lsmeans)
library(ggbiplot)
library(ggplot2)
require(MASS)
require(scales)
require(car)
require(ggplot2)
require(ggiraph)
require(ggiraphExtra)
library(geosphere)
library(vctrs)
library(here)
library(stringi)
```

## Add functions
```{r}
diagnostic<-function(x){
  plot(x)
  hist(x)
  qqnorm(x)
  qqline(x,lty=2, col="Red")

  skew<-function(x){
    m3<-sum((x-mean(x))^3)/length(x)
    s3<-sqrt(var(x))^3
    m3/s3}

  kurtosis<-function(x){
    m4<-sum((x-mean(x))^4)/length(x)
    s4<-var(x)^2
    m4/s4-3}

  print(paste("Kurtosis=", kurtosis(x), sep=""))
  print(paste("Skew=", skew(x), sep=""))
}


# lmer_diagnostic <- function(model) {
#  p1 <- plot(model, type = c("p", "smooth"))
#  p2 <- plot(model, sqrt(abs(resid(.))) ~ fitted(.), type = c("p", "smooth"))
#  p3 <- qqnorm(residuals(model))
#  p4 <- qqline(residuals(model))
#  
#  return( list(p1, p2, p3, p4) )
#     
# }



##### Export ANOVAs ##### 
# OLD-----
# flowering_gr_city_m1.tidy      <- tidy(car::Anova(flowering_gr_city_m1      ))
# flowering_gr_urb_m1.tidy       <- tidy(car::Anova(flowering_gr_urb_m1       ))
# flowering_urbsubs_city_m1.tidy <- tidy(car::Anova(flowering_urbsubs_city_m1 ))
# flowering_urbsubs_usc_m1.tidy  <- tidy(car::Anova(flowering_urbsubs_usc_m1   ))
#  

# anovas_merged.1 <- bind_rows(flowering_gr_city_m1.tidy    ,
#                               flowering_gr_urb_m1.tidy,
#                               flowering_urbsubs_city_m1.tidy,
#                               flowering_urbsubs_usc_m1.tidy ) %>%
#   mutate_if(.,
#             is.character,
#             str_replace_all,
#             pattern = c("City_dist", "Urb_score"),
#             replacement = c("Distance to City Center", "Urbanization Score")) %>%
#   mutate_if(.,
#             is.character,
#             str_replace_all,
#             pattern = c("Transect_ID", ":"),
#             replacement = c("Subtransect", " : ")) %>%
#   mutate_at(c(2,4), round, 3) %>%
#   rename_at(1, ~ "Effect") %>%
#   rename_at(2, ~ "Chi Square" ) %>%
#   rename_at(4, ~ "P" ) %>%
#   add_column(Model = 0) %>%
#   relocate(Model, before = Effect)

# anovas_table <- function(mod1, mod2, mod3, mod4) {
#   mod1.anova.tidy <- tidy(car::Anova(mod1))
#   mod2.anova.tidy <- tidy(car::Anova(mod2))
#   mod3.anova.tidy <- tidy(car::Anova(mod3))
#   mod4.anova.tidy <- tidy(car::Anova(mod4))
#   
#   anovas_merged <-  bind_rows( mod1.anova.tidy,
#                              mod2.anova.tidy,
#                              mod3.anova.tidy,
#                              mod4.anova.tidy) %>%
#   mutate_if(.,
#             is.character,
#             str_replace_all,
#             pattern = c("City_dist", "Urb_score"),
#             replacement = c("Distance to City Center", "Urbanization Score")) %>%
#   mutate_at(c(2,4), round, 3) %>%
#   rename_at(1, ~ "Effect") %>%
#   rename_at(2, ~ "Chi Square" ) %>%
#   rename_at(4, ~ "P" ) %>%
#   add_column(Model = "") %>%
#   relocate(Model, before = Effect) %>%
#     dplyr::select(., -4)
#   
# 
#   
#   anovas_merged[[1]][[1]] <- 1
#   anovas_merged[[1]][[2]] <- 2
#   anovas_merged[[1]][[3]] <- 3
#   anovas_merged[[1]][[6]] <- 4
# 
#   
#   return(as.data.frame(anovas_merged))
# }
# 
# fl1 <- anovas_table(flowering_gr_city_m1 ,
#                     flowering_gr_urb_m1      ,
#                     flowering_urbsubs_city_m1,
#                     flowering_urbsubs_usc_m1 ) %>%
#   mutate(P = ifelse(P < 0.001, "< 0.001", round(P, 3))) %>%
#   mutate_if(.,
#             is.character,
#             str_replace_all,
#             pattern = c("Transect_ID"),
#             replacement = c("Subtransect"))


# NEXT: PUT INTO  NICE TABLE

# library(flextable)
# library(officer)
# ft <- flextable(fl1) %>%
#   bold(., ~ P  == "< 0.001" | P <= 0.05, ~ P, bold = TRUE) %>%
#   set_caption(., caption = "Does Urbanization Affect Year 2 Flowering?") %>%
#   add_footer_lines(., "Models 1 and 2 include all populations. Models 3 and 4 include only urban populations.") %>%
#   italic(., italic = TRUE, part = "footer") %>%
#   align(., i = 1, part = "header", align = "center") %>%
#   width(., 2, width = 2.75) %>%
#   border(., c(2,3,6), border.top = fp_border(color="black", width = 0.5))  %>%
#   save_as_image(., "flextable_test.1.png")

### this fits a regular model... not the anova...
# flowering_gr_city_m1 %>% 
#   tidy() %>%
#   dplyr::filter(., effect == "fixed") %>%
#   dplyr::select(-c(1:2)) %>%
#   dplyr::filter(term != "(Intercept)") %>%
#   dplyr::mutate_if(.,
#             is.character,
#             str_replace_all,
#             pattern = c("City_dist"),
#             replacement = c("Distance to City Center")) %>%
#   rename_at(1, ~ "Effect") %>%
#   rename_at(2, ~ "Estimate") %>%
#   rename_at(3, ~ "Standard Error") %>%
#   rename_at(4, ~ "Chi Square" ) %>%
#   rename_at(5, ~ "P" ) %>%
#       flextable()  %>%
#   colformat_num(j = c(2:5), digits = 3) %>%
# bold(., ~ P  == "< 0.001" | P <= 0.05, ~ P, bold = TRUE) %>%
#   set_caption(., caption = "Does Urbanization Affect Year 2 Flowering?") %>%
#   align(., i = 1, part = "header", align = "center") %>%
#   align_text_col(., align = "left") %>%
#   align_nottext_col(., align = "center") %>%
#   autofit(., add_w = 0.1, add_h = 0.1)

# GOOD CODE-----
anova_table_flx <- function(mod1) {

  flx_1 <-  car::Anova(mod1) %>% 
  tidy() %>%
  dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("City_dist"),
            replacement = c("Distance to City Center")) %>%
    dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("Urb_score"),
            replacement = c("Urbanization Score")) %>%
    dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("Transect_ID"),
            replacement = c("Subtransect")) %>%
  rename_at(1, ~ "Effect") %>%
  rename_at(2, ~ "Chi Square" ) %>%
  rename_at(4, ~ "P" ) %>%
  # dplyr::select(-3) %>%
    flextable()  %>%
    colformat_num(j = c(2,4), digits = 3) %>%
    flextable::bold(., ~ P  == "< 0.001" | P <= 0.05, ~ P, bold = TRUE) %>%
    flextable::italic(., ~ P > 0.05 & P <= 0.1, ~ P, italic = TRUE) %>%
  # set_caption(., caption = "Does Urbanization Affect Year 2 Flowering?") %>%
  # align(., i = 1, part = "header", align = "center") %>%
  # add_footer_lines(., paste("Model formula: ", paste0(toString(formula(mod1)[3])))) %>%
  # italic(., italic = TRUE, part = "footer") %>%
  align_text_col(., align = "left") %>%
  align_nottext_col(., align = "center") %>%
  autofit(., add_w = 0.1, add_h = 0.1) 

  
      # make filename a string (from symbol)
  # filename1 <- toString(formula(mod1)[[2]])

  # can't figure out how to remove space from filename so it's staying for now...
  path_out = here::here("./Figures_Tables/ANOVA_tables_images/ ")
  
  save_as_image(flx_1,
                gsub(" ", "",
                     paste(path_out,
                      # filename1,
                      print(substitute(mod1)),
                      "_ANOVA.png")))

}

# use _transf function if response var has been transformed
# use _binomial or _quantitative when I had to fit 2 extra models per var: binomial and then, with positive values, quantitative
AIC_compare.city_dist <- function(full_model, ME_model) {
  
  data.frame(Model = c("Full model",
                       "Main effects only"),
                     AIC = c(AIC(full_model),
                             AIC(ME_model))) %>%
    write.csv(gsub(" ", "",
                   paste(here::here("./Figures_Tables/ANOVA_tables_images/ "),
                       "AIC_comparison_",
                       formula(full_model)[[2]],
                       "_city",
                       # deparse(substitute(full_model)),
                       ".csv")))
  
}
AIC_compare.city_dist_transf <- function(full_model, ME_model) {
  
  data.frame(Model = c("Full model",
                       "Main effects only"),
                     AIC = c(AIC(full_model),
                             AIC(ME_model))) %>%
    write.csv(gsub(" ", "",
                   paste(here::here("./Figures_Tables/ANOVA_tables_images/ "),
                       "AIC_comparison_",
                       toString(formula(full_model)[[2]][2]),
                       "_city",
                       # deparse(substitute(full_model)),
                       ".csv")))
  
}
AIC_compare.city_dist_transf_binomial <- function(full_model, ME_model) {
  
  data.frame(Model = c("Full model",
                       "Main effects only"),
                     AIC = c(AIC(full_model),
                             AIC(ME_model))) %>%
    write.csv(gsub(" ", "",
                   paste(here::here("./Figures_Tables/ANOVA_tables_images/ "),
                       "AIC_comparison_",
                       toString(formula(full_model)[[2]][2]),
                       "_city_binomial",
                       # deparse(substitute(full_model)),
                       ".csv")))
  
}
AIC_compare.city_dist_transf_quantitative <- function(full_model, ME_model) {
  
  data.frame(Model = c("Full model",
                       "Main effects only"),
                     AIC = c(AIC(full_model),
                             AIC(ME_model))) %>%
    write.csv(gsub(" ", "",
                   paste(here::here("./Figures_Tables/ANOVA_tables_images/ "),
                       "AIC_comparison_",
                       toString(formula(full_model)[[2]][2]),
                       "_city_quantitative",
                       # deparse(substitute(full_model)),
                       ".csv")))
  
}


AIC_compare.urb_score <- function(full_model, ME_model) {
  
  data.frame(Model = c("Full model",
                       "Main effects only"),
                     AIC = c(AIC(full_model),
                             AIC(ME_model))) %>%
    write.csv(gsub(" ", "",
                   paste(here::here("./Figures_Tables/ANOVA_tables_images/ "),
                       "AIC_comparison_",
                       toString(formula(full_model)[[2]]),
                       "_urbscore",
                       # deparse(substitute(full_model)),
                       ".csv")))
  
}
AIC_compare.urb_score_transf <- function(full_model, ME_model) {
  
  data.frame(Model = c("Full model",
                       "Main effects only"),
                     AIC = c(AIC(full_model),
                             AIC(ME_model))) %>%
    write.csv(gsub(" ", "",
                   paste(here::here("./Figures_Tables/ANOVA_tables_images/ "),
                       "AIC_comparison_",
                       toString(formula(full_model)[[2]][2]),
                       "_urbscore",
                       # deparse(substitute(full_model)),
                       ".csv")))
  
}
AIC_compare.urb_score_transf_binomial <- function(full_model, ME_model) {
  
  data.frame(Model = c("Full model",
                       "Main effects only"),
                     AIC = c(AIC(full_model),
                             AIC(ME_model))) %>%
    write.csv(gsub(" ", "",
                   paste(here::here("./Figures_Tables/ANOVA_tables_images/ "),
                       "AIC_comparison_",
                       toString(formula(full_model)[[2]][2]),
                       "_urbscore_binomial",
                       # deparse(substitute(full_model)),
                       ".csv")))
  
}
AIC_compare.urb_score_transf_quantitative <- function(full_model, ME_model) {
  
  data.frame(Model = c("Full model",
                       "Main effects only"),
                     AIC = c(AIC(full_model),
                             AIC(ME_model))) %>%
    write.csv(gsub(" ", "",
                   paste(here::here("./Figures_Tables/ANOVA_tables_images/ "),
                       "AIC_comparison_",
                       toString(formula(full_model)[[2]][2]),
                       "_urbscore_quantitative",
                       # deparse(substitute(full_model)),
                       ".csv")))
  
}



# get name of models so I can later export all model names with their formulas-----
qq <- function(...) sapply(substitute({ ... })[-1], deparse)

```

## Import data
```{r}
# 2019 data-----
data_clean_2019 <- read.csv(here::here("./CommonGardenExperiment_2019Data/clean_data/clean_data_2019KSR.csv"), na.strings=c("NO PLANT", "none"), blank.lines.skip=TRUE, header=TRUE, sep=",") %>%
  dplyr::select(., -c(1:2))

# 2020 data-----
heights_both_2020 <- read.csv(here::here("./CommonGardenExperiment_2020Data/clean_data/2020_heights_clean.csv")) %>%
  dplyr::select(., -c(1:2))

herbivory_both_2020 <- read.csv(here::here("./CommonGardenExperiment_2020Data/clean_data/2020_herbivory_clean.csv")) %>%
  dplyr::select(., -c(1:2))

survival_2020 <- read.csv(here::here("./CommonGardenExperiment_2020Data/clean_data/2020_survival_clean.csv")) %>%
  dplyr::select(., -c(1:2))

weevil_both <- read.csv(here::here("./CommonGardenExperiment_2020Data/clean_data/2020_weevil_damage_clean.csv")) %>%
  dplyr::select(., -c(1:2))

reproductive <- read.csv(here::here("./CommonGardenExperiment_2020Data/clean_data/2020_reproductive_clean.csv")) %>%
  dplyr::select(., -c(1:2))

flowering_2020 <- read.csv(here::here("./CommonGardenExperiment_2020Data/clean_data/2020_floweringplants_clean.csv")) %>%
  dplyr::select(., -c(1:2))
```

## Make combined 2019/2020 dfs
```{r}
# heights (includes heights and num. ramets)-----
## first make copy of data_clean_2019 with colnames that match heights_both_2020's
heights_2019 <- data_clean_2019 %>%
  dplyr::select(., c(1:6, 11:13, 18:19, 25:41)) %>%
  dplyr::filter(., Dead_2019 == 0) %>%
  dplyr::rename(., Dead = Dead_2019,
                Ramets_midJune = Num_Ramets_DC2, # doing this & following rows to compare btwn years
                Ramets_Sept = Num_Ramets_DC3, 
                Total_Height_midJune = Total_Height_DC2,
                Total_Height_Sept = Total_height_DC3) 
heights_2019$Year = 2019
heights_2019$rel_growth_rate <- as.character(heights_2019$rel_growth_rate)
heights_2019$rel_growth_rate <- as.numeric(heights_2019$rel_growth_rate)


# copy of 2020 data w/colnames that match 2019's
heights_2020 <- heights_both_2020 %>%
  dplyr::select(., -c(16)) %>%
  dplyr::rename(., Ramets_midJune = Ramets_June, # doing this & following rows to compare btwn years
                Total_Height_midJune = Total_Height_June) 
heights_2020$Year = 2020

# combine yearly dfs
heights_19_20 <- rbind.fill(heights_2019, heights_2020)
heights_19_20$Year <- as.factor(heights_19_20$Year)
heights_19_20$Family <- as.factor(heights_19_20$Family)
heights_19_20$Population <- as.factor(heights_19_20$Population)
heights_19_20$rel_growth_rate <- as.numeric(heights_19_20$rel_growth_rate)

# rm(heights_2019, heights_2020)

heights_19_20$Population <- as.factor(heights_19_20$Population)
heights_19_20$Family <- as.factor(heights_19_20$Family)




# herbivory-----
## first make copy of data_clean_2019 with colnames that match heights_both_2020's
herb_2019 <- data_clean_2019 %>%
  dplyr::select(., c(1:6, 18:19, 21, 32, 35:41)) %>%
  dplyr::filter(., Dead_2019 == 0) %>%
  dplyr::rename(., Dead = Dead_2019,
                Herbivory_mean_Sept = Herbivory_mean_DC3 # doing this to compare btwn years
                ) 
herb_2019$Year = 2019
herb_2019$Herbivory_mean_Sept <- as.character(herb_2019$Herbivory_mean_Sept)
herb_2019$Herbivory_mean_Sept <- as.numeric(herb_2019$Herbivory_mean_Sept)

# copy of 2020 data w/colnames that match 2019's
herb_2020 <- herbivory_both_2020 %>%
  dplyr::select(., -c(18)) %>%
  dplyr::rename(., Herbivory_mean_Sept = Herbivory.Sept_mean # doing thisto compare btwn years
                ) 
herb_2020$Year = 2020

# combine yearly dfs
herbivory_19_20 <- rbind.fill(herb_2019, herb_2020)

# rm(herb_2019, herb_2020)

herbivory_19_20$Population <- as.factor(herbivory_19_20$Population)
herbivory_19_20$Family <- as.factor(herbivory_19_20$Family)





# survival-----

## first make copy of data_clean_2019 with colnames that match heights_both_2020's
surv_2019 <- data_clean_2019 %>%
  dplyr::select(., c(1:6, 14:16, 25, 32, 35:41)) %>%
  dplyr::rename(., Dead = Dead_2019                ) 
surv_2019$Year = 2019

# copy of 2020 data w/colnames that match 2019's
surv_2020 <- survival_2020 %>%
  dplyr::select(., -c(12)) %>%
  dplyr::rename(., Dead = dead_2020 # doing thisto compare btwn years
                ) 
surv_2020$Year = 2020

# combine yearly dfs
survival_19_20 <- rbind.fill(surv_2019, surv_2020)

# rm(surv_2019, surv_2020)

survival_19_20$Population <- as.factor(survival_19_20$Population)
survival_19_20$Family <- as.factor(survival_19_20$Family)
survival_19_20$Block <- as.factor(survival_19_20$Block)
survival_19_20$Year <- as.factor(survival_19_20$Year)


```

# Find family & population means
## reproductive
### Binary: flowering success
```{r}

# Find family means
flowered2020_familymeans <- reproductive  %>%
  dplyr::select(., c(2:7, 10, 14, 16:18)) %>%
  group_by(Population, Family) %>%
    dplyr::summarise(
      sum_replicates = n_distinct(Replicate),
      sum_flowered_indivs = sum(as.integer(Flowered2020)),
      City_dist = first(City_dist),
      Transect_ID = first(Transect_ID),
      Urb_score = first(Urb_score),
      nPlants=n())


# Find population means
flowered2020_popmeans <- flowered2020_familymeans %>%
  group_by(Population) %>%
    dplyr::summarise(
      sum_replicates = sum(sum_replicates),
      sum_flowered_indivs = sum(as.integer(sum_flowered_indivs)),
      City_dist = first(City_dist),
      Transect_ID = first(Transect_ID),
      Urb_score = first(Urb_score)) %>%
  as.data.frame(flowered2020_popmeans) %>%
  
# add percent flowered column
  dplyr::mutate(., percent_flowered = sum_flowered_indivs / sum_replicates)

# remove pops with only 1 rep?




# Use SummarySE to get stats per family & population

### NOT TRANSFORMED
# SSE_fams_height_2020 <- summarySE(DC7_2020_heights, measurevar="Total_Height", groupvars=c("Population", "Family"), na.rm=TRUE)
# SSE_fams_height_2020 <- merge(x = SSE_fams_height_2020, y = Distances, by = "Population", all.x = TRUE)
# 
# SSE_pops_height_2020 <- summarySE(SSE_fams_height_2020, measurevar="Total_Height", groupvars=c("Population"), na.rm=TRUE)
# ## removing pops with only 1 representative (4 pops)
# SSE_pops_height_2020 <- merge(x = SSE_pops_height_2020 %>% filter(N > 1), y = Distances, by = "Population", all.x = TRUE)


```



## Height
### 2019
```{r}

# Find family means
heights_both2019_familymeans <- heights_2019 %>%
  group_by(Population, Family) %>%
    dplyr::summarise(
      sum_replicates = n_distinct(Replicate),
      sum_height_earlyJune = sum(Total_Height_DC1),
      sum_height_midJune = sum(Total_Height_midJune),
      sum_height_Sept = sum(Total_Height_Sept),
      mean_Ramets_earlyJune = mean(Num_Ramets_DC1),
      mean_Ramets_midJune = mean(Ramets_midJune),
      mean_Ramets_Sept = mean(Ramets_Sept),
      City_dist = first(City_dist),
      Transect_ID = first(Transect_ID),
      mean_rel_growth_rate = mean(rel_growth_rate, na.rm = TRUE),
      Urb_score = first(Urb_score),
      nPlants=n())
## divide total height by num. plants/pop
heights_both2019_familymeans$mean_height_midJune <- heights_both2019_familymeans$sum_height_midJune / heights_both2019_familymeans$sum_replicates

heights_both2019_familymeans$mean_height_earlyJune <- heights_both2019_familymeans$sum_height_earlyJune / heights_both2019_familymeans$sum_replicates

heights_both2019_familymeans$mean_height_Sept <- heights_both2019_familymeans$sum_height_Sept / heights_both2019_familymeans$sum_replicates


# Find population means
heights_both2019_popmeans <- heights_both2019_familymeans %>%
  group_by(Population) %>%
    dplyr::summarise(
      sum_replicates = sum(sum_replicates),
      sum_height_earlyJune = sum(sum_height_earlyJune),
      sum_height_midJune = sum(sum_height_midJune),
      sum_height_Sept = sum(sum_height_Sept),
      mean_Ramets_earlyJune = mean(mean_Ramets_earlyJune),
      mean_Ramets_midJune = mean(mean_Ramets_midJune),
      mean_Ramets_Sept = mean(mean_Ramets_Sept),
      mean_height_earlyJune = mean(mean_height_earlyJune),
      mean_height_midJune = mean(mean_height_midJune),
      mean_height_Sept = mean(mean_height_Sept),
      City_dist = first(City_dist),
      Transect_ID = first(Transect_ID),
      Urb_score = first(Urb_score),
      mean_rel_growth_rate = mean(mean_rel_growth_rate))


```



### 2020
```{r}

# Find family means
heights_both2020_familymeans <- heights_both_2020 %>%
  group_by(Population, Family) %>%
    dplyr::summarise(
      sum_replicates = n_distinct(Replicate),
      sum_height_June = sum(Total_Height_June),
      sum_height_Sept = sum(Total_Height_Sept),
      mean_Ramets_June = mean(Ramets_June),
      mean_Ramets_Sept = mean(Ramets_Sept),
      City_dist = first(City_dist),
      Transect_ID = first(Transect_ID),
      mean_rel_growth_rate = mean(rel_growth_rate),
      Urb_score = first(Urb_score),
      nPlants=n())
## divide total height by num. plants/pop
heights_both2020_familymeans$mean_height_June <- heights_both2020_familymeans$sum_height_June / heights_both2020_familymeans$sum_replicates

heights_both2020_familymeans$mean_height_Sept <- heights_both2020_familymeans$sum_height_Sept / heights_both2020_familymeans$sum_replicates


# Find population means
heights_both2020_popmeans <- heights_both2020_familymeans %>%
  group_by(Population) %>%
    dplyr::summarise(
      sum_replicates = sum(sum_replicates),
      sum_height_June = sum(sum_height_June),
      sum_height_Sept = sum(sum_height_Sept),
      mean_Ramets_June = mean(mean_Ramets_June),
      mean_Ramets_Sept = mean(mean_Ramets_Sept),
      mean_height_June = mean(mean_height_June),
      mean_height_Sept = mean(mean_height_Sept),
      City_dist = first(City_dist),
      Transect_ID = first(Transect_ID),
      Urb_score = first(Urb_score),
      mean_rel_growth_rate = mean(mean_rel_growth_rate))



# # Use SummarySE to get stats per family & population
# ## HEIGHTS
# intermediate1 <- summarySE(heights_both_2020, measurevar="Total_Height_June", groupvars=c("Population", "Family"), na.rm=TRUE)
# 
# intermediate2 <- summarySE(heights_both_2020, measurevar="Total_Height_Sept", groupvars=c("Population", "Family"), na.rm=TRUE)
# 
# heights_2020_familymeans_stats <- left_join(intermediate1, intermediate2, by = c("Population", "Family"), suffix = c(".July", ".Sept"))
# 
# 
# # Use SummarySE to get stats per family & population
# ## no. ramets
# intermediate1 <- summarySE(heights_both_2020, measurevar="Ramets_June", groupvars=c("Population", "Family"), na.rm=TRUE)
# 
# intermediate2 <- summarySE(heights_both_2020, measurevar="Ramets_Sept", groupvars=c("Population", "Family"), na.rm=TRUE)
# 
# ramets_2020_familymeans_stats <- left_join(intermediate1, intermediate2, by = c("Population", "Family"), suffix = c(".June", ".Sept"))
# 
# # Add transect data via merge
# ramets_2020_familymeans_stats <- merge(ramets_2020_familymeans_stats, Distances, by = "Population", all.x = TRUE)
# 
# 
# 
# # SSE_pops_height_2020 <- summarySE(intermediates, measurevar="Total_Height", groupvars=c("Population"), na.rm=TRUE)

```


## Weevil scar lengths
```{r}
# Find family means
weevil_both2020_familymeans <- weevil_both %>%
  group_by(Population, Family) %>%
    dplyr::summarise(
      sum_replicates = n_distinct(Replicate),
      mean_scar_div_Juneheight = mean(scar_div_Juneheight, na.rm = TRUE),
      mean_scar = mean(Scar_length_cm),
      City_dist = first(City_dist),
      Transect_ID = first(Transect_ID),
      Urb_score = first(Urb_score),
      nPlants=n())


# Find population means
weevil_both2020_popmeans <- weevil_both2020_familymeans %>%
  group_by(Population) %>%
    dplyr::summarise(
      sum_replicates = sum(sum_replicates),
      mean_scar_div_Juneheight = mean(mean_scar_div_Juneheight, na.rm = TRUE),
      mean_scar = mean(mean_scar),
      City_dist = first(City_dist),
      Transect_ID = first(Transect_ID),
      Urb_score = first(Urb_score))



# Use SummarySE to get stats per family & population

### NOT TRANSFORMED
# SSE_fams_height_2020 <- summarySE(DC7_2020_heights, measurevar="Total_Height", groupvars=c("Population", "Family"), na.rm=TRUE)
# SSE_fams_height_2020 <- merge(x = SSE_fams_height_2020, y = Distances, by = "Population", all.x = TRUE)
# 
# SSE_pops_height_2020 <- summarySE(SSE_fams_height_2020, measurevar="Total_Height", groupvars=c("Population"), na.rm=TRUE)
# ## removing pops with only 1 representative (4 pops)
# SSE_pops_height_2020 <- merge(x = SSE_pops_height_2020 %>% filter(N > 1), y = Distances, by = "Population", all.x = TRUE)


```
## Herbivory
### 2019
```{r}
# Find family means
herbivory2019_familymeans <- herb_2019 %>%
  group_by(Population, Family) %>%
    dplyr::summarise(
      sum_replicates = n_distinct(Replicate),
      Herbivory.Sept_mean = mean(Herbivory_mean_Sept, na.rm = T),
      City_dist = first(City_dist),
      Transect_ID = first(Transect_ID),
      Urb_score = first(Urb_score),
      nPlants=n())
herbivory2019_familymeans <- as.data.frame(herbivory2019_familymeans)


# Find population means
herbivory2019_popmeans <- herbivory2019_familymeans %>%
  group_by(Population) %>%
    dplyr::summarise(
      sum_replicates = sum(sum_replicates),
      Herbivory.Sept_mean = mean(Herbivory.Sept_mean, na.rm = T),
      City_dist = first(City_dist),
      Transect_ID = first(Transect_ID),
      Urb_score = first(Urb_score))
herbivory2019_popmeans <- as.data.frame(herbivory2019_popmeans)

```

### 2020
```{r}
# Find family means
herbivory2020_familymeans <- herbivory_both_2020 %>%
  group_by(Population, Family) %>%
    dplyr::summarise(
      sum_replicates = n_distinct(Replicate),
      Herbivory.July_mean = mean(Herbivory.July_mean, na.rm = T),
      Herbivory.Sept_mean = mean(Herbivory.Sept_mean, na.rm = T),
      City_dist = first(City_dist),
      Transect_ID = first(Transect_ID),
      Urb_score = first(Urb_score),
      nPlants=n())
herbivory2020_familymeans <- as.data.frame(herbivory2020_familymeans)


# Find population means
herbivory2020_popmeans <- herbivory2020_familymeans %>%
  group_by(Population) %>%
    dplyr::summarise(
      sum_replicates = sum(sum_replicates),
      Herbivory.July_mean = mean(Herbivory.July_mean, na.rm = T),
      Herbivory.Sept_mean = mean(Herbivory.Sept_mean, na.rm = T),
      City_dist = first(City_dist),
      Transect_ID = first(Transect_ID),
      Urb_score = first(Urb_score))
herbivory2020_popmeans <- as.data.frame(herbivory2020_popmeans)


# Use SummarySE to get stats per family & population

### NOT TRANSFORMED
# SSE_fams_height_2020 <- summarySE(DC7_2020_heights, measurevar="Total_Height", groupvars=c("Population", "Family"), na.rm=TRUE)
# SSE_fams_height_2020 <- merge(x = SSE_fams_height_2020, y = Distances, by = "Population", all.x = TRUE)
# 
# SSE_pops_height_2020 <- summarySE(SSE_fams_height_2020, measurevar="Total_Height", groupvars=c("Population"), na.rm=TRUE)
# ## removing pops with only 1 representative (4 pops)
# SSE_pops_height_2020 <- merge(x = SSE_pops_height_2020 %>% filter(N > 1), y = Distances, by = "Population", all.x = TRUE)


```


## Survival
### 2019
```{r}
# Find family means
survival2019_familymeans <- surv_2019 %>%
  group_by(Population, Family) %>%
    dplyr::summarise(
      sum_replicates = n_distinct(Replicate),
      survival_mean = mean(Dead, na.rm = T),
      City_dist = first(City_dist),
      Transect_ID = first(Transect_ID),
      Urb_score = first(Urb_score),
      nPlants=n())
survival2019_familymeans <- as.data.frame(survival2019_familymeans)


# Find population means
survival2019_popmeans <- survival2019_familymeans %>%
  group_by(Population) %>%
    dplyr::summarise(
      sum_replicates = sum(sum_replicates),
      survival_mean = mean(survival_mean, na.rm = T),
      City_dist = first(City_dist),
      Transect_ID = first(Transect_ID),
      Urb_score = first(Urb_score))
survival2019_popmeans <- as.data.frame(survival2019_popmeans)

```


### 2020
```{r}
# Find family means
survival2020_familymeans <- survival_2020 %>%
  group_by(Population, Family) %>%
    dplyr::summarise(
      sum_replicates = n_distinct(Replicate),
      survival_mean = mean(dead_2020, na.rm = T),
      City_dist = first(City_dist),
      Transect_ID = first(Transect_ID),
      Urb_score = first(Urb_score),
      nPlants=n())
survival2020_familymeans <- as.data.frame(survival2020_familymeans)


# Find population means
survival2020_popmeans <- survival2020_familymeans %>%
  group_by(Population) %>%
    dplyr::summarise(
      sum_replicates = sum(sum_replicates),
      survival_mean = mean(survival_mean, na.rm = T),
      City_dist = first(City_dist),
      Transect_ID = first(Transect_ID),
      Urb_score = first(Urb_score))
survival2020_popmeans <- as.data.frame(survival2020_popmeans)


# Use SummarySE to get stats per family & population

### NOT TRANSFORMED
# SSE_fams_height_2020 <- summarySE(DC7_2020_heights, measurevar="Total_Height", groupvars=c("Population", "Family"), na.rm=TRUE)
# SSE_fams_height_2020 <- merge(x = SSE_fams_height_2020, y = Distances, by = "Population", all.x = TRUE)
# 
# SSE_pops_height_2020 <- summarySE(SSE_fams_height_2020, measurevar="Total_Height", groupvars=c("Population"), na.rm=TRUE)
# ## removing pops with only 1 representative (4 pops)
# SSE_pops_height_2020 <- merge(x = SSE_pops_height_2020 %>% filter(N > 1), y = Distances, by = "Population", all.x = TRUE)


```

# Statistics: 2019
## Heights
### Early June height
#### lmer
##### Entire gradient: *Not sig for city_dis or urb_score
###### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################
diagnostic(test1)

plot(test1, type = c("p", "smooth"))
plot(test1, sqrt(abs(resid(.))) ~ fitted(.),
     type = c("p", "smooth"))
qqnorm(residuals(test1))
qqline(residuals(test1))


### NESTED RANDOM EFFECTS-----
test1<- lmer(Total_Height_DC1 ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, REML = F)
# NOT singular

car::Anova(lmer(Total_Height_DC1 ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, REML = F))
# distance NOT significant


r.squaredGLMM(lmer(Total_Height_DC1 ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, REML = F))

### CROSSED RANDOM EFFECTS-----
lmer(Total_Height_DC1 ~ (1|Block) + (1|Population:Family) + City_dist,
  data = heights_2019, REML = F)
# NOT singular

car::Anova(lmer(Total_Height_DC1 ~ (1|Block) + (1|Population:Family) + City_dist,
  data = heights_2019, REML = F))
# distance NOT significant



# ANy variation within families or populations?
m.1 <- lmer(Total_Height_DC1 ~ (1|Population/Family), data = heights_2019, REML = T)

ranova(m.1)
# YES for within families
# 
sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance")
variances1 <- as.data.frame(variances1)
variances1 <- variances1 %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_EarlyJuneHeight_lmer_PVE.csv", col.names=TRUE, sep=",")
write.table(variances1, "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_EarlyJuneHeight_lmer_PVE.csv", col.names=TRUE, sep=",", append=TRUE)
```

###### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################


### NESTED RANDOM EFFECTS-----
lmer(Total_Height_DC1 ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, REML = F)
# is singular...

car::Anova(lmer(Total_Height_DC1 ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, REML = F))
# nothing significant


r.squaredGLMM(lmer(Total_Height_DC1 ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, REML = F))

### CROSSED RANDOM EFFECTS-----
lmer(Total_Height_DC1 ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = heights_2019, REML = F)
# NOT singular!

car::Anova(lmer(Total_Height_DC1 ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = heights_2019, REML = F))
# nothing significant

```

##### Urban subtransects: *transect sig for both
###### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
lmer(Total_Height_DC1  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)


car::Anova(lmer(Total_Height_DC1  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant


# Just main effects
car::Anova(lmer(Total_Height_DC1  ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant



### CROSSED RANDOM EFFECTS-----
# Full model
lmer(Total_Height_DC1  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)
# No warnings!!

car::Anova(lmer(Total_Height_DC1  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant


# Just main effects
car::Anova(lmer(Total_Height_DC1  ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, 
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant


AIC(lmer(Total_Height_DC1  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))

AIC(lmer(Total_Height_DC1  ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# AIC <2 apart; both "best models" though just main effects lower AIC




# ANy variation among families or populations?
m.1 <- lmer(Total_Height_DC1 ~ (1|Population/Family), data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = T)
ranova(m.1)
# YES for within families

m.2 <- lmer(Total_Height_DC1 ~ (1|Population/Family) + Transect_ID, data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)
car::Anova(m.2)
# YES among transects


m.3 <- lmer(Total_Height_DC1 ~ (1|Population/Family) + Transect_ID, data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = T)
car::Anova(m.3)
# YES among transects (still)


sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance")
variances1 <- as.data.frame(variances1)
variances1 <- variances1 %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_earlyJuneHeight_urban_lmer_PVE.csv", col.names=TRUE, sep=",")
write.table(variances1, "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_earlyJuneHeight_urban_lmer_PVE.csv", col.names=TRUE, sep=",", append=TRUE)
write.table(car::Anova(m.2), "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_earlyJuneHeight_urban_lmer_PVE.csv", col.names=TRUE, sep=",", append=TRUE)
```

###### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
lmer(Total_Height_DC1  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)
# No warnings!!

car::Anova(lmer(Total_Height_DC1  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant


# Just main effects
car::Anova(lmer(Total_Height_DC1  ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant



### CROSSED RANDOM EFFECTS-----
# Full model
lmer(Total_Height_DC1  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)
# No warnings!!

car::Anova(lmer(Total_Height_DC1  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant


# Just main effects
car::Anova(lmer(Total_Height_DC1  ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, 
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
     control=lmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# transect significant


AIC(lmer(Total_Height_DC1  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))

AIC(lmer(Total_Height_DC1  ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# AIC <2 apart; both "best models" though just main effects lower AIC

```


### Mid June height
#### lmer
##### Entire gradient: *NOT sig for city_dist or urb_score
###### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################


### NESTED RANDOM EFFECTS-----
lmer(Total_Height_midJune ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, REML = F,
     control=lmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5)))

car::Anova(lmer(Total_Height_midJune ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, REML = F,
     control=lmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# distance NOT significant


r.squaredGLMM(lmer(Total_Height_midJune ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, REML = F,
     control=lmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))

### CROSSED RANDOM EFFECTS-----
lmer(Total_Height_midJune ~ (1|Block) + (1|Population:Family) + City_dist,
  data = heights_2019, REML = F)
# NOT singular!

car::Anova(lmer(Total_Height_midJune ~ (1|Block) + (1|Population:Family) + City_dist,
  data = heights_2019, REML = F))
# distance NOT significant




# ANy variation within families or populations?
m.1 <- lmer(Total_Height_midJune ~ (1|Population/Family), data = heights_2019, REML = T)

ranova(m.1)
# YES for within families
sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance")
variances1 <- as.data.frame(variances1)
variances1 <- variances1 %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_midJuneHeight_lmer_PVE.csv", col.names=TRUE, sep=",")
write.table(variances1, "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_midJuneHeight_lmer_PVE.csv", col.names=TRUE, sep=",", append=TRUE)
```

###### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################


### NESTED RANDOM EFFECTS-----
lmer(Total_Height_midJune ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, REML = F)

car::Anova(lmer(Total_Height_midJune ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, REML = F))
# nothing significant


r.squaredGLMM(lmer(Total_Height_midJune ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, REML = F))

### CROSSED RANDOM EFFECTS-----
lmer(Total_Height_midJune ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = heights_2019, REML = F)
# NOT singular

car::Anova(lmer(Total_Height_midJune ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = heights_2019, REML = F))
# nothing significant

```

##### Urban subtransects: *transect sig for both
###### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
lmer(Total_Height_midJune  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)
# singular

car::Anova(lmer(Total_Height_midJune  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant


# Just main effects
car::Anova(lmer(Total_Height_midJune  ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# singular, transect significant



### CROSSED RANDOM EFFECTS-----
# Full model
lmer(Total_Height_midJune  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)
# No warnings!!

car::Anova(lmer(Total_Height_midJune  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant


# Just main effects
car::Anova(lmer(Total_Height_midJune  ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, 
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant


AIC(lmer(Total_Height_midJune  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))

AIC(lmer(Total_Height_midJune  ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# AIC <2 apart; both "best models" though just main effects lower AIC




# ANy variation among families or populations?
m.1 <- lmer(Total_Height_midJune ~ (1|Population/Family), data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = T)
ranova(m.1)
# YES for among families

m.2 <- lmer(Total_Height_midJune ~ (1|Population/Family) + Transect_ID, data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)
car::Anova(m.2)
# YES among transects though


m.3 <- lmer(Total_Height_midJune ~ (1|Population/Family) + Transect_ID, data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = T)
car::Anova(m.3)
# YES amnog transects


sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance")
variances1 <- as.data.frame(variances1)
variances1 <- variances1 %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1),
            "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_midJuneHeight_urban_lmer_PVE.csv",
            col.names=TRUE, sep=",")
write.table(variances1,
            "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_midJuneHeight_urban_lmer_PVE.csv", 
            col.names=TRUE, sep=",", append=TRUE)
write.table(car::Anova(m.2),
            "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_midJuneHeight_urban_lmer_PVE.csv", 
            col.names=TRUE, sep=",", append=TRUE)
```

###### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
lmer(Total_Height_midJune  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)
# singular

car::Anova(lmer(Total_Height_midJune  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant


# Just main effects
car::Anova(lmer(Total_Height_midJune  ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant



### CROSSED RANDOM EFFECTS-----
# Full model
lmer(Total_Height_midJune  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)
# No warnings!!

car::Anova(lmer(Total_Height_midJune  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant


# Just main effects
car::Anova(lmer(Total_Height_midJune  ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, 
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant


AIC(lmer(Total_Height_midJune  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))

AIC(lmer(Total_Height_midJune  ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# AIC <2 apart; both "best models" though just main effects lower AIC

```


### Sept height
#### lmer
##### Entire gradient: *Not sig for either
###### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################


### NESTED RANDOM EFFECTS-----
lmer(Total_Height_Sept ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, REML = F)
# NOT singular

car::Anova(lmer(Total_Height_Sept ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, REML = F))
# distance not significant


### CROSSED RANDOM EFFECTS-----
lmer(Total_Height_Sept ~ (1|Block) + (1|Population:Family) + City_dist,
  data = heights_2019, REML = F)
# NOT singular!

car::Anova(lmer(Total_Height_Sept ~ (1|Block) + (1|Population:Family) + City_dist,
  data = heights_2019, REML = F))
# distance not  significant

r.squaredGLMM(lmer(Total_Height_Sept ~ (1|Block) + (1|Population:Family) + City_dist,
  data = heights_2019, REML = F))

# ANy variation within families or populations?
m.1 <- lmer(Total_Height_Sept ~ (1|Population/Family), data = heights_2019, REML = T)

ranova(m.1)
# YES for within families

sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance")
variances1 <- as.data.frame(variances1)
variances1 <- variances1 %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_SeptHeight_lmer_PVE.csv", col.names=TRUE, sep=",")
write.table(variances1, "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_SeptHeight_lmer_PVE.csv", col.names=TRUE, sep=",", append=TRUE)
```

###### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################


### NESTED RANDOM EFFECTS-----
lmer(Total_Height_Sept ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, REML = F)
# not singular...

car::Anova(lmer(Total_Height_Sept ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, REML = F))
# not significant


### CROSSED RANDOM EFFECTS-----
lmer(Total_Height_Sept ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = heights_2019, REML = F)
# NOT singular!

car::Anova(lmer(Total_Height_Sept ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = heights_2019, REML = F))
# not significant

r.squaredGLMM(lmer(Total_Height_Sept ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = heights_2019, REML = F))

```


##### Urban subtransects: *Not sig for either
###### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
lmer(Total_Height_Sept  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
     control=lmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5)))
# singular

car::Anova(lmer(Total_Height_Sept  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
     control=lmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# nothing significant


# Just main effects
car::Anova(lmer(Total_Height_Sept  ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
     control=lmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# nothing significant



### CROSSED RANDOM EFFECTS-----
# Full model
lmer(Total_Height_Sept  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)
# No warnings!!

car::Anova(lmer(Total_Height_Sept  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# nothing significant


# Just main effects
car::Anova(lmer(Total_Height_Sept  ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# nothing significant


AIC(lmer(Total_Height_Sept  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))

AIC(lmer(Total_Height_Sept  ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# AIC <2 apart; both "best models" though just main effects lower AIC




# ANy variation among families or populations?
m.1 <- lmer(Total_Height_Sept ~ (1|Population/Family), data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = T)
ranova(m.1)
# YES for among families

m.2 <- lmer(Total_Height_Sept ~ (1|Population/Family) + Transect_ID, data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)
car::Anova(m.2)
# not among transects though


m.3 <- lmer(Total_Height_Sept ~ (1|Population/Family) + Transect_ID, data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = T)
car::Anova(m.3)
# not sig in this or m.2


sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance")
variances1 <- as.data.frame(variances1)
variances1 <- variances1 %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1),
            "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_SeptHeight_urban_lmer_PVE.csv", 
            col.names=TRUE, sep=",")
write.table(variances1,
            "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_SeptHeight_urban_lmer_PVE.csv", 
            col.names=TRUE, sep=",", append=TRUE)
write.table(car::Anova(m.2),
            "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_SeptHeight_urban_lmer_PVE.csv", 
            col.names=TRUE, sep=",", append=TRUE)
```


###### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
lmer(Total_Height_Sept  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)
# singular

car::Anova(lmer(Total_Height_Sept  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# nothing significant


# Just main effects
car::Anova(lmer(Total_Height_Sept  ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# nothing significant



### CROSSED RANDOM EFFECTS-----
# Full model
lmer(Total_Height_Sept  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)
# No warnings!!

car::Anova(lmer(Total_Height_Sept  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# nothing significant


# Just main effects
car::Anova(lmer(Total_Height_Sept  ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# nothing significant


AIC(lmer(Total_Height_Sept  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))

AIC(lmer(Total_Height_Sept  ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# AIC <2 apart; both "best models" though just main effects lower AIC

```

## Relative Growth Rate
### Mid-June through Sept
#### lmer
##### Entire gradient: *Not sig for city_dis or urb_score
###### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################


### NESTED RANDOM EFFECTS-----
lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, REML = F)
# NOT singular

car::Anova(lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, REML = F))
# distance NOT significant


r.squaredGLMM(lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, REML = F))

### CROSSED RANDOM EFFECTS-----
lmer(rel_growth_rate ~ (1|Block) + (1|Population:Family) + City_dist,
  data = heights_2019, REML = F)
# NOT singular

car::Anova(lmer(rel_growth_rate ~ (1|Block) + (1|Population:Family) + City_dist,
  data = heights_2019, REML = F))
# distance NOT significant




# ANy variation within families or populations?
m.1 <- lmer(rel_growth_rate ~ (1|Population/Family), data = heights_2019, REML = T)

ranova(m.1)
# YES for within families
# 
sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance")
variances1 <- as.data.frame(variances1)
variances1 <- variances1 %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_relgrowthrate_lmer_PVE.csv", col.names=TRUE, sep=",")
write.table(variances1, "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_relgrowthrate_lmer_PVE.csv", col.names=TRUE, sep=",", append=TRUE)
```

###### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################


### NESTED RANDOM EFFECTS-----
lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, REML = F)

car::Anova(lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, REML = F))
# nothing significant


r.squaredGLMM(lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, REML = F))

### CROSSED RANDOM EFFECTS-----
lmer(rel_growth_rate ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = heights_2019, REML = F)

car::Anova(lmer(rel_growth_rate ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = heights_2019, REML = F))
# nothing significant

```

##### Urban subtransects: *transect sig for both
###### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
lmer(rel_growth_rate  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)
# singular

car::Anova(lmer(rel_growth_rate  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant


# Just main effects
car::Anova(lmer(rel_growth_rate  ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant



### CROSSED RANDOM EFFECTS-----
# Full model
lmer(rel_growth_rate  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)
# No warnings!!

car::Anova(lmer(rel_growth_rate  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant


# Just main effects
car::Anova(lmer(rel_growth_rate  ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, 
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant


AIC(lmer(rel_growth_rate  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))

AIC(lmer(rel_growth_rate  ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# AIC <2 apart; both "best models" though just main effects lower AIC




# ANy variation among families or populations?
m.1 <- lmer(rel_growth_rate ~ (1|Population/Family), data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = T)
ranova(m.1)
# YES for within families

m.2 <- lmer(rel_growth_rate ~ (1|Population/Family) + Transect_ID, data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)
car::Anova(m.2)
# YES among transects


m.3 <- lmer(rel_growth_rate ~ (1|Population/Family) + Transect_ID, data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = T)
car::Anova(m.3)
# YES among transects (still)


sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance")
variances1 <- as.data.frame(variances1)
variances1 <- variances1 %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_relgrowthrate_urban_lmer_PVE.csv", col.names=TRUE, sep=",")
write.table(variances1, "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_relgrowthrate_urban_lmer_PVE.csv", col.names=TRUE, sep=",", append=TRUE)
write.table(car::Anova(m.2), "~/R_Projects/chapter_two/Figures_Tables/ranova_PVE/2019_relgrowthrate_urban_lmer_PVE.csv", col.names=TRUE, sep=",", append=TRUE)
```

###### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
lmer(rel_growth_rate  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)

car::Anova(lmer(rel_growth_rate  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant


# Just main effects
car::Anova(lmer(rel_growth_rate  ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant



### CROSSED RANDOM EFFECTS-----
# Full model
lmer(rel_growth_rate  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F)
# No warnings!!

car::Anova(lmer(rel_growth_rate  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# transect significant


# Just main effects
car::Anova(lmer(rel_growth_rate  ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, 
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
     control=lmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# transect significant


AIC(lmer(rel_growth_rate  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))

AIC(lmer(rel_growth_rate  ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F))
# AIC <2 apart; both "best models" though just main effects lower AIC

```


## No. Ramets
### Early June ramets
NOTE: Originally used lmer but then switched to glmer w/poisson bc it's count data.
-This didn't change the story for gradient (city_dist nor urb_score)
-This DID change story for urb subs (urb_score: interaxn became sig)
#### glmer
##### Entire gradient: *Not sig for city_dis or urb_score
###### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################


### NESTED RANDOM EFFECTS-----
glmer(Num_Ramets_DC1 ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, family = poisson)
# NOT singular

car::Anova(glmer(Num_Ramets_DC1 ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, family = poisson))
# distance NOT significant


r.squaredGLMM(glmer(Num_Ramets_DC1 ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, family = poisson))

### CROSSED RANDOM EFFECTS-----
glmer(Num_Ramets_DC1 ~ (1|Block) + (1|Population:Family) + City_dist,
  data = heights_2019, family = poisson)
# NOT singular

car::Anova(glmer(Num_Ramets_DC1 ~ (1|Block) + (1|Population:Family) + City_dist,
  data = heights_2019, family = poisson))
# distance NOT significant


```

###### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################


### NESTED RANDOM EFFECTS-----
glmer(Num_Ramets_DC1 ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, family = poisson)
# not singular...

car::Anova(glmer(Num_Ramets_DC1 ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, family = poisson))
# nothing significant


r.squaredGLMM(glmer(Num_Ramets_DC1 ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, REML = F))

### CROSSED RANDOM EFFECTS-----
glmer(Num_Ramets_DC1 ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = heights_2019, family = poisson)
# NOT singular!

car::Anova(glmer(Num_Ramets_DC1 ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = heights_2019, family = poisson))
# nothing significant

```

##### Urban subtransects: *transect sig for both AND interaxn sig for urb_score
###### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
glmer(Num_Ramets_DC1  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5)))
# singular

car::Anova(glmer(Num_Ramets_DC1  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# transect significant


# Just main effects
car::Anova(glmer(Num_Ramets_DC1  ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# transect significant



### CROSSED RANDOM EFFECTS-----
# Full model
glmer(Num_Ramets_DC1  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5)))
# No warnings!!

car::Anova(glmer(Num_Ramets_DC1  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# transect significant


# Just main effects
car::Anova(glmer(Num_Ramets_DC1  ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# transect significant


AIC(glmer(Num_Ramets_DC1  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))

AIC(glmer(Num_Ramets_DC1  ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# AIC <2 apart; both "best models" though just main effects lower AIC

```

###### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
glmer(Num_Ramets_DC1  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5)))
# singular

car::Anova(glmer(Num_Ramets_DC1  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# transect significant and so is interaxn




### CROSSED RANDOM EFFECTS-----
# Full model
glmer(Num_Ramets_DC1  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5)))
# No warnings!!

car::Anova(glmer(Num_Ramets_DC1  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# transect significant AND interaxn



AIC(glmer(Num_Ramets_DC1  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))


```


### Mid June ramets
NOTE: Originally used lmer but then switched to glmer w/poisson bc it's count data.
-This didn't change the story for gradient (city_dist nor urb_score)
-This DID change story for urb subs (urb_score: transect became marg sig)
#### glmer
##### Entire gradient: *NOT sig for city_dist or urb_score
###### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################


### NESTED RANDOM EFFECTS-----
glmer(Ramets_midJune ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5)))

car::Anova(glmer(Ramets_midJune ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# distance NOT significant


r.squaredGLMM(glmer(Ramets_midJune ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))

### CROSSED RANDOM EFFECTS-----
glmer(Ramets_midJune ~ (1|Block) + (1|Population:Family) + City_dist,
  data = heights_2019, family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5)))
# NOT singular!

car::Anova(glmer(Ramets_midJune ~ (1|Block) + (1|Population:Family) + City_dist,
  data = heights_2019, family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# distance NOT significant

```

###### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################


### NESTED RANDOM EFFECTS-----
glmer(Ramets_midJune ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, family = poisson)

car::Anova(glmer(Ramets_midJune ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, family = poisson))
# nothing significant


r.squaredGLMM(glmer(Ramets_midJune ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, family = poisson))

### CROSSED RANDOM EFFECTS-----
glmer(Ramets_midJune ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = heights_2019, family = poisson)
# NOT singular

car::Anova(glmer(Ramets_midJune ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = heights_2019, family = poisson))
# nothing significant

```

##### Urban subtransects: *transect marg sig for city_dist, not for urb_score
###### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
glmer(Ramets_midJune  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson)
# singular

car::Anova(glmer(Ramets_midJune  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson))
# transect marg significant


# Just main effects
car::Anova(glmer(Ramets_midJune  ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson))
# singular, transect marg significant



### CROSSED RANDOM EFFECTS-----
# Full model
glmer(Ramets_midJune  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5)))
# model not converging...

car::Anova(glmer(Ramets_midJune  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# transect marg significant


# Just main effects
car::Anova(glmer(Ramets_midJune  ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, 
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# transect marg significant


AIC(glmer(Ramets_midJune  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))

AIC(glmer(Ramets_midJune  ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# AIC <2 apart; both "best models" though just main effects lower AIC

```

###### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
glmer(Ramets_midJune  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson)
# singular

car::Anova(glmer(Ramets_midJune  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson))
# transect marg significant


# Just main effects
car::Anova(glmer(Ramets_midJune  ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson))
# transect marg significant



### CROSSED RANDOM EFFECTS-----
# Full model
glmer(Ramets_midJune  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson)
# No warnings!!

car::Anova(glmer(Ramets_midJune  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson))
# transect marg significant


# Just main effects
car::Anova(glmer(Ramets_midJune  ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, 
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson))
# transect marg significant


AIC(glmer(Ramets_midJune  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson))

AIC(glmer(Ramets_midJune  ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson))
# AIC <2 apart; both "best models" though just main effects lower AIC

```


### Sept ramets
NOTE: Originally used lmer but then switched to glmer w/poisson bc it's count data.
-This didn't change the story for gradient OR urb subs (city_dist nor urb_score)
#### glmer
##### Entire gradient: *Not sig for either
###### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################


### NESTED RANDOM EFFECTS-----
glmer(Ramets_Sept ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, family = poisson)
#  singular

car::Anova(glmer(Ramets_Sept ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019, family = poisson))
# distance not significant


### CROSSED RANDOM EFFECTS-----
glmer(Ramets_Sept ~ (1|Block) + (1|Population:Family) + City_dist,
  data = heights_2019, family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5)))
# convergence warning

car::Anova(glmer(Ramets_Sept ~ (1|Block) + (1|Population:Family) + City_dist,
  data = heights_2019, family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# distance not  significant

r.squaredGLMM(glmer(Ramets_Sept ~ (1|Block) + (1|Population:Family) + City_dist,
  data = heights_2019, family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))

```

###### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################


### NESTED RANDOM EFFECTS-----
glmer(Ramets_Sept ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5)))
#  singular...

car::Anova(glmer(Ramets_Sept ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_2019, family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# not significant


### CROSSED RANDOM EFFECTS-----
glmer(Ramets_Sept ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = heights_2019, family = poisson)
# NOT singular!

car::Anova(glmer(Ramets_Sept ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = heights_2019, family = poisson))
# not significant

r.squaredGLMM(glmer(Ramets_Sept ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = heights_2019, family = poisson))

```


##### Urban subtransects: *Not sig for either
###### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
glmer(Ramets_Sept  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5)))
# singular

car::Anova(glmer(Ramets_Sept  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# nothing significant


# Just main effects
car::Anova(glmer(Ramets_Sept  ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,
     control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# nothing significant



### CROSSED RANDOM EFFECTS-----
# Full model
glmer(Ramets_Sept  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson)
# No warnings!!

car::Anova(glmer(Ramets_Sept  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson))
# nothing significant


# Just main effects
car::Anova(glmer(Ramets_Sept  ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson))
# nothing significant


AIC(glmer(Ramets_Sept  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson))

AIC(glmer(Ramets_Sept  ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson))
# AIC <2 apart; both "best models" though just main effects lower AIC
```


###### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
glmer(Ramets_Sept  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson)
# singular

car::Anova(glmer(Ramets_Sept  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson))
# nothing significant


# Just main effects
car::Anova(glmer(Ramets_Sept  ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson,
      control=glmerControl(optimizer="bobyqa",
                                  optCtrl=list(maxfun=2e5))))
# nothing significant



### CROSSED RANDOM EFFECTS-----
# Full model
glmer(Ramets_Sept  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson)
# No warnings!!

car::Anova(glmer(Ramets_Sept  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson))
# nothing significant


# Just main effects
car::Anova(glmer(Ramets_Sept  ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson))
# nothing significant


AIC(glmer(Ramets_Sept  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson))

AIC(glmer(Ramets_Sept  ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,
     data = heights_2019 %>% dplyr::filter(., Transect_ID != "Rural"), family = poisson))
# AIC <2 apart; both "best models" though just main effects lower AIC

```

## Herbivory
### Sept
#### glmer w/binomial distr.
NOTE: I originally fit these models w/herbivory scores ranging from 0 to 100 and used lmer. Then I switched to herbivory percents (dividing by 100) and using binomial distr. I would've used quasi-binomial but glmer can't handle that, only glm.
-The story didn't change when analyzing the entire gradient NOR urban subtransects: i.e. herbivory didn't change with urbanization when quantified with city_dist nor urb_score.
##### Entire gradient: *Not sig for either
###### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

# Using a binomial distribution bc glmer can't handle quasi-binomial, which is what the optimal model would be here.

### NESTED RANDOM EFFECTS-----
glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Population/Family) + City_dist,
  data = herb_2019,
  family = binomial(link = logit))
# is singular...

car::Anova(glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Population/Family) + City_dist,
  data = herb_2019,
  family = binomial(link = logit)))
# nothing is significant

r.squaredGLMM(glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Population/Family) + City_dist,
  data = herb_2019,
  family = binomial(link = logit)))  

### CROSSED RANDOM EFFECTS-----
glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Population:Family) + City_dist,
  data = herb_2019,
  family = binomial(link = logit))
#  singular

car::Anova(glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Population:Family) + City_dist,
  data = herb_2019,
  family = binomial(link = logit)))
# distance not significant


```

###### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################


### NESTED RANDOM EFFECTS-----
glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = herb_2019,
  family = binomial(link = logit))
# is singular...

car::Anova(glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = herb_2019,
  family = binomial(link = logit)))
# nothing is significant

r.squaredGLMM(glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = herb_2019,
  family = binomial(link = logit)))
  

### CROSSED RANDOM EFFECTS-----
glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = herb_2019,
  family = binomial(link = logit))
#  singular

car::Anova(glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = herb_2019,
  family = binomial(link = logit)))
#  not significant


```


##### Urban subtransects: *Not sig for either
###### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
glmer(Herbivory_mean_Sept  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
     data = herb_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = binomial(link = logit))
# singular...

car::Anova(glmer(Herbivory_mean_Sept  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
     data = herb_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
       family = binomial(link = logit)))
# nothingsignificant


# Just main effects
car::Anova(glmer(Herbivory_mean_Sept  ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
     data = herb_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = binomial(link = logit)))
# singular... nothing is significant



### CROSSED RANDOM EFFECTS-----
# Full model
glmer(Herbivory_mean_Sept  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = herb_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
       family = binomial(link = logit))
#  singular...

car::Anova(glmer(Herbivory_mean_Sept  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = herb_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
      family = binomial(link = logit)))
# nothing is significant


# Just main effects
car::Anova(glmer(Herbivory_mean_Sept  ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,
     data = herb_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
       family = binomial(link = logit)))
# singular... nothing is significant


AIC(glmer(Herbivory_mean_Sept  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
     data = herb_2019 %>% dplyr::filter(., Transect_ID != "Rural"),   family = binomial(link = logit))
)

AIC(glmer(Herbivory_mean_Sept  ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,
     data = herb_2019 %>% dplyr::filter(., Transect_ID != "Rural"),  family = binomial(link = logit))
)
# AIC <2 apart; both "best models" though main effects model has lower AIC

```

###### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
glmer(Herbivory_mean_Sept  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
     data = herb_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
     family = binomial(link = logit))
# singular...

car::Anova(glmer(Herbivory_mean_Sept  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
     data = herb_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
     family = binomial(link = logit))
)
# nothing significant


# Just main effects
car::Anova(glmer(Herbivory_mean_Sept  ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
     data = herb_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
     family = binomial(link = logit)))
# singular... nothing significant



### CROSSED RANDOM EFFECTS-----
# Full model
glmer(Herbivory_mean_Sept  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = herb_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
       family = binomial(link = logit))
#  singular...

car::Anova(glmer(Herbivory_mean_Sept  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = herb_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
       family = binomial(link = logit)))
# nothing significant


# Just main effects
car::Anova(glmer(Herbivory_mean_Sept  ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,
     data = herb_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
       family = binomial(link = logit)))
# singular... nothing significant


AIC(glmer(Herbivory_mean_Sept  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
     data = herb_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
     family = binomial(link = logit))
)

AIC(glmer(Herbivory_mean_Sept  ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,
     data = herb_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
     family = binomial(link = logit))
)
# AIC <2 apart; both "best models" though main effects model has lower AIC

```



## Survival
### glmer
#### Entire gradient: *Nothing sig for either
##### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################


### NESTED RANDOM EFFECTS-----
glmer(Dead ~ (1|Block) + (1|Population/Family) + City_dist,
  data = surv_2019,
  family = binomial(link = "logit"),
  nAGQ=0,
  control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5)))
# CONVERGES when I set nAGQ to 0

car::Anova(glmer(Dead ~ (1|Block) + (1|Population/Family) + City_dist,
  data = surv_2019,
  family = binomial(link = "logit"),
  nAGQ=0,
  control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# nothing significant



### CROSSED RANDOM EFFECTS-----
glmer(Dead ~ (1|Block) + (1|Population:Family) + City_dist,
  data = surv_2019,
  family = binomial(link = "logit"),
  nAGQ=0,
  control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5)))
# no problems


car::Anova(glmer(Dead ~ (1|Block) + (1|Population:Family) + City_dist,
  data = surv_2019,
  family = binomial(link = "logit"),
  nAGQ=0,
  control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# nothing significant

```

##### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################


### NESTED RANDOM EFFECTS-----
glmer(Dead ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = surv_2019,
  family = binomial(link = "logit"),
  nAGQ=0,
  control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5)))
# CONVERGES when I set nAGQ to 0

car::Anova(glmer(Dead ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = surv_2019,
  family = binomial(link = "logit"),
  nAGQ=0,
  control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# nothing significant



### CROSSED RANDOM EFFECTS-----
glmer(Dead ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = surv_2019,
  family = binomial(link = "logit"),
  nAGQ=0,
  control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5)))
# no problems


car::Anova(glmer(Dead ~ (1|Block) + (1|Population:Family) + Urb_score,
  data = surv_2019,
  family = binomial(link = "logit"),
  nAGQ=0,
  control=glmerControl(optimizer="bobyqa",
                                 optCtrl=list(maxfun=2e5))))
# nothing significant


```


#### Urban subtransects: *interaxn sig for city_dist when crossed; nothing sig for urb_score
##### City_dist
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
glmer(Dead  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = surv_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = binomial(link = "logit"),
  nAGQ=0,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# no problems!

car::Anova(glmer(Dead  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = surv_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = binomial(link = "logit"),
  nAGQ=0,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# interaxn marg significant


# Just main effects
car::Anova(glmer(Dead  ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = surv_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = binomial(link = "logit"),
  nAGQ=0,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# nothing significant



### CROSSED RANDOM EFFECTS-----
# Full model
glmer(Dead  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
  data = surv_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = binomial(link = "logit"),
  nAGQ=0,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# No warnings

car::Anova(glmer(Dead  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
  data = surv_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = binomial(link = "logit"),
  nAGQ=0,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# interaxn is significant



AIC(glmer(Dead  ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,
                 data = surv_2019 %>% dplyr::filter(., Transect_ID != "Rural"),        family = binomial(link = "logit"),
                 nAGQ=0,
                 glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))

AIC(glmer(Dead  ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,
                 data = surv_2019 %>% dplyr::filter(., Transect_ID != "Rural"),        family = binomial(link = "logit"),
                 nAGQ=0,
                 glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# AIC >2 apart; full model is "best model"
```


##### Urb_score
```{r}
# NO DIFFERENCE BETWEEN MODELS W/ CROSSED VS NESTED RANDOM EFFECTS #
###################################################################

### NESTED RANDOM EFFECTS-----
# Full model
glmer(Dead  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = surv_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = binomial(link = "logit"),
  nAGQ=0,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# no problems!

car::Anova(glmer(Dead  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = surv_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = binomial(link = "logit"),
  nAGQ=0,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# nothing significant


# Just main effects
car::Anova(glmer(Dead  ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = surv_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = binomial(link = "logit"),
  nAGQ=0,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# nothing significant



### CROSSED RANDOM EFFECTS-----
# Full model
glmer(Dead  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
  data = surv_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = binomial(link = "logit"),
  nAGQ=0,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# No warnings

car::Anova(glmer(Dead  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
  data = surv_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = binomial(link = "logit"),
  nAGQ=0,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# nothing significant


# Just main effects
car::Anova(glmer(Dead  ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,
                 data = surv_2019 %>% dplyr::filter(., Transect_ID != "Rural"),
                 family = binomial(link = "logit"),
                 nAGQ=0,
                 glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# nothing significant


AIC(glmer(Dead  ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,
                 data = surv_2019 %>% dplyr::filter(., Transect_ID != "Rural"),        family = binomial(link = "logit"),
                 nAGQ=0,
                 glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))

AIC(glmer(Dead  ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,
                 data = surv_2019 %>% dplyr::filter(., Transect_ID != "Rural"),        family = binomial(link = "logit"),
                 nAGQ=0,
                 glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# AIC <2 apart; both "best models" though full model lower AIC
```


# Statistics: 2020
## comparing lmer w/glmmTMB
```{r}
# # lmer
# lmer_m1 <- lmer(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020, REML = F)
# 
# car_anova_lmer <- car::Anova(lmer_m1)
# Anova.glmmTMB(lmer_m1, # doesn't run
#               type = "II")
# 
# # glmmTMB
# glmmTMB_m1 <- glmmTMB(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020,
#   REML = F,
#   family = gaussian)
# 
# car_anova_glmmtmb <- car::Anova(glmmTMB_m1)
# anova_glmmtmb <- Anova.glmmTMB(glmmTMB_m1,
#               type = "II")
# 
# 
# anova_comparison <- bind_rows(tidy(car_anova_lmer),
#           tidy(car_anova_glmmtmb),
#           tidy(anova_glmmtmb)) %>%
#   add_column(Model = c("car::Anova(lmer model)", "car::Anova(glmmTMB model)", "Anova.glmmTMB(glmmTMB model)"), .before = "term") %>%
#   write.csv("comparing_ANOVAs_lmer_glmmtmb.csv")
```

## reproductive
### Plants that flowered
#### Flowering success
##### Sig difference between urb vs rural? (Odds ratio)
```{r}
# # How many plants flowered per subtransect? using 2019 alive plants
# tib1 <- reproductive %>%
#   filter(Alive_DC1 != '0')%>%
#   group_by(Flowered2020, Urb_Rur) %>%
#   tally()
# tib1
# 
# 
# Flowered_ttest <- matrix(c(21, 3, 556, 282), nrow = 2,
#                          dimnames = list(
#                            c("Urban", "Rural"),
#                            c("Flowered", "Didn't Flower")))
# 
# fisher.test(Flowered_ttest, alternative = "two.sided")
# # odds ratio = 3.5464
# # p = 0.02859
# # medium effect size


# How many plants flowered per subtransect? using 2020 alive plants
reproductive <- anti_join(reproductive, dead_2020, by = c("Row", "Column"))

tib2 <- reproductive %>%
  group_by(Flowered2020, Urb_Rur) %>%
  tally()
tib2


Flowered_ttest2 <- matrix(c(
  as.integer(tib2[3,3]),
  as.integer(tib2[4,3]),
  as.integer(tib2[1,3]),
  as.integer(tib2[2,3])),
  nrow = 2,
  dimnames = list(
    c("Urban", "Rural"),
    c("Flowered", "Didn't Flower")))

fisher.test(Flowered_ttest2, alternative = "two.sided")
# odds ratio = 3.5148
# p = 0.0445
# medium effect size

chisq.test(Flowered_ttest2)
# X-squared = 3.7416, df = 1, p-value = 0.05307





# How many populations had at least one plant flower per subtransect? using 2020 alive plants
reproductive <- anti_join(reproductive, dead_2020, by = c("Row", "Column"))

tib3 <- reproductive[,c(1:6, 78:86)] %>%
  group_by(Population, Flowered2020, Urb_Rur) %>%
  dplyr::summarise(Pops = n_distinct(Population),
                   Urb_Rur = first(Urb_Rur)) %>%
  group_by(Population, Urb_Rur) %>%
  dplyr::summarise(Flowered = sum(as.integer(Flowered2020)),
                   Urb_Rur = first(Urb_Rur)) %>%
  group_by(Urb_Rur, Flowered) %>%
  dplyr::summarise(Pops = n_distinct(Population))
  
tib3
# Flowered = 1: Didn't flower
# Flowered = 3: Did flower



Flowered_ttest3 <- matrix(c(
  as.integer(tib3[2,3]),
  as.integer(tib3[4,3]),
  as.integer(tib3[3,3]),
  as.integer(tib3[2,3])),
  nrow = 2,
  dimnames = list(
    c("Urban", "Rural"),
    c("Flowered", "Didn't Flower")))

fisher.test(Flowered_ttest3, alternative = "two.sided")
# odds ratio = 3.5750
# p = 0.1006 (NOT SIGNIFICANT; CAN'T REJECT NULL)
# medium effect size


chisq.test(Flowered_ttest3)
# X-squared = 2.0551, df = 1, p-value = 0.1517
```



##### Sig difference between urb:north vs urb:south? (Odds ratio)
```{r}
# How many plants flowered per subtransect? using 2020 alive plants
reproductive <- anti_join(reproductive, dead_2020, by = c("Row", "Column"))

tib4 <- reproductive %>%
  filter(., Transect_ID != 'Rural') %>%
  group_by(Flowered2020, Transect_ID) %>%
  tally()
tib4


Flowered_ttest4 <- matrix(c(
  as.integer(tib4[3,3]),
  as.integer(tib4[4,3]),
  as.integer(tib4[1,3]),
  as.integer(tib4[2,3])),
  nrow = 2,
  dimnames = list(
    c("North", "South"),
    c("Flowered", "Didn't Flower")))

fisher.test(Flowered_ttest4, alternative = "two.sided")
# odds ratio = 0.7970 (inverted = 1.2547)
# p = 0.6618 (CAN'T REJECT THE NULL)
# negligible effect size

chisq.test(Flowered_ttest4)
# X-squared = 0.081128, df = 1, p-value = 0.7758






# How many populations had at least one plant flower per subtransect? using 2020 alive plants
reproductive <- anti_join(reproductive, dead_2020, by = c("Row", "Column"))

tib5 <- reproductive[,c(1:6, 78:86)] %>%
  filter(., Transect_ID != "Rural") %>%
  group_by(Population, Flowered2020, Transect_ID) %>%
  dplyr::summarise(Pops = n_distinct(Population),
                   Transect_ID = first(Transect_ID)) %>%
  group_by(Population, Transect_ID) %>%
  dplyr::summarise(Flowered = sum(as.integer(Flowered2020)),
                   Transect_ID = first(Transect_ID)) %>%
  group_by(Transect_ID, Flowered) %>%
  dplyr::summarise(Pops = n_distinct(Population))
  
tib5
# Flowered = 1: Didn't flower
# Flowered = 3: Did flower



Flowered_ttest5 <- matrix(c(
  as.integer(tib5[2,3]),
  as.integer(tib5[4,3]),
  as.integer(tib5[3,3]),
  as.integer(tib5[2,3])),
  nrow = 2,
  dimnames = list(
    c("North", "South"),
    c("Flowered", "Didn't Flower")))

fisher.test(Flowered_ttest5, alternative = "two.sided")
# odds ratio = 0.4737 (reciprocal = 2.1110)
# p = 0.4521 (NOT SIGNIFICANT; CAN'T REJECT NULL)
# small effect size

chisq.test(Flowered_ttest5)
# X-squared = 0.41878, df = 1, p-value = 0.5175
```


##### Block effect?
```{r}
glmer(Flowered2020 ~ Block + (1|Population/Family),
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=1,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))

car::Anova(glmer(Flowered2020 ~ Block + (1|Population/Family),
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=1,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# Block is significant, so yes, the number of plants that flowered DID significantly vary by block.

summary(glmer(Flowered2020 ~ Block + (1|Population/Family),
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=1,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
```

#### Flower count: HOLD OFF until 2021- too few plants and will probably overfit all models
##### Mean flower count/inflorescence
###### Sig difference along gradient?
####### glmer: diagnostics (**YES: Both city_dist and urb_score significant)
```{r}
flowercount_2020_lmer_gradient <- glmer(mean_flower_count ~
                                          (1|Block) +
                                          (1|Population/Family) +
                                          City_dist, 
                                        REML = F,
                                        data = flowering_2020,
                                        family = "poisson")
res <- simulateResiduals(flowercount_2020_lmer_gradient)
plot(res)
testDispersion(flowercount_2020_lmer_gradient)
hist(flowering_2020$mean_flower_count, breaks = 20)

# is singular
summary(flowercount_2020_lmer_gradient)
```

####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----

# ANOVA
car::Anova(flowercount_2020_lmer_gradient)
# distance is sig

library(MuMIn)
r.squaredGLMM(flowercount_2020_lmer_gradient)


### CROSSED RANDOM EFFECTS-----
lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F))
# distance is sig


# ANy variation among families or populations?
ranova(lmer(mean_flower_count ~ (1|Population/Family), data = flowering_2020, REML = T))
# no... is singular
```

####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
flowercount_2020_lmer_gradient_urbscore <- lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
# is singular

# ANOVA
car::Anova(flowercount_2020_lmer_gradient_urbscore)
# sig

library(MuMIn)
r.squaredGLMM(flowercount_2020_lmer_gradient_urbscore)


### CROSSED RANDOM EFFECTS-----
lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F))
#  sig

```

##### Sig difference btwn urban subtransects?
###### lmer: *NO: Nothing sig for city_dist or urb_score
###### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
flowercount_2020_lmer_subtr <- lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(flowercount_2020_lmer_subtr)
# nothing sig
AIC(flowercount_2020_lmer_subtr)

car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# nothing sig

r.squaredGLMM(flowercount_2020_lmer_subtr)
# is this worth doing, since I have two regression lines?

AIC(lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig


car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig



# ANy variation among families or populations?
ranova(lmer(mean_flower_count ~ (1|Population/Family), data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = T))
# no... is singular
car::Anova(lmer(mean_flower_count ~ (1|Population/Family) + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# no... is singular

```
###### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
flowercount_2020_lmer_subtr_urbscore <- lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(flowercount_2020_lmer_subtr_urbscore)
# nothing sig
AIC(flowercount_2020_lmer_subtr_urbscore)

car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# nothing sig

r.squaredGLMM(flowercount_2020_lmer_subtr_urbscore)
# is this worth doing, since I have two regression lines?

AIC(lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig


car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig

```

##### Total flower count
###### Sig difference along gradient?
####### glmer: *Marginally sig for city_dist, insig for urb_score
######## City_dist
```{r}
### nested RANDOM EFFECTS-----
flowercountsum_2020_glmer_gradient <- glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, family = 'poisson')
# is singular...


# ANOVA
car::Anova(flowercountsum_2020_glmer_gradient)
# distance is marginally sig

r.squaredGLMM(flowercountsum_2020_glmer_gradient)


### CROSSED RANDOM EFFECTS-----
glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, family = 'poisson')
# NOT singular!


# ANOVA
car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, family = 'poisson')
)
# distance is marginally sig




# ANy variation among families or populations?
# ranova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, family = 'poisson'))
```

######## Urb_score
```{r}
### nested RANDOM EFFECTS-----
flowercountsum_2020_glmer_gradient_urbscore <- glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, family = 'poisson')
# is singular...


# ANOVA
car::Anova(flowercountsum_2020_glmer_gradient_urbscore)
# not sig

r.squaredGLMM(flowercountsum_2020_glmer_gradient_urbscore)


### CROSSED RANDOM EFFECTS-----
glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, family = 'poisson')
# NOT singular!


# ANOVA
car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, family = 'poisson')
)
# not sig

```

###### Sig difference btwn urban subtransects?
####### glmer: *NO for both city_dist & urb_score
######## City_dist
```{r}
### NESTED RANDOM EFFECTS-----
flowercountsum_2020_glmer_subtr <- glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
                                     data = flowering_2020 %>% filter(Transect_ID != "Rural"))
# singular

# ANOVA
car::Anova(flowercountsum_2020_glmer_subtr)
AIC(flowercountsum_2020_glmer_subtr)
# nothing sig


car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural")))
# nothing sig

car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural")))
# nothing sig



### CROSSED RANDOM EFFECTS-----
glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
# singular

# ANOVA
car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
)
AIC(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
)
# nothing sig


car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
)
# nothing sig
AIC(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
)

```

######## Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
flowercountsum_2020_glmer_subtr_urbscore <- glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
                                     data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
# singular

# ANOVA
car::Anova(flowercountsum_2020_glmer_subtr_urbscore)
AIC(flowercountsum_2020_glmer_subtr_urbscore)
# nothing sig


car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson))
# nothing sig

car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson))
# nothing sig



### CROSSED RANDOM EFFECTS-----
glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
# NOT singular

# ANOVA
car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
)
AIC(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
)
# nothing sig


car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
)
# nothing sig
AIC(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
)

```


#### Flower size: HOLD OFF until 2021- too few plants and will probably overfit all models
##### Mean flower size/inflorescence
###### lmer
####### gradient: *NOt sig for either city_dist or urb_score
######## City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
# is singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)
# distance not sig

library(MuMIn)
r.squaredGLMM(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F))
# distance not sig


# ANy variation among families or populations?
ranova(lmer(Overall_mean ~ (1|Population/Family), data = flowering_2020, REML = T))
# no
```


######## Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020,
     REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)
# not sig

library(MuMIn)
r.squaredGLMM(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F))
# urb_score not sig

```

####### urban subtransects: *Main effects sig for both; interaxn sig for city_dist (marg sig for urb_score)
######## City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Overall_mean ~ (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# main effects and interaxn sig

car::Anova(lmer(Overall_mean ~  (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular,  everything  sig

AIC(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# both main effects sig

r.squaredGLMM(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# very high r-sq...is this worth doing, since I have two regression lines?

AIC(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# NOT singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# everything sig


car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects sig



# ANy variation among families or populations?
ranova(lmer(Overall_mean ~ (1|Population/Family), data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = T))
# no
car::Anova(lmer(Overall_mean ~ (1|Population/Family) + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# YES... variance DOES differ by subtransect... is singular

```
######## Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Overall_mean ~ (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# main effects sig

car::Anova(lmer(Overall_mean ~  (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular, main effects sig

AIC(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# both main effects sig

r.squaredGLMM(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# very high r-sq...is this worth doing, since I have two regression lines?

AIC(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects sig


car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects sig

```

#### Pods: HOLD OFF until 2021- too few plants and will probably overfit all models
##### lmer
###### gradient: *NOt sig for either city_dist or urb_score
####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
# is singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)
# distance not sig

r.squaredGLMM(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F))
# distance not sig


# ANy variation among families or populations?
ranova(lmer(Pods ~ (1|Population/Family), data = flowering_2020, REML = T))
# no
```


####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020,
     REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)
# not sig

r.squaredGLMM(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F))
# urb_score not sig

```

###### urban subtransects: *Main effects marg sig for city_dist; nothing sig for urb_score)
####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Pods ~ (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# main effects marg sig

car::Anova(lmer(Pods ~  (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular, main effects marg  sig

AIC(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# both main effects marg sig

r.squaredGLMM(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# very high r-sq...is this worth doing, since I have two regression lines?

AIC(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
#  singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects marg sig


car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects marg sig



# ANy variation among families or populations?
ranova(lmer(Pods ~ (1|Population/Family), data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = T))
# no
car::Anova(lmer(Pods ~ (1|Population/Family) + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# no ...variance doesn't differ by subtransect

```
####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Pods ~ (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# nothing sig

car::Anova(lmer(Pods ~  (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular,nothing sig

AIC(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# both main effects NOT sig

r.squaredGLMM(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

AIC(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig

car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig

```

#### Peduncles (Inflorescences): HOLD OFF until 2021- too few plants and will probably overfit all models
##### lmer
###### gradient: *NOt sig for either city_dist or urb_score
####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
# is singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)
# distance not sig

r.squaredGLMM(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F))
# distance not sig


# ANy variation among families or populations?
ranova(lmer(Peduncles ~ (1|Population/Family), data = flowering_2020, REML = T))
# no
```


####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020,
     REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)
# not sig

r.squaredGLMM(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F))
# urb_score not sig

```

###### urban subtransects: *nothing sig for city_dist (transect marg sig when interaction included but becomes non-sig when only main effects present); transect marg sig for urb_score)
####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Peduncles ~ (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# transect marg sig

car::Anova(lmer(Peduncles ~  (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular, transect marg  sig

AIC(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# nothing sig

r.squaredGLMM(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

AIC(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
#  singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# transect marg sig


car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig



# ANy variation among families or populations?
ranova(lmer(Peduncles ~ (1|Population/Family), data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = T))
# no
car::Anova(lmer(Peduncles ~ (1|Population/Family) + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# no ...variance doesn't differ by subtransect

```
####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Peduncles ~ (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# transect is marg sig

car::Anova(lmer(Peduncles ~  (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular, transect marg sig

AIC(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# transect marg sig

r.squaredGLMM(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

AIC(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# transect marg sig

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# transect marg sig

```


### All plants
#### Regressions (is urbanization related to flowering?)
##### glmer: diagnostics
```{r}
# GRADIENT / CITY_DIST
flowering_gr_city_m1 <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + City_dist,
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=0)

res <- simulateResiduals(flowering_gr_city_m1)
plot(res) # looks great!




# GRADIENT / URB SCORE
flowering_gr_urb_m1 <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=0)

res <- simulateResiduals(flowering_gr_urb_m1)
plot(res) # looks great!





# URBAN SUBTRANSECTS / CITY_DIST
flowering_urbsubs_city_m1 <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = reproductive %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ=0)

res <- simulateResiduals(flowering_urbsubs_city_m1)
plot(res) # looks great!

# main effects:
flowering_urbsubs_city_m1_ME <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = reproductive %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ=0)




# URBAN SUBTRANSECTS / URB SCORE
flowering_urbsubs_usc_m1 <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = reproductive %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ=0)

res <- simulateResiduals(flowering_urbsubs_usc_m1)
plot(res) # looks great!

# main effects:
flowering_urbsubs_usc_m1_ME <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = reproductive %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ=0)
```

##### Entire gradient: *Nothing sig for either
###### City_dist
```{r}
car::Anova(flowering_gr_city_m1)
# nothing significant



# ANy variation within families or populations?

##### TACTIC 1: try bootstrapping #####
# NOT PERFECT b/c can't nest family within pop but trying a few ways to get at the correct answer.
# https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html#test-of-random-parameter
library(pbkrtest)
library(pbnm)

# JUST POPULATION
gmm <-  glmer(Flowered2020 ~ City_dist + (1|Population), # can't leave in Family... doesn't work
              family = binomial(link = "logit"),
              data = reproductive,
             nAGQ = 0)

# IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
gmm1 <-  glmer(Flowered2020 ~ City_dist + (1|Population/Family), 
              family = binomial(link = "logit"),
              data = reproductive,
             nAGQ = 0)

# POP:FAMILY
gmm2 <-  glmer(Flowered2020 ~ City_dist + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
              family = binomial(link = "logit"),
              data = reproductive,
             nAGQ = 0)

# UNIQUE FAMILIES
reproductive$Family_unique <- paste(reproductive$Population, reproductive$Family)
gmm3 <-  glmer(Flowered2020 ~ City_dist + (1|Family_unique),
              family = binomial(link = "logit"),
              data = reproductive,
             nAGQ = 0)

# EQUIVALENT TO FAM NESTED W/IN POP
gmm4 <-  glmer(Flowered2020 ~ City_dist + (1|Population:Family) + (1|Population),
              family = binomial(link = "logit"),
              data = reproductive,
             nAGQ = 0)


# REDUCED MODEL
gmmDG1 <- glm(Flowered2020 ~ City_dist,
              family = binomial(link = "logit"),
              data = reproductive)

### RESULTS ###
# POPULATION (so, results are about populations)
pbgmmDg1 <- pbnm(gmm,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
summary(pbgmmDg1) # p = 0.031...  var among pops

# EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
pbgmmDg4 <- pbnm(gmm4,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
ranova_pop <- summary(pbgmmDg4) %T>%
  print() # p = 0.028... var among pops accounting for fams

# POP:FAMILY (so, results are about families)- accounts for fams being in same pop
pbgmmDg2 <- pbnm(gmm2,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
ranova_fam <- summary(pbgmmDg2) %T>%
  print() # p = 0.191... little var among families crossed w/ pops

# UNIQUE FAMILIES (so, results are about families)
pbgmmDg3 <- pbnm(gmm3,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
summary(pbgmmDg3) # p = 0.258... little var among families, period




##### use anova to test significance of terms (this isn't what we want, though): #####
## test Pop/Fam
# anova(gmm1, gmmDG1) # p = 0.235
# 
# ## test Pop/Fam but expanded
# anova(gmm4, gmmDG1) # p = 0.235      # SAME AS ABOVE
# 
# ## test Pop
# anova(gmm, gmmDG1) # p = 0.088*
# 
# ## test Fam
# anova(gmm3, gmmDG1) # p = 0.587
# 
# ## test pop:fam
# anova(gmm2, gmmDG1) # p = 0.587     # SAME AS ABOVE



#--------- FINAL RESULTS: ----------#
# Bootstrapping:
# - Pop: SIGNIFICANT
# - Family: NOT SIGNIFICANT
# anova:
# - Pop: SIGNIFICANT
# - Family: NOT SIGNIFICANT

# --- DO THE 2 METHODS MATCH? ---#
#       [X]    YES!
#             

##### TACTIC 2- comparing full to reduced models #####
# m.1 <- glmer(Flowered2020 ~ (1|Population/Family) + (0+Flowered2020|Population/Family) + City_dist, data = reproductive,   family = binomial(link = "logit"),
#              nAGQ = 0)
# 
# m.2 <- glmer(Flowered2020 ~ (1|Population/Family) + City_dist, data = reproductive,   family = binomial(link = "logit"),
#              nAGQ = 0)
# 
# m.3 <- glm(Flowered2020 ~  City_dist, data = reproductive,   family = binomial(link = "logit"))
# car::Anova(m.1)
# car::Anova(m.2)
# car::Anova(m.3)
# 
# 
# 
# 
# pbkrtest::PBmodcomp(m.2,m.1,seed=101)

#### TACTIC 3: BOOTSTRAP W/A DIFF PACKAGE #####
# anova_merMod<-function(model,rand,w=NULL,seed=round(runif(1,0,100),0),nsim=50){
#   data<-model@frame
#   if(!is.null(w)){
#     data<-data[,-grep("(weights)",names(data))]
#   }
#   
#   resp<-names(model.frame(model))[1]
#   #generate a list of reduced model formula
#   fs<-list()
#   fs[[1]]<-as.formula(paste(resp,"~ 1 +",rand))
#   nb_terms<-length(attr(terms(model),"term.labels"))
#   if(nb_terms>1){
#     for(i in 1:nb_terms){
#       tmp<-c(attr(terms(model),"term.labels")[1:i],rand)
#       fs[[i+1]]<-reformulate(tmp,response=resp)
#     }      
#   }
#   #fit the reduced model to the data
#   
#   fam<-family(model)[1]$family
#   if(fam=="gaussian"){
#     m_fit<-lapply(fs,function(x) lmer(x,data,REML=FALSE))
#   } else if(fam=="binomial"){
#     m_fit<-lapply(fs,function(x) glmer(x,data,family=fam,weights=w))
#   }  else{
#     m_fit<-lapply(fs,function(x) glmer(x,data,family=fam))
#   }
#   #compare nested model with one another and get LRT values (ie increase in the likelihood of the models as parameters are added)
#   tab_out<-NULL
#   
#   for(i in 1:(length(m_fit)-1)){
#     comp<-PBmodcomp(m_fit[[i+1]],m_fit[[i]],seed=seed,nsim=nsim)    
#     term_added<-attr(terms(m_fit[[i+1]]),"term.labels")[length(attr(terms(m_fit[[i+1]]),"term.labels"))]
#     #here are reported the bootstrapped p-values, ie not assuming any parametric distribution like chi-square to the LRT values generated under the null model
#     #these p-values represent the number of time the simulated LRT value (under null model) are larger than the observe one
#     tmp<-data.frame(term=term_added,LRT=comp$test$stat[1],p_value=comp$test$p.value[2])
#     tab_out<-rbind(tab_out,tmp)
#     print(paste("Variable ",term_added," tested",sep=""))
#   }  
#   print(paste("Seed set to:",seed))
#   return(tab_out)  
# }
# 
# anova_merMod(gmm1,rand = "(1|Population/Family)",w = rep(10,100))



##### old code #####

sum.1 <- summary(gmm4)

variances1 <- print(VarCorr(gmm4),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)

# export percent variance explained
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Floweringsuccess_glmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)

# export ranova
sink(here::here("./Figures_Tables/ranova_PVE/2020_Floweringsuccess_glmer_ranova.csv"))
print("POPULATION", sep="\n\n")
print(ranova_pop, sep="\n\n")
  cat("\n")
print("FAMILY", sep="\n\n")
print(ranova_fam, sep="\n\n")
  cat("\n")
if (ranova_pop[1] <= 0.05){
  print ('There is variance among populations')}
if (ranova_pop[1] > 0.05){
  print ("There is not much variance among populations")}
if (ranova_fam[1] <= 0.05){
  print ("There is variance among families")}
if (ranova_fam[1] > 0.05){
  print ("There is not much variance among families")}
sink()

# write.table(ranova(m.1), "~/R_Projects/Chapter2_KSR/Figures_Tables/ranova_PVE/2020_Floweringsuccess_glmer_PVE.csv", col.names=TRUE, sep=",")

```

###### Urb_score
```{r}
car::Anova(flowering_gr_urb_m1)
# not sig


```

##### Urban subtransects: *Nothing sig for either
###### City_dist
```{r}
car::Anova(flowering_urbsubs_city_m1) # nothing sig
car::Anova(flowering_urbsubs_city_m1_ME) # nothing sig

AIC(flowering_urbsubs_city_m1, flowering_urbsubs_city_m1_ME) # <2 away
```

###### Urb_score
```{r}
car::Anova(flowering_urbsubs_usc_m1) # nothing sig
car::Anova(flowering_urbsubs_usc_m1_ME) # nothing sig

AIC(flowering_urbsubs_usc_m1, flowering_urbsubs_usc_m1_ME) # <2 away
```


##### Export ANOVAs
```{r}

anova_table_flx(flowering_gr_city_m1)
anova_table_flx(flowering_gr_urb_m1)
anova_table_flx(flowering_urbsubs_city_m1)
anova_table_flx(flowering_urbsubs_city_m1_ME)
anova_table_flx(flowering_urbsubs_usc_m1)
anova_table_flx(flowering_urbsubs_usc_m1_ME)

AIC_compare.city_dist(flowering_urbsubs_city_m1, flowering_urbsubs_city_m1_ME)
AIC_compare.urb_score(flowering_urbsubs_usc_m1, flowering_urbsubs_usc_m1_ME)
       
# list of models
# model_list <- list(flowering_gr_city_m1,
# flowering_gr_urb_m1,
# flowering_urbsubs_city_m1,
# flowering_urbsubs_city_m1_ME,
# flowering_urbsubs_usc_m1,
# flowering_urbsubs_usc_m1_ME)
```

## Heights
### June height
#### lmer: diagnostics
```{r}
# GRADIENT / CITY_DIST-----

# Height_Jun20_gr_city_m1 <- lmer(Total_Height_June ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(Height_Jun20_gr_city_m1, type = "diag") # is singular & right-skewed
# 
# Height_Jun20_gr_city_m2 <- lmer(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(Height_Jun20_gr_city_m2, type = "diag") # looks good though singular... take out block
# 
# Height_Jun20_gr_city_m3 <- lmer(sqrt(Total_Height_June) ~  (1|Population/Family) + City_dist,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(Height_Jun20_gr_city_m3, type = "diag") # looks good
# 
# AIC(Height_Jun20_gr_city_m2, Height_Jun20_gr_city_m3) #model with block has significantly lower AIC, so I should leave in block
# 
# Height_Jun20_gr_city_m4 <- lmer(sqrt(Total_Height_June) ~ (1|Block) + (1|Population) +  City_dist,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(Height_Jun20_gr_city_m4, type = "diag") # looks good 
# 
# AIC(Height_Jun20_gr_city_m2, Height_Jun20_gr_city_m4) #model with Pop/Fam has >4  lower AIC, so I should leave in Pop/Fam
# 
# car::Anova(Height_Jun20_gr_city_m2) # very similar results to anova below!
# car::Anova(Height_Jun20_gr_city_m4)

# try glmmTMB
Height_Jun20_gr_city_m5 <- glmmTMB(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_both_2020,
  family = gaussian) # it works! use this




# GRADIENT / URB SCORE-----

# Height_Jun20_gr_usc_m1 <- lmer(Total_Height_June ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(Height_Jun20_gr_usc_m1, type = "diag") # right-skewed

Height_Jun20_gr_usc_m2 <- lmer(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_both_2020, REML = F)
sjPlot::plot_model(Height_Jun20_gr_usc_m2, type = "diag") # looks good



# URB SUBTRANSECTS / CITY_DIST-----

# Height_Jun20_urbsubs_city_m1 <- lmer(Total_Height_June ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(Height_Jun20_urbsubs_city_m1, type = "diag") # right-skewed

Height_Jun20_urbsubs_city_m2 <- lmer(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  REML = F)
sjPlot::plot_model(Height_Jun20_urbsubs_city_m2, type = "diag") # looks good

# main effects
Height_Jun20_urbsubs_city_m2_ME <- lmer(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  REML = F)




# URB SUBTRANSECTS / URB SCORE-----

# Height_Jun20_urbsubs_usc_m1 <- lmer(Total_Height_June ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(Height_Jun20_urbsubs_usc_m1, type = "diag") # right-skewed & singular

Height_Jun20_urbsubs_usc_m2 <- lmer(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  REML = F,
      control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(Height_Jun20_urbsubs_usc_m2, type = "diag") # looks good

# main effects
Height_Jun20_urbsubs_usc_m2_ME <- lmer(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  REML = F,
    control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

summary(Height_Jun20_urbsubs_usc_m2_ME)
```

#### Entire gradient: *Marg sig for City_dist, not for urb_score
##### City_dist
```{r}
car::Anova(Height_Jun20_gr_city_m5) # marg sig




# ANy variation within families or populations?
m.1 <- lmer(sqrt(Total_Height_June) ~ (1|Population/Family), data = heights_both_2020, REML = T)

ranova(m.1)
# YES for among families


sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_JuneHeight_lmer_PVE.csv"), col.names=TRUE, sep=",")
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_JuneHeight_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)


# METHOD 2
# pbnm_m1 <- lmer(sqrt(Total_Height_June) ~ (1|Population/Family) + City_dist, data = heights_both_2020, REML = T)
# 
# pbnm_m2 <- lm(sqrt(Total_Height_June) ~  City_dist, data = heights_both_2020 , REML = T)
# 
# anova(pbnm_m1, pbnm_m2) # sig: p = 0.014*
# 
# 
# ##### use anova to test significance of terms (this isn't what we want, though): #####
# # JUST POPULATION
# gmm <-  lmer(sqrt(Total_Height_June) ~ City_dist + (1|Population),
#               data = heights_both_2020, REML = T)
# 
# # IDEAL MODEL (DOESN'T WORK for glmer THOUGH)
# gmm1 <-  lmer(sqrt(Total_Height_June) ~ City_dist + (1|Population/Family), 
#               data = heights_both_2020, REML = T)
# 
# # POP:FAMILY
# gmm2 <-  lmer(sqrt(Total_Height_June) ~ City_dist + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#               data = heights_both_2020, REML = T)
# 
# # UNIQUE FAMILIES
# heights_both_2020$Family_unique <- paste(heights_both_2020$Population, heights_both_2020$Family)
# gmm3 <-  lmer(sqrt(Total_Height_June) ~ City_dist + (1|Family_unique),
#               data = heights_both_2020, REML = T)
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4 <-  lmer(sqrt(Total_Height_June) ~ City_dist + (1|Population:Family) + (1|Population),
#               data = heights_both_2020, REML = T)
# 
# 
# 
# # test Pop/Fam
# anova(gmm1, pbnm_m2) # p = 0.014* - POP/FAM IS SIGNIFICANT
# 
# ## test Pop/Fam but expanded
# anova(gmm4, pbnm_m2) # p = 0.014*      SAME AS ABOVE
# 
# ## test Pop
# anova(gmm, pbnm_m2) # p = 0.131 - POP IS *NOT* SIGNIFICANT
# 
# ## test Fam
# anova(gmm3, pbnm_m2) # p = 0.004*  - FAM IS SIGNIFICANT
# 
# ## test pop:fam
# anova(gmm2, pbnm_m2) # p = 0.004*     SAME AS ABOVE


```

##### Urb_score
```{r}
car::Anova(Height_Jun20_gr_usc_m2) # not sig
```

#### Urban subtransects: *Not sig for either
##### City_dist
```{r}
car::Anova(Height_Jun20_urbsubs_city_m2) # nothing sig
car::Anova(Height_Jun20_urbsubs_city_m2_ME) # nothing sig




# ANy variation among families or populations?
m.1 <- lmer(sqrt(Total_Height_June) ~ (1|Population/Family),
            data = heights_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
            REML = T)
ranova(m.1)
# YES? (marg sig) for among families

m.2 <- lmer(sqrt(Total_Height_June) ~ (1|Population/Family) + Transect_ID,
            data = heights_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
            REML = F)
car::Anova(m.2)
# not among transects though


m.3 <- lmer(sqrt(Total_Height_June) ~ (1|Population/Family) + Transect_ID,
            data = heights_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
            REML = T)
car::Anova(m.3)
# not sig in this or m.2


sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_JuneHeight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",")
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_JuneHeight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
write.table(car::Anova(m.2), here::here("./Figures_Tables/ranova_PVE/2020_JuneHeight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)


```

##### Urb_score
```{r}
car::Anova(Height_Jun20_urbsubs_usc_m2) # not sig
car::Anova(Height_Jun20_urbsubs_usc_m2_ME) # not sig

```

#### Export ANOVA
```{r}
anova_table_flx(Height_Jun20_gr_city_m5)
anova_table_flx(Height_Jun20_gr_usc_m2)
anova_table_flx(Height_Jun20_urbsubs_city_m2)
anova_table_flx(Height_Jun20_urbsubs_city_m2_ME)
anova_table_flx(Height_Jun20_urbsubs_usc_m2)
anova_table_flx(Height_Jun20_urbsubs_usc_m2_ME)

AIC_compare.city_dist_transf(Height_Jun20_urbsubs_city_m2,
                      Height_Jun20_urbsubs_city_m2_ME)
    
AIC_compare.urb_score_transf(Height_Jun20_urbsubs_usc_m2,
                      Height_Jun20_urbsubs_usc_m2_ME) 

# list of models
# model_list <- append(model_list,
#                      list(
#                        Height_Jun20_gr_city_m5,
# Height_Jun20_gr_usc_m2,
# Height_Jun20_urbsubs_city_m2,
# Height_Jun20_urbsubs_city_m2_ME,
# Height_Jun20_urbsubs_usc_m2,
# Height_Jun20_urbsubs_usc_m2_ME
# ))
```

### Sept height
#### lmer: diagnostics
```{r}
# GRADIENT / CITY_DIST-----

# Height_Sept20_gr_city_m1 <- lmer(Total_Height_Sept ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020, REML = F,
#       control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(Height_Sept20_gr_city_m1, type = "diag") # right-skewed

Height_Sept20_gr_city_m2 <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_both_2020, REML = F)
sjPlot::plot_model(Height_Sept20_gr_city_m2, type = "diag") # looks good





# GRADIENT / URB SCORE-----

# Height_Sept20_gr_usc_m1 <- lmer(Total_Height_Sept ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(Height_Sept20_gr_usc_m1, type = "diag") # right-skewed
# 
# 
# Height_Sept20_gr_usc_m2 <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020, REML = F,
#         control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(Height_Sept20_gr_usc_m2, type = "diag") # looks good though singular... take out block 
# 
# Height_Sept20_gr_usc_m3 <- lmer(sqrt(Total_Height_Sept) ~ (1|Population/Family) + Urb_score,
#   data = heights_both_2020, REML = F,
#         control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(Height_Sept20_gr_usc_m3, type = "diag") # looks ok
# 
# AIC(Height_Sept20_gr_usc_m2, Height_Sept20_gr_usc_m3) # model with block has significantly lower AIC... leave it in
# 
# Height_Sept20_gr_usc_m4 <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population) + Urb_score,
#   data = heights_both_2020, REML = F,
#         control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(Height_Sept20_gr_usc_m4, type = "diag") # looks ok
# 
# 
# car::Anova(Height_Sept20_gr_usc_m2) # very similar results to model below
# car::Anova(Height_Sept20_gr_usc_m4)
# 
# 
# AIC(Height_Sept20_gr_usc_m2, Height_Sept20_gr_usc_m4) # nearly identical AIC... use m4

# try glmmTMB
Height_Sept20_gr_usc_m5 <- glmmTMB(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_both_2020,
  family = gaussian) # works! use this



# URB SUBTRANSECTS / CITY_DIST-----

# Height_Sept20_urbsubs_city_m1 <- lmer(Total_Height_Sept ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(Height_Sept20_urbsubs_city_m1, type = "diag") # right-skewed & singular
# 
# Height_Sept20_urbsubs_city_m2 <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#         control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(Height_Sept20_urbsubs_city_m2, type = "diag") # looks good but still singular... take out block
# 
# Height_Sept20_urbsubs_city_m3 <- lmer(sqrt(Total_Height_Sept) ~  (1|Population/Family) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#         control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(Height_Sept20_urbsubs_city_m3, type = "diag") # still singular... take out fam
# 
# Height_Sept20_urbsubs_city_m4 <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#         control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(Height_Sept20_urbsubs_city_m4, type = "diag") # looks ok 

# AIC(Height_Sept20_urbsubs_city_m2, Height_Sept20_urbsubs_city_m4) # nearly identical AIC
# 
# car::Anova(Height_Sept20_urbsubs_city_m4) # extremely similar results!
# car::Anova(Height_Sept20_urbsubs_city_m2)

# try glmmTMB
Height_Sept20_urbsubs_city_m5 <- glmmTMB(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = gaussian) # works! use this


# main effects
Height_Sept20_urbsubs_city_m5_ME <- glmmTMB(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = gaussian) # works! use this




# URB SUBTRANSECTS / URB SCORE-----

# Height_Sept20_urbsubs_usc_m1 <- lmer(Total_Height_Sept ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(Height_Sept20_urbsubs_usc_m1, type = "diag") # right-skewed


Height_Sept20_urbsubs_usc_m2 <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  REML = F)
sjPlot::plot_model(Height_Sept20_urbsubs_usc_m2, type = "diag") # looks good


# main effects
Height_Sept20_urbsubs_usc_m2_ME <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  REML = F,
    control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

summary(Height_Sept20_urbsubs_usc_m2_ME)
```
#### Entire gradient: *marginally sig for city_dist, not for urb_score
###### City_dist
```{r}
car::Anova(Height_Sept20_gr_city_m2) #marginally sig


# ANy variation within families or populations?
m.1 <- lmer(Total_Height_Sept ~ (1|Population/Family), data = heights_both_2020, REML = T)

ranova(m.1)
# YES for among families


sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_SeptHeight_lmer_PVE.csv"), col.names=TRUE, sep=",")
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_SeptHeight_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)

```

###### Urb_score
```{r}
car::Anova(Height_Sept20_gr_usc_m5) # not sig
```


#### Urban subtransects: *Not sig for either
###### City_dist
```{r}
car::Anova(Height_Sept20_urbsubs_city_m5) # not sig
car::Anova(Height_Sept20_urbsubs_city_m5_ME)# not sig


# ANy variation among families or populations?
m.1 <- lmer(sqrt(Total_Height_Sept) ~ (1|Population/Family),
            data = heights_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
            REML = T)
ranova(m.1)
# no

m.2 <- lmer(sqrt(Total_Height_Sept) ~ (1|Population/Family) + Transect_ID,
            data = heights_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
            REML = F)
car::Anova(m.2)
# not among transects either


m.3 <- lmer(sqrt(Total_Height_Sept) ~ (1|Population/Family) + Transect_ID,
            data = heights_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
            REML = T)
car::Anova(m.3)
# not sig in this or m.2


sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_SeptHeight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",")
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_SeptHeight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
write.table(car::Anova(m.2), here::here("./Figures_Tables/ranova_PVE/2020_SeptHeight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```


###### Urb_score
```{r}
car::Anova(Height_Sept20_urbsubs_usc_m2) # not sig
car::Anova(Height_Sept20_urbsubs_usc_m2_ME)# not sig
```

#### Export ANOVA
```{r}
anova_table_flx(Height_Sept20_gr_city_m2)
anova_table_flx(Height_Sept20_gr_usc_m5)
anova_table_flx(Height_Sept20_urbsubs_city_m5)
anova_table_flx(Height_Sept20_urbsubs_city_m5_ME)
anova_table_flx(Height_Sept20_urbsubs_usc_m2)
anova_table_flx(Height_Sept20_urbsubs_usc_m2_ME)

AIC_compare.city_dist_transf(Height_Sept20_urbsubs_city_m5,
                      Height_Sept20_urbsubs_city_m5_ME)
    
AIC_compare.urb_score_transf(Height_Sept20_urbsubs_usc_m2,
                      Height_Sept20_urbsubs_usc_m2_ME) 

# list of models
# model_list <- append(model_list,
# 
# list(
#   Height_Sept20_gr_city_m2,
# Height_Sept20_gr_usc_m5,
# Height_Sept20_urbsubs_city_m5,
# Height_Sept20_urbsubs_city_m5_ME,
# Height_Sept20_urbsubs_usc_m2,
# Height_Sept20_urbsubs_usc_m2_ME
# ))
```
## Weevil scars: standardized by June height
### lmer: diagnostics
```{r}
# GRADIENT / CITY_DIST-----

# weev_stn_gr_city_m1 <- lmer(scar_div_Juneheight ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both, REML = F)
# sjPlot::plot_model(weev_stn_gr_city_m1, type = "diag") # is singular & right-skewed
# 
# weev_stn_gr_city_m2 <- lmer(log(scar_div_Juneheight + 1) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both, REML = F)
# sjPlot::plot_model(weev_stn_gr_city_m2, type = "diag") # sqrt, cube root, log still look bad... try binomial, then removing zeroes and going from there


# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

# recode plants as having height or not
weevil_both$scar_div_Juneheight_binary <- weevil_both$scar_div_Juneheight
weevil_both$scar_div_Juneheight_binary[weevil_both$scar_div_Juneheight_binary > 0] <- 1

weev_stn_gr_city_m3 <- glmer((scar_div_Juneheight_binary) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = weevil_both,
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(weev_stn_gr_city_m3)
plot(res)
# looks great! 
summary(weev_stn_gr_city_m3)

car::Anova(weev_stn_gr_city_m3) # not sig- so, whether the plant was attacked by weevils not associated with urbanization


# weev_stn_gr_city_m4 <- lmer(scar_div_Juneheight ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_city_m4, type='diag') #very right-skewed... try sqrt
# 
# weev_stn_gr_city_m5 <- lmer(sqrt(scar_div_Juneheight) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_city_m5, type='diag') # still r-skew... try cube rt
# 
# weev_stn_gr_city_m6 <- lmer((scar_div_Juneheight)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_city_m6, type='diag') # still r-skew... try log
# 
# weev_stn_gr_city_m7 <- lmer(log(scar_div_Juneheight) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_city_m7, type='diag') # much better but qqplot suspicious... good enough, I guess... still singular though. Take out block
# 
# weev_stn_gr_city_m8 <- lmer(log(scar_div_Juneheight) ~ (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out /Fam
# 
# weev_stn_gr_city_m9 <- lmer(log(scar_div_Juneheight) ~ (1|Block) + (1|Population) + City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out block
# 
# weev_stn_gr_city_m10 <- lmer(log(scar_div_Juneheight) ~ (1|Population) +  City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 


# try glmmTMB
# test1 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population) + City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   family = gaussian) # it works!
# 
# test1 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   family = gaussian) # it works! 

weev_stn_gr_city_m11 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family) + (1|Block) + City_dist,
  data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
  family = gaussian) # it works! use this


# GRADIENT / URB SCORE-----

# weev_stn_gr_usc_m1 <- lmer(scar_div_Juneheight ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both, REML = F)
# sjPlot::plot_model(weev_stn_gr_usc_m1, type = "diag") # is singular & right-skewed
# 
# weev_stn_gr_usc_m2 <- lmer((scar_div_Juneheight)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both, REML = F)
# sjPlot::plot_model(weev_stn_gr_usc_m2, type = "diag") # sqrt, cube root, log still look bad... try binomial, then removing zeroes and going from there


# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS
weev_stn_gr_usc_m3 <- glmer((scar_div_Juneheight_binary) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = weevil_both,
family = "binomial"(link = "logit"),
  nAGQ = 0,
control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(weev_stn_gr_usc_m3)
plot(res)
# looks great! 
summary(weev_stn_gr_usc_m3)

car::Anova(weev_stn_gr_usc_m3) # not sig- so, whether the plant was attacked by weevils not associated with urbanization


# weev_stn_gr_usc_m4 <- lmer(scar_div_Juneheight ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_usc_m4, type='diag') #very right-skewed... try sqrt
# 
# weev_stn_gr_usc_m5 <- lmer(sqrt(scar_div_Juneheight) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_usc_m5, type='diag') # still r-skew... try cube rt
# 
# weev_stn_gr_usc_m6 <- lmer((scar_div_Juneheight)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_usc_m6, type='diag') # still r-skew... try log
# 
# weev_stn_gr_usc_m7 <- lmer(log(scar_div_Juneheight) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_usc_m7, type='diag') # much better but qqplot suspicious...still singular though. Take out block
# 
# weev_stn_gr_usc_m8 <- lmer(log(scar_div_Juneheight) ~ (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out Fam
# 
# weev_stn_gr_usc_m10 <- lmer(log(scar_div_Juneheight) ~ (1|Block) + (1|Population) + Urb_score,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out block too
# 
# weev_stn_gr_usc_m11 <- lmer(log(scar_div_Juneheight) ~ (1|Population) + Urb_score,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 


# try glmmTMB
weev_stn_gr_usc_m12 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family) + (1|Block) + Urb_score,
  data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
  family = gaussian) # it works! use this







# URB SUBTRANSECTS / CITY_DIST-----

# weev_stn_urbsubs_city_m1 <- lmer(scar_div_Juneheight ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(weev_stn_urbsubs_city_m1, type = "diag") # right-skewed
# 
# weev_stn_urbsubs_city_m2 <- lmer(sqrt(scar_div_Juneheight) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_urbsubs_city_m2, type = "diag") # still very right-skewed...
# 
# weev_stn_urbsubs_city_m3 <- lmer((scar_div_Juneheight)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_urbsubs_city_m3, type = "diag") # still very right-skewed... should take out zeroes and look at binomial, then quantatitative

# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS
weev_stn_urbsubs_city_m4 <- glmer((scar_div_Juneheight_binary) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = weevil_both %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(weev_stn_urbsubs_city_m4)
plot(res)
# looks great! 

car::Anova(weev_stn_urbsubs_city_m4) # not sig- so, whether the plant was attacked by weevils not associated with urbanization nor urban subtr

# main effects
weev_stn_urbsubs_city_m4_ME <- glmer((scar_div_Juneheight_binary) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = weevil_both %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

# weev_stn_urbsubs_city_m4 <- lmer(scar_div_Juneheight ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_urbsubs_city_m4, type='diag') #very right-skewed... try sqrt
# 
# weev_stn_urbsubs_city_m5 <- lmer(sqrt(scar_div_Juneheight) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_urbsubs_city_m5, type='diag') #still right-skewed... though better... try cube root
# 
# weev_stn_urbsubs_city_m6 <- lmer((scar_div_Juneheight)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_urbsubs_city_m6, type='diag') # looks pretty good... try log
# 
# 
# weev_stn_urbsubs_city_m7 <- lmer(log(scar_div_Juneheight + 0.1) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_urbsubs_city_m7, type='diag') # looks the same as cube root but maybe a little better? still singular though. Take out block
# 
# weev_stn_urbsubs_city_m8 <- lmer(log(scar_div_Juneheight) ~ (1|Population/Family) +  City_dist * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out Fam
# 
# weev_stn_urbsubs_city_m9 <- lmer(log(scar_div_Juneheight) ~ (1|Block) + (1|Population) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) #  singular... take out block
# 
# weev_stn_urbsubs_city_m10 <- lmer(log(scar_div_Juneheight) ~  (1|Population) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"), 
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) #  singular... 


# try glmmTMB
weev_stn_urbsubs_city_m11 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family) + (1|Block) + City_dist * Transect_ID,
  data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"), 
  family = gaussian) # it works! use this



# main effects
# test2 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family) + (1|Block) + City_dist + Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"), 
#   family = gaussian) # singular,,, taje out block
# 
# weev_stn_urbsubs_city_m11_ME.1 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family)  + City_dist + Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"), 
#   family = gaussian) # works now. Take out block and put back in Family to see if it changes

weev_stn_urbsubs_city_m11_ME.2 <- glmmTMB(log(scar_div_Juneheight) ~ + (1|Block) + (1|Population)  + City_dist + Transect_ID,
  data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"), 
  family = gaussian) # works too

car::Anova(weev_stn_urbsubs_city_m11)
car::Anova(weev_stn_urbsubs_city_m11_ME.1)
car::Anova(weev_stn_urbsubs_city_m11_ME.2) # these results much more similar to full model than model above (.1) so will use this.


# URB SUBTRANSECTS / URB SCORE-----

# weev_stn_urbsubs_usc_m1 <- lmer(scar_div_Juneheight ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(weev_stn_urbsubs_usc_m1, type = "diag") # right-skewed
# 
# weev_stn_urbsubs_usc_m2 <- lmer(sqrt(scar_div_Juneheight) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_urbsubs_usc_m2, type = "diag") # still very right-skewed...
# 
# weev_stn_urbsubs_usc_m3 <- lmer((scar_div_Juneheight)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_urbsubs_usc_m3, type = "diag") # still very right-skewed... should take out zeroes and look at binomial, then quantatitative

# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS
weev_stn_urbsubs_usc_m4 <- glmer((scar_div_Juneheight_binary) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = weevil_both %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
    nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(weev_stn_urbsubs_usc_m4)
plot(res)
# looks great! 

car::Anova(weev_stn_urbsubs_usc_m4) # not sig- so, whether the plant was attacked by weevils not associated with urbanization nor urban subtr

# main effects
weev_stn_urbsubs_usc_m4_ME <- glmer((scar_div_Juneheight_binary) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = weevil_both %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
    nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))


# weev_stn_gr_usc_m4 <- lmer(scar_div_Juneheight ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_usc_m4, type='diag') #very right-skewed... try sqrt
# 
# weev_stn_gr_usc_m5 <- lmer(sqrt(scar_div_Juneheight) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_usc_m5, type='diag') #still right-skewed... though better... try cube root
# 
# weev_stn_gr_usc_m6 <- lmer((scar_div_Juneheight)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_usc_m6, type='diag') # looks pretty good... try log
# 
# 
# weev_stn_gr_usc_m7 <- lmer(log(scar_div_Juneheight + 0.1) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_usc_m7, type='diag') # looks the same as cube root but maybe a little better? still singular though...Take out block
# 
# weev_stn_gr_usc_m8 <- lmer(log(scar_div_Juneheight) ~ (1|Population/Family) +  Urb_score * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out Fam
# 
# weev_stn_gr_usc_m9 <- lmer(log(scar_div_Juneheight) ~ (1|Block) + (1|Population) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) #  singular... take out block
# 
# weev_stn_gr_usc_m10 <- lmer(log(scar_div_Juneheight) ~ (1|Population) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) #  singular... 



# try glmmTMB
weev_stn_usc_usc_m10 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family) + (1|Block) + Urb_score * Transect_ID,
  data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"), 
  family = gaussian) # it works! use this



# main effects
# test2 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family) + (1|Block) + Urb_score + Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   family = gaussian) # singular,,, taje out block
# 
# weev_stn_usc_usc_m10_ME.1 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family)  + Urb_score + Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   family = gaussian) # works now. Take out block and put back in Family to see if it changes

weev_stn_usc_usc_m10_ME.2 <- glmmTMB(log(scar_div_Juneheight) ~ + (1|Block) + (1|Population)  + Urb_score + Transect_ID,
  data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"), 
  family = gaussian) # works too

car::Anova(weev_stn_usc_usc_m10)
car::Anova(weev_stn_usc_usc_m10_ME.1)
car::Anova(weev_stn_usc_usc_m10_ME.2) # these results much more similar to full model than model above (.1) so will use this.


```

### Entire gradient: *Not sig for either
#### City_dist
```{r}
car::Anova(weev_stn_gr_city_m3) # binomial: not sig
car::Anova(weev_stn_gr_city_m11) # quantitative: not sig



# ANy variation within families or populations?
m.1 <- lmer(log(scar_div_Juneheight) ~ (1|Population/Family),
            data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
            REML = T)

ranova(m.1)
# No for both


sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_Weevildivheight_lmer_PVE.csv"), col.names=TRUE, sep=",")
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Weevildivheight_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

#### Urb_score
```{r}
car::Anova(weev_stn_gr_usc_m3) # binomial: not sig
car::Anova(weev_stn_gr_usc_m12) # quantitative: not sig

```


### Urban subtransects: *Marg sig transect for city_dist
#### City_dist
```{r}
car::Anova(weev_stn_urbsubs_city_m4) # binomial: nothing sig
car::Anova(weev_stn_urbsubs_city_m4_ME) # binomial: nothing sig
car::Anova(weev_stn_urbsubs_city_m11) # quantitative: transect marg sig
car::Anova(weev_stn_urbsubs_city_m11_ME.2) #quant main effects: transect marg sig

AIC(weev_stn_urbsubs_city_m11, weev_stn_urbsubs_city_m11_ME.2) # main effects has sig lower AIC


# ANy variation among families or populations?
m.1 <- lmer(log(scar_div_Juneheight) ~ (1|Population/Family),
            data = weevil_both %>%
              filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
            REML = T)
ranova(m.1)
# no, is singular


m.2 <- lmer(log(scar_div_Juneheight) ~ (1|Population/Family) + Transect_ID,
            data = weevil_both %>%
              filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
            REML = F)
car::Anova(m.2)
# not among transects either


m.3 <- lmer(log(scar_div_Juneheight) ~ (1|Population/Family) + Transect_ID,
              data = weevil_both %>%
              filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
            REML = T)
car::Anova(m.3)
# not sig in this or m.2


sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_Weevildivheight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",")
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Weevildivheight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
write.table(car::Anova(m.2), here::here("./Figures_Tables/ranova_PVE/2020_Weevildivheight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

#### Urb_score
```{r}
car::Anova(weev_stn_urbsubs_usc_m4) # binomial: not sig
car::Anova(weev_stn_usc_usc_m10) # quantitative: not sig
car::Anova(weev_stn_usc_usc_m10_ME.2)

AIC(weev_stn_usc_usc_m10, weev_stn_usc_usc_m10_ME.2) # ME better but <2 AIC away
```


### Export ANOVA
```{r}
anova_table_flx(weev_stn_gr_city_m3)
anova_table_flx(weev_stn_gr_city_m11)
anova_table_flx(weev_stn_gr_usc_m3)
anova_table_flx(weev_stn_gr_usc_m12)

anova_table_flx(weev_stn_urbsubs_city_m4)
anova_table_flx(weev_stn_urbsubs_city_m4_ME)
anova_table_flx(weev_stn_urbsubs_city_m11)
anova_table_flx(weev_stn_urbsubs_city_m11_ME.2)

anova_table_flx(weev_stn_urbsubs_usc_m4)
anova_table_flx(weev_stn_urbsubs_usc_m4_ME)
anova_table_flx(weev_stn_usc_usc_m10)
anova_table_flx(weev_stn_usc_usc_m10_ME.2)


AIC_compare.city_dist_transf_binomial(weev_stn_urbsubs_city_m4,
                      weev_stn_urbsubs_city_m4_ME)

AIC_compare.city_dist_transf_quantitative(weev_stn_urbsubs_city_m11,
                      weev_stn_urbsubs_city_m11_ME.2)

AIC_compare.urb_score_transf_binomial(weev_stn_urbsubs_usc_m4,
                      weev_stn_urbsubs_usc_m4_ME)

AIC_compare.urb_score_transf_quantitative(weev_stn_usc_usc_m10,
                      weev_stn_usc_usc_m10_ME.2) 

# list of models
# model_list <- append(model_list,
# 
# list(
#   weev_stn_gr_city_m3,
# weev_stn_gr_city_m11,
# weev_stn_gr_usc_m3,
# weev_stn_gr_usc_m12,
# weev_stn_urbsubs_city_m4,
# weev_stn_urbsubs_city_m4_ME,
# weev_stn_urbsubs_city_m11,
# weev_stn_urbsubs_city_m11_ME.2,
# weev_stn_urbsubs_usc_m4,
# weev_stn_urbsubs_usc_m4_ME,
# weev_stn_usc_usc_m10,
# weev_stn_usc_usc_m10_ME.2
#   
# ))
```

## Weevil scars: NOT standardized by June height
### lmer
```{r}
# GRADIENT / CITY_DIST-----

# weev_gr_city_m1 <- lmer(Scar_length_cm ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both,
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_city_m1, type = "diag") # right-skewed
# 
# weev_gr_city_m2 <- lmer(sqrt(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both, REML = F,
#       control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_city_m2, type = "diag") # sqrt, cube root, log still look bad... try binomial, then removing zeroes and going from there


# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

# recode plants as having height or not
weevil_both$Scar_length_cm_binary <- weevil_both$Scar_length_cm
weevil_both$Scar_length_cm_binary[weevil_both$Scar_length_cm_binary > 0] <- 1

weev_gr_city_m3 <- glmer((Scar_length_cm_binary) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = weevil_both,
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(weev_gr_city_m3)
plot(res)
# looks great! 
summary(weev_gr_city_m3)

car::Anova(weev_gr_city_m3) # not sig- so, whether the plant was attacked by weevils not associated with urbanization


# weev_gr_city_m4 <- lmer(Scar_length_cm ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_city_m4, type='diag') #very right-skewed... try sqrt
# 
# weev_gr_city_m5 <- lmer(sqrt(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_city_m5, type='diag') # still r-skew... try cube rt
# 
# weev_gr_city_m6 <- lmer((Scar_length_cm)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_city_m6, type='diag') # still r-skew... try log
# 
# weev_gr_city_m7 <- lmer(log(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_city_m7, type='diag') # much better  still singular though. Take out block
# 
# weev_gr_city_m8 <- lmer(log(Scar_length_cm) ~ (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out Fam
# 
# weev_gr_city_m9 <- lmer(log(Scar_length_cm) ~ (1|Block) + (1|Population) + City_dist,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out block
# 
# weev_gr_city_m10 <- lmer(log(Scar_length_cm) ~ (1|Population) + City_dist,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 

# try glmmTMB
weev_gr_city_m11 <- glmmTMB(log(Scar_length_cm) ~ (1|Population/Family) + (1|Block) + City_dist,
  data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"), 
  family = gaussian) # it works! use this




# GRADIENT / URB SCORE-----

# weev_gr_usc_m1 <- lmer(Scar_length_cm ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both, REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_usc_m1, type = "diag") # right-skewed
# 
# weev_gr_usc_m2 <- lmer((Scar_length_cm)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both, REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_usc_m2, type = "diag") # sqrt, cube root, log still look bad... try binomial, then removing zeroes and going from there


# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS
weev_gr_usc_m3 <- glmer((Scar_length_cm_binary) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = weevil_both,
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(weev_gr_usc_m3)
plot(res)
# looks great! 
summary(weev_gr_usc_m3)

car::Anova(weev_gr_usc_m3) # not sig- so, whether the plant was attacked by weevils not associated with urbanization


# weev_gr_usc_m4 <- lmer(Scar_length_cm ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_usc_m4, type='diag') #very right-skewed... try sqrt
# 
# weev_gr_usc_m5 <- lmer(sqrt(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_usc_m5, type='diag') # still r-skew... try cube rt
# 
# weev_gr_usc_m6 <- lmer((Scar_length_cm)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_usc_m6, type='diag') # still r-skew... try log
# 
# weev_gr_usc_m7 <- lmer(log(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_usc_m7, type='diag') # much better but qqplot suspicious... good enough, I guess still singular though. Take out block
# 
# weev_gr_usc_m8 <- lmer(log(Scar_length_cm) ~ (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out /Fam
# 
# weev_gr_usc_m9 <- lmer(log(Scar_length_cm) ~ (1|Block) + (1|Population) + Urb_score,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out block
# 
# weev_gr_usc_m10 <- lmer(log(Scar_length_cm) ~ (1|Population) + Urb_score,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 

# try glmmTMB
weev_gr_usc_m10 <- glmmTMB(log(Scar_length_cm) ~ (1|Population/Family) + (1|Block) + Urb_score,
  data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"), 
  family = gaussian) # it works! use this


# URB SUBTRANSECTS / CITY_DIST-----

# weev_urbsubs_city_m1 <- lmer(Scar_length_cm ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(weev_urbsubs_city_m1, type = "diag") # right-skewed
# 
# weev_urbsubs_city_m2 <- lmer(sqrt(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_city_m2, type = "diag") # still very right-skewed...
# 
# weev_urbsubs_city_m3 <- lmer((Scar_length_cm)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_city_m3, type = "diag") # still very right-skewed... should take out zeroes and look at binomial, then quantatitative

# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS
weev_urbsubs_city_m4 <- glmer((Scar_length_cm_binary) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = weevil_both %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(weev_urbsubs_city_m4)
plot(res)
# looks great! 

car::Anova(weev_urbsubs_city_m4) # not sig- so, whether the plant was attacked by weevils not associated with urbanization nor urban subtr


# main effects
weev_urbsubs_city_m4_ME <- glmer((Scar_length_cm_binary) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = weevil_both %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

# weev_urbsubs_city_m4 <- lmer(Scar_length_cm ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_city_m4, type='diag') #very right-skewed... try sqrt
# 
# weev_urbsubs_city_m5 <- lmer(sqrt(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_city_m5, type='diag') #still right-skewed... though better... try cube root
# 
# weev_urbsubs_city_m6 <- lmer((Scar_length_cm)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_city_m6, type='diag') # looks pretty good! try log just in case
# 
# 
# weev_urbsubs_city_m7 <- lmer(log(Scar_length_cm + 0.1) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_city_m7, type='diag') # looks the same as cube root but maybe a little better? a bit of kurtosis thoughstill singular though. Take out block
# 
# weev_urbsubs_city_m8 <- lmer(log(Scar_length_cm) ~ (1|Population/Family) + City_dist* Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out Fam
# 
# weev_urbsubs_city_m9 <- lmer(log(Scar_length_cm) ~ (1|Block) +  (1|Population) + City_dist* Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out block too
# 
# weev_urbsubs_city_m10 <- lmer(log(Scar_length_cm) ~  (1|Population) + City_dist* Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 

# try glmmTMB
weev_urbsubs_city_m11 <- glmmTMB(log(Scar_length_cm + 0.1) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
  family = gaussian) # it works! use this



# main effects
weev_urbsubs_city_m11_ME <- glmmTMB(log(Scar_length_cm + 0.1) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
  family = gaussian) # it works! use this



# URB SUBTRANSECTS / URB SCORE-----

# weev_urbsubs_usc_m1 <- lmer(Scar_length_cm ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(weev_urbsubs_usc_m1, type = "diag") # right-skewed
# 
# weev_urbsubs_usc_m2 <- lmer(sqrt(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_usc_m2, type = "diag") # still very right-skewed...
# 
# weev_urbsubs_usc_m3 <- lmer((Scar_length_cm)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_usc_m3, type = "diag") # still very right-skewed... should take out zeroes and look at binomial, then quantatitative

# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS
weev_urbsubs_usc_m4 <- glmer((Scar_length_cm_binary) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = weevil_both %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(weev_urbsubs_usc_m4)
plot(res)
# looks great! 

car::Anova(weev_urbsubs_usc_m4) # not sig- so, whether the plant was attacked by weevils not associated with urbanization nor urban subtr


# main effects
weev_urbsubs_usc_m4_ME <- glmer((Scar_length_cm_binary) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = weevil_both %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

# weev_urbsubs_usc_m4 <- lmer(Scar_length_cm ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_usc_m4, type='diag') #very right-skewed... try sqrt
# 
# weev_urbsubs_usc_m5 <- lmer(sqrt(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_usc_m5, type='diag') #still right-skewed... though better... try cube root
# 
# weev_urbsubs_usc_m6 <- lmer((Scar_length_cm)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_usc_m6, type='diag') # looks pretty good... try log
# 
# 
# weev_urbsubs_usc_m7 <- lmer(log(Scar_length_cm + 0.1) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_usc_m7, type='diag') # looks the same as cube root but maybe a little better? some kurtosis though still singular  Take out block
# 
# weev_urbsubs_usc_m8 <- lmer(log(Scar_length_cm) ~ (1|Population/Family) + Urb_score* Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out Fam
# 
# weev_urbsubs_usc_m9 <- lmer(log(Scar_length_cm) ~ (1|Block) +  (1|Population) + Urb_score* Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out block too
# 
# weev_urbsubs_usc_m10 <- lmer(log(Scar_length_cm) ~  (1|Population) + Urb_score* Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 

# try glmmTMB
weev_urbsubs_usc_m11 <- glmmTMB(log(Scar_length_cm + 0.1) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
  family = gaussian) # it works! use this



# main effects
weev_urbsubs_usc_m11_ME <- glmmTMB(log(Scar_length_cm + 0.1) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
  family = gaussian) # it works! use this

```

### Entire gradient: *NOt sig for either
#### City_dist
```{r}
car::Anova(weev_gr_city_m3) # binomial: not sig
car::Anova(weev_gr_city_m11) # quantitative: not sig



# ANy variation within families or populations?
m.1 <- lmer(log(Scar_length_cm) ~ (1|Population/Family),
            data = weevil_both %>% filter(Scar_length_cm_binary == 1),
            REML = T)

ranova(m.1)
# No for both


sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_Weevil_lmer_PVE.csv"), col.names=TRUE, sep=",")
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Weevil_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```


#### Urb_score
```{r}
car::Anova(weev_gr_usc_m3) # binomial: not sig
car::Anova(weev_gr_usc_m10) # quantitative: not sig

```


### Urban subtransects: *Transect sig for city_dist AND urb_score
#### City_dist
```{r}
car::Anova(weev_urbsubs_city_m4) # binomial: not sig
car::Anova(weev_urbsubs_city_m4_ME) # binomial: not sig
car::Anova(weev_urbsubs_city_m11) # quantitative: transect sig
car::Anova(weev_urbsubs_city_m11_ME) # quantitative main effects: transect sig

AIC(weev_urbsubs_city_m11, weev_urbsubs_city_m11_ME)# main effects lower AIC (less than 2)



# ANy variation among families or populations?
m.1 <- lmer(log(Scar_length_cm) ~ (1|Population/Family),
              data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
            REML = T)
ranova(m.1)
# no

m.2 <- lmer(log(Scar_length_cm) ~ (1|Population/Family) + Transect_ID,
              data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),

            REML = F)
car::Anova(m.2)
# YES among transects 


m.3 <- lmer(log(Scar_length_cm) ~ (1|Population/Family) + Transect_ID,
              data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
            REML = T)
car::Anova(m.3)
# YES among transects


sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_Weevil_urban_lmer_PVE.csv"), col.names=TRUE, sep=",")
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Weevil_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
write.table(car::Anova(m.2), here::here("./Figures_Tables/ranova_PVE/2020_Weevil_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)

```

#### Urb_score
```{r}
car::Anova(weev_urbsubs_usc_m4) # binomial: not sig
car::Anova(weev_urbsubs_usc_m4_ME) # binomial: not sig
car::Anova(weev_urbsubs_usc_m11) # quantitative: transect sig
car::Anova(weev_urbsubs_usc_m11_ME) # quantitative main effects: transect sig

AIC(weev_urbsubs_usc_m11, weev_urbsubs_usc_m11_ME)# main effects lower AIC (less than 2)


```

### Export ANOVA
```{r}
anova_table_flx(weev_gr_city_m3)
anova_table_flx(weev_gr_city_m11)
anova_table_flx(weev_gr_usc_m3)
anova_table_flx(weev_gr_usc_m10)

anova_table_flx(weev_urbsubs_city_m4)
anova_table_flx(weev_urbsubs_city_m4_ME) 
anova_table_flx(weev_urbsubs_city_m11)
anova_table_flx(weev_urbsubs_city_m11_ME)
anova_table_flx(weev_urbsubs_usc_m4)
anova_table_flx(weev_urbsubs_usc_m4_ME)
anova_table_flx(weev_urbsubs_usc_m11)
anova_table_flx(weev_urbsubs_usc_m11_ME)


AIC_compare.city_dist_transf_binomial(weev_urbsubs_city_m4,
                      weev_urbsubs_city_m4_ME)

AIC_compare.city_dist_transf_quantitative(weev_urbsubs_city_m11,
                      weev_urbsubs_city_m11_ME)

AIC_compare.urb_score_transf_binomial(weev_urbsubs_usc_m4,
                      weev_urbsubs_usc_m4_ME)

AIC_compare.urb_score_transf_quantitative(weev_urbsubs_usc_m11,
                      weev_urbsubs_usc_m11_ME) 

# list of models
# model_list <- append(model_list,
# 
# list(
# 
#   weev_gr_city_m3,
# weev_gr_city_m11,
# weev_gr_usc_m3,
# weev_gr_usc_m10,
# weev_urbsubs_city_m4,
# weev_urbsubs_city_m4_ME, 
# weev_urbsubs_city_m11,
# weev_urbsubs_city_m11_ME,
# weev_urbsubs_usc_m4,
# weev_urbsubs_usc_m4_ME,
# weev_urbsubs_usc_m11,
# weev_urbsubs_usc_m11_ME
#   
# ))
```

## Herbivory
### July
#### glmer: diagnostics
```{r}
# Gradient / city_dist----------

# herb2020_gr_dist_m1 <- glmer(Herbivory.July_mean ~ (1|Block)  + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020,
#   family = binomial,
#   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# res <- simulateResiduals(herb2020_gr_dist_m1)
# plot(res)
# # major errors... try beta distribution
# 
# 
# herb2020_gr_dist_m2 <- glmmTMB(Herbivory.July_mean  ~ (1|Block) +  (1|Population/Family) + City_dist,
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# # Error in eval(family$initialize) : y values must be 0 < y < 1
# # recode: 0s as 0.00001 & 1 as 0.999999

herbivory_both_2020$Herbivory.July_mean_recode <- herbivory_both_2020$Herbivory.July_mean
herbivory_both_2020$Herbivory.July_mean_recode[herbivory_both_2020$Herbivory.July_mean == 1] <- 0.999999
herbivory_both_2020$Herbivory.July_mean_recode[herbivory_both_2020$Herbivory.July_mean == 0] <- 0.000001


# herb2020_gr_dist_m3 <- glmmTMB(Herbivory.July_mean_recode  ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020_gr_dist_m3)
# plot(res)
# # IT WORKS
# 
# hist(herbivory_both_2020$Herbivory.July_mean_recode, breaks = 30)
# summary(herb2020_gr_dist_m3)
# testDispersion(herb2020_gr_dist_m3)
# testZeroInflation(herb2020_gr_dist_m3)
# 
# # address overdispersion through an individual-level random effect
# herbivory_both_2020$ID <- seq.int(nrow(herbivory_both_2020))
# 
# herb2020_gr_dist_m4 <- glmmTMB(Herbivory.July_mean_recode  ~ (1|Block) + (1|Population/Family) + City_dist + (1|ID),
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020_gr_dist_m4)
# plot(res)
# # better but still not optimal
# 
# testDispersion(herb2020_gr_dist_m4) # is it underdispersed now?
# testZeroInflation(herb2020_gr_dist_m4)
# 
# # try binomial and then quantitative?



# recode plants as having height or not
herbivory_both_2020$Herbivory.July_mean_binary <- herbivory_both_2020$Herbivory.July_mean
herbivory_both_2020$Herbivory.July_mean_binary[herbivory_both_2020$Herbivory.July_mean_binary > 0] <- 1

herb2020_gr_dist_m5 <- glmer((Herbivory.July_mean_binary) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = herbivory_both_2020,
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herb2020_gr_dist_m5)
plot(res)
# looks great! 
summary(herb2020_gr_dist_m5)

car::Anova(herb2020_gr_dist_m5) # not sig


# herb2020_gr_dist_m6 <- lmer(Herbivory.July_mean ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_gr_dist_m6, type='diag') #very right-skewed... try cube root
# 
# herb2020_gr_dist_m7 <- lmer(Herbivory.July_mean^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_gr_dist_m7, type='diag') # still right-skewed... try log

herb2020_gr_dist_m8 <- lmer(log(Herbivory.July_mean) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(herb2020_gr_dist_m8, type='diag') # looks great!

car::Anova(herb2020_gr_dist_m8) # not sig




# Gradient / urb_score----------

# herb2020_gr_usc_m1 <-  glmer(Herbivory.July_mean ~ (1|Block)  + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020,
#   family = binomial,
#   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# res <- simulateResiduals(herb2020_gr_usc_m1)
# plot(res)
# # major errors... try beta distribution
# 
# 
# herb2020_gr_usc_m2 <- glmmTMB(Herbivory.July_mean  ~ (1|Block) +  (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# # Error in eval(family$initialize) : y values must be 0 < y < 1
# # recode: 0s as 0.00001 & 1 as 0.999999
# 
# 
# herb2020_gr_usc_m3 <- glmmTMB(Herbivory.July_mean_recode  ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020_gr_usc_m3)
# plot(res)
# # IT WORKS
# 
# hist(herbivory_both_2020$Herbivory.July_mean_recode, breaks = 30)
# summary(herb2020_gr_usc_m3)
# testDispersion(herb2020_gr_usc_m3)
# testZeroInflation(herb2020_gr_usc_m3)
# 
# # address overdispersion through an individual-level random effect
# herb2020_gr_usc_m4 <- glmmTMB(Herbivory.July_mean_recode  ~ (1|Block) + (1|Population/Family) + Urb_score + (1|ID),
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020_gr_usc_m4)
# plot(res)
# # better but still not optimal
# 
# testDispersion(herb2020_gr_usc_m4) # is it underdispersed now?
# testZeroInflation(herb2020_gr_usc_m4)
# 
# # try binomial and then quantitative?



# recode plants as having height or not
herb2020_gr_usc_m5 <- glmer((Herbivory.July_mean_binary) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = herbivory_both_2020,
  family = "binomial"(link="logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herb2020_gr_usc_m5)
plot(res)
# looks great! 
summary(herb2020_gr_usc_m5)

car::Anova(herb2020_gr_usc_m5) # not sig


# herb2020_gr_usc_m6 <- lmer(Herbivory.July_mean ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_gr_usc_m6, type='diag') #very right-skewed... try cube root
# 
# herb2020_gr_usc_m7 <- lmer(Herbivory.July_mean^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_gr_usc_m7, type='diag') # still right-skewed... try log

herb2020_gr_usc_m8 <- lmer(log(Herbivory.July_mean) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(herb2020_gr_usc_m8, type='diag') # looks great!

car::Anova(herb2020_gr_usc_m8) # not sig






# Urb sites / city_dist----------

# herb2020_urb_dist_m1 <- glmer(Herbivory.July_mean ~ (1|Block)  + (1|Population/Family) + City_dist * Transect_ID,
#     data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#     family = binomial,
#   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# res <- simulateResiduals(herb2020_urb_dist_m1)
# plot(res)
# # major errors... try beta distribution
# 
# 
# herb2020_urb_dist_m2 <- glmmTMB(Herbivory.July_mean  ~ (1|Block) +  (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# # Error in eval(family$initialize) : y values must be 0 < y < 1
# # recode: 0s as 0.00001 & 1 as 0.999999
# 
# 
# herb2020_urb_dist_m3 <- glmmTMB(Herbivory.July_mean_recode  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020_urb_dist_m3)
# plot(res)
# # IT WORKS
# 
# summary(herb2020_urb_dist_m3)
# testDispersion(herb2020_urb_dist_m3)
# testZeroInflation(herb2020_urb_dist_m3)
# 
# # address overdispersion through an individual-level random effect
# 
# herb2020_urb_dist_m4 <- glmmTMB(Herbivory.July_mean_recode  ~ (1|Block) + (1|Population/Family) + City_dist + (1|ID),
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020_urb_dist_m4)
# plot(res)
# # better but still not optimal
# 
# testDispersion(herb2020_urb_dist_m4) # is it underdispersed now?
# testZeroInflation(herb2020_urb_dist_m4)
# 
# # try binomial and then quantitative?


herb2020_urb_dist_m5 <- glmer((Herbivory.July_mean_binary) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link="logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herb2020_urb_dist_m5)
plot(res)
# looks great! 
summary(herb2020_urb_dist_m5)

car::Anova(herb2020_urb_dist_m5) # city_dist sig


# main effects
herb2020_urb_dist_m5_ME <- glmer((Herbivory.July_mean_binary) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link="logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

# herb2020_urb_dist_m6 <- lmer(Herbivory.July_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_urb_dist_m6, type='diag') #very right-skewed... try cube root
# 
# herb2020_urb_dist_m7 <- lmer(Herbivory.July_mean^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_urb_dist_m7, type='diag') # still right-skewed... try log

# herb2020_urb_dist_m8 <- lmer(log(Herbivory.July_mean) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_urb_dist_m8, type='diag') # looks great! but stil singular... try glmmTMB

herb2020_urb_dist_m8 <- glmmTMB(log(Herbivory.July_mean) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
  family = gaussian)
sjPlot::plot_model(herb2020_urb_dist_m8, type='diag') # looks great!

car::Anova(herb2020_urb_dist_m8) # interaction not sig

# main effects
herb2020_urb_dist_m8_ME <- glmmTMB(log(Herbivory.July_mean) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
  family = gaussian)



# Urb sites / urb_score----------

# herb2020_urb_usc_m1 <- glmer(Herbivory.July_mean ~ (1|Block)  + (1|Population/Family) + Urb_score * Transect_ID,
#     data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#     family = binomial,
#   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# res <- simulateResiduals(herb2020_urb_usc_m1)
# plot(res)
# # major errors... try beta distribution
# 
# 
# herb2020_urb_usc_m2 <- glmmTMB(Herbivory.July_mean  ~ (1|Block) +  (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# # Error in eval(family$initialize) : y values must be 0 < y < 1
# # recode: 0s as 0.00001 & 1 as 0.999999
# 
# 
# herb2020_urb_usc_m3 <- glmmTMB(Herbivory.July_mean_recode  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020_urb_usc_m3)
# plot(res)
# # IT WORKS
# 
# summary(herb2020_urb_usc_m3)
# testDispersion(herb2020_urb_usc_m3)
# testZeroInflation(herb2020_urb_usc_m3)
# 
# # address overdispersion through an individual-level random effect
# 
# herb2020_urb_usc_m4 <- glmmTMB(Herbivory.July_mean_recode  ~ (1|Block) + (1|Population/Family) + Urb_score + (1|ID),
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020_urb_usc_m4)
# plot(res)
# # better but still not optimal
# 
# testDispersion(herb2020_urb_usc_m4) # is it underdispersed now?
# testZeroInflation(herb2020_urb_usc_m4)
# 
# # try binomial and then quantitative?


herb2020_urb_usc_m5 <- glmer((Herbivory.July_mean_binary) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link="logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herb2020_urb_usc_m5)
plot(res)
# looks great! 
summary(herb2020_urb_usc_m5)

car::Anova(herb2020_urb_usc_m5) # Urb_score marg sig


# main effects
herb2020_urb_usc_m5_ME <- glmer((Herbivory.July_mean_binary) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link="logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

# herb2020_urb_usc_m6 <- lmer(Herbivory.July_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_urb_usc_m6, type='diag') #very right-skewed... try cube root
# 
# herb2020_urb_usc_m7 <- lmer(Herbivory.July_mean^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_urb_usc_m7, type='diag') # still right-skewed... try log

herb2020_urb_usc_m8 <- lmer(log(Herbivory.July_mean) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(herb2020_urb_usc_m8, type='diag') # looks great!

car::Anova(herb2020_urb_usc_m8) # nothing sig

# main effects
herb2020_urb_usc_m8_ME <- lmer(log(Herbivory.July_mean) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))


```

#### Entire gradient: *Not sig for either
##### City_dist
```{r}
car::Anova(herb2020_gr_dist_m5) # binomial: not sig
car::Anova(herb2020_gr_dist_m8) # quantitative: not sig




# ANy variation within families or populations?
m.1 <- lmer(log(Herbivory.July_mean) ~ (1|Population/Family),
            data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1),
            REML = T,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

ranova(m.1)
# No for both


sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_HerbivoryJuly_lmer_PVE.csv"), col.names=TRUE, sep=",")
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_HerbivoryJuly_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

##### Urb_score
```{r}
car::Anova(herb2020_gr_usc_m5) # binomial: not sig
car::Anova(herb2020_gr_usc_m8) # quantitative: not sig

```


#### Urban subtransects: *Sig for city_dist (binomial and quantitative), marg sig for binomial (urb_score)
##### City_dist
```{r}
car::Anova(herb2020_urb_dist_m5) # binomial: city_dist sig
car::Anova(herb2020_urb_dist_m5_ME) # binomial: city_dist sig
car::Anova(herb2020_urb_dist_m8) # quantitative: city_dist sig
car::Anova(herb2020_urb_dist_m8_ME) # quantitative main effects: city_dist sig

AIC(herb2020_urb_dist_m5, herb2020_urb_dist_m5_ME) # very close
AIC(herb2020_urb_dist_m8, herb2020_urb_dist_m8_ME) # main effects has lower AIC ... but the interaxn is sig so ME model isn't relevant



# ANy variation among families or populations?
m.1 <- lmer(log(Herbivory.July_mean) ~  (1|Population/Family) + City_dist ,
  data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)),
  REML = T)

ranova(m.1)
# no

m.2 <- lmer(log(Herbivory.July_mean) ~ (1|Population/Family) + Transect_ID,
              data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Urb_Rur == "Urban"),

            REML = F)
car::Anova(m.2)
# not among transects either


m.3 <- lmer(log(Herbivory.July_mean) ~ (1|Population/Family) + Transect_ID,
              data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Urb_Rur == "Urban"),
            REML = T)
car::Anova(m.3)
# also not sig among transects


sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_HerbivoryJuly_urban_lmer_PVE.csv"), col.names=TRUE, sep=",")
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_HerbivoryJuly_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
write.table(car::Anova(m.2), here::here("./Figures_Tables/ranova_PVE/2020_HerbivoryJuly_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

##### Urb_score
```{r}
car::Anova(herb2020_urb_usc_m5) # binomial: urb_score marg sig
car::Anova(herb2020_urb_usc_m5_ME) # binomial: urb_score marg sig
car::Anova(herb2020_urb_usc_m8) # quantitative: nothing sig
car::Anova(herb2020_urb_usc_m8_ME) # quantitative main effects: not sig

AIC(herb2020_urb_usc_m5, herb2020_urb_usc_m5_ME) # very close
AIC(herb2020_urb_usc_m8, herb2020_urb_usc_m8_ME)
# main effects has lower AIC
```


#### Export ANOVA
```{r}
anova_table_flx(herb2020_gr_dist_m5)
anova_table_flx(herb2020_gr_dist_m8)
anova_table_flx(herb2020_gr_usc_m5)
anova_table_flx(herb2020_gr_usc_m8)

anova_table_flx(herb2020_urb_dist_m5)
anova_table_flx(herb2020_urb_dist_m5_ME)
anova_table_flx(herb2020_urb_dist_m8)
anova_table_flx(herb2020_urb_dist_m8_ME)
anova_table_flx(herb2020_urb_usc_m5)
anova_table_flx(herb2020_urb_usc_m5_ME)
anova_table_flx(herb2020_urb_usc_m8)
anova_table_flx(herb2020_urb_usc_m8_ME)

AIC_compare.city_dist_transf_binomial(herb2020_urb_dist_m5,
                      herb2020_urb_dist_m5_ME)

AIC_compare.city_dist_transf_quantitative(herb2020_urb_dist_m8,
                      herb2020_urb_dist_m8_ME)
    
AIC_compare.urb_score_transf_binomial(herb2020_urb_usc_m5,
                      herb2020_urb_usc_m5_ME)

AIC_compare.urb_score_transf_quantitative(herb2020_urb_usc_m8,
                                          herb2020_urb_usc_m8_ME)

# list of models
# model_list <- append(model_list,
# 
# list(
# 
# herb2020_gr_dist_m5,
# herb2020_gr_dist_m8,
# herb2020_gr_usc_m5,
# herb2020_gr_usc_m8,
# herb2020_urb_dist_m5,
# herb2020_urb_dist_m5_ME,
# herb2020_urb_dist_m8,
# herb2020_urb_dist_m8_ME,
# herb2020_urb_usc_m5,
# herb2020_urb_usc_m5_ME,
# herb2020_urb_usc_m8,
# herb2020_urb_usc_m8_ME
#   
# ))
```


### Sept
#### glmer: diagnostics
```{r}
# Gradient / city_dist----------

# herb2020.S_gr_dist_m1 <- glmer(Herbivory.Sept_mean ~ (1|Block)  + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020,
#   family = binomial,
#   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# res <- simulateResiduals(herb2020.S_gr_dist_m1)
# plot(res)
# # major errors... try beta distribution
# 
# 
# herb2020.S_gr_dist_m2 <- glmmTMB(Herbivory.Sept_mean  ~ (1|Block) +  (1|Population/Family) + City_dist,
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# # Error in eval(family$initialize) : y values must be 0 < y < 1
# # recode: 0s as 0.00001 & 1 as 0.999999

herbivory_both_2020$Herbivory.Sept_mean_recode <- herbivory_both_2020$Herbivory.Sept_mean
herbivory_both_2020$Herbivory.Sept_mean_recode[herbivory_both_2020$Herbivory.Sept_mean == 1] <- 0.999999
herbivory_both_2020$Herbivory.Sept_mean_recode[herbivory_both_2020$Herbivory.Sept_mean == 0] <- 0.000001



# herb2020.S_gr_dist_m3 <- glmmTMB(Herbivory.Sept_mean_recode  ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020.S_gr_dist_m3)
# plot(res)
# # IT WORKS
# 
# hist(herbivory_both_2020$Herbivory.Sept_mean_recode, breaks = 30)
# summary(herb2020.S_gr_dist_m3)
# testDispersion(herb2020.S_gr_dist_m3)
# testZeroInflation(herb2020.S_gr_dist_m3)
# 
# # address overdispersion through an individual-level random effect
# 
# herb2020.S_gr_dist_m4 <- glmmTMB(Herbivory.Sept_mean_recode  ~ (1|Block) + (1|Population/Family) + City_dist + (1|ID),
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020.S_gr_dist_m4)
# plot(res)
# # better but still not optimal
# 
# 
# # try binomial and then quantitative?

# recode plants as having height or not
herbivory_both_2020$Herbivory.Sept_mean_binary <- herbivory_both_2020$Herbivory.Sept_mean
herbivory_both_2020$Herbivory.Sept_mean_binary[herbivory_both_2020$Herbivory.Sept_mean_binary > 0] <- 1

herb2020.S_gr_dist_m5 <- glmer((Herbivory.Sept_mean_binary) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = herbivory_both_2020,
  family = "binomial"(link="logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herb2020.S_gr_dist_m5)
plot(res)
# looks great! 
summary(herb2020.S_gr_dist_m5)

car::Anova(herb2020.S_gr_dist_m5) # marg sig


# herb2020.S_gr_dist_m6 <- lmer(Herbivory.Sept_mean ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_gr_dist_m6, type='diag') #very right-skewed... try cube root
# 
# herb2020.S_gr_dist_m7 <- lmer(Herbivory.Sept_mean^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_gr_dist_m7, type='diag') # still right-skewed... try log
# 
# herb2020.S_gr_dist_m8 <- lmer(log(Herbivory.Sept_mean) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_gr_dist_m8, type='diag') # looks good but still singular... try removing block
# 
# herb2020.S_gr_dist_m9 <- lmer(log(Herbivory.Sept_mean) ~  (1|Population/Family) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... remove Fam instead
# 
# herb2020.S_gr_dist_m10 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population) + (1|Block) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... remove block
# 
# herb2020.S_gr_dist_m11 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 

# try glmmTMB
herb2020.S_gr_dist_m12 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population) + City_dist,
  data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
  family = gaussian) # it works! use this

# test1 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population/Family) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   family = gaussian) # singular
# 
# test1 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population) + (1|Block) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   family = gaussian) # singular




# Gradient / urb_score----------

# herb2020.S_gr_usc_m1 <-  glmer(Herbivory.Sept_mean ~ (1|Block)  + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020,
#   family = binomial,
#   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# res <- simulateResiduals(herb2020.S_gr_usc_m1)
# plot(res)
# # major errors... try beta distribution
# 
# 
# herb2020.S_gr_usc_m2 <- glmmTMB(Herbivory.Sept_mean  ~ (1|Block) +  (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# # Error in eval(family$initialize) : y values must be 0 < y < 1
# # recode: 0s as 0.00001 & 1 as 0.999999
# 
# 
# herb2020.S_gr_usc_m3 <- glmmTMB(Herbivory.Sept_mean_recode  ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020.S_gr_usc_m3)
# plot(res)
# # IT WORKS
# 
# hist(herbivory_both_2020$Herbivory.Sept_mean_recode, breaks = 30)
# summary(herb2020.S_gr_usc_m3)
# testDispersion(herb2020.S_gr_usc_m3)
# testZeroInflation(herb2020.S_gr_usc_m3)
# 
# # address overdispersion through an individual-level random effect
# herb2020.S_gr_usc_m4 <- glmmTMB(Herbivory.Sept_mean_recode  ~ (1|Block) + (1|Population/Family) + Urb_score + (1|ID),
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020.S_gr_usc_m4)
# plot(res)
# # better but still not optimal
# 
# 
# # try binomial and then quantitative?



# recode plants as having height or not
herb2020.S_gr_usc_m5 <- glmer((Herbivory.Sept_mean_binary) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = herbivory_both_2020,
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herb2020.S_gr_usc_m5)
plot(res)
# looks great! 
summary(herb2020.S_gr_usc_m5)

car::Anova(herb2020.S_gr_usc_m5) # not sig


# herb2020.S_gr_usc_m6 <- lmer(Herbivory.Sept_mean ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_gr_usc_m6, type='diag') #very right-skewed... try cube root
# 
# herb2020.S_gr_usc_m7 <- lmer(Herbivory.Sept_mean^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_gr_usc_m7, type='diag') # still right-skewed... try log
# 
# herb2020.S_gr_usc_m8 <- lmer(log(Herbivory.Sept_mean) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_gr_usc_m8, type='diag') # looks great! but still singular... try removing block
# 
# herb2020.S_gr_usc_m9 <- lmer(log(Herbivory.Sept_mean) ~  (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... remove  Fam instead
# 
# herb2020.S_gr_usc_m10 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population) + (1|Block) + Urb_score,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... remove block
# 
# herb2020.S_gr_usc_m11 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population) + Urb_score,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 

# try glmmTMB
test1 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population) + Urb_score,
  data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
  family = gaussian) # it works!

test1 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population/Family) + Urb_score,
  data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
  family = gaussian) # it works!

herb2020.S_gr_usc_m12 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population) + (1|Block) + Urb_score,
  data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
  family = gaussian) # it works! use this



# Urb sites / city_dist----------

# herb2020.S_urb_dist_m1 <- glmer(Herbivory.Sept_mean ~ (1|Block)  + (1|Population/Family) + City_dist * Transect_ID,
#     data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#     family = binomial,
#   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# res <- simulateResiduals(herb2020.S_urb_dist_m1)
# plot(res)
# # major errors... try beta distribution
# 
# 
# herb2020.S_urb_dist_m2 <- glmmTMB(Herbivory.Sept_mean  ~ (1|Block) +  (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# # Error in eval(family$initialize) : y values must be 0 < y < 1
# # recode: 0s as 0.00001 & 1 as 0.999999
# 
# 
# herb2020.S_urb_dist_m3 <- glmmTMB(Herbivory.Sept_mean_recode  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020.S_urb_dist_m3)
# plot(res)
# # IT WORKS
# 
# summary(herb2020.S_urb_dist_m3)
# testDispersion(herb2020.S_urb_dist_m3)
# testZeroInflation(herb2020.S_urb_dist_m3)
# 
# # address overdispersion through an individual-level random effect
# 
# herb2020.S_urb_dist_m4 <- glmmTMB(Herbivory.Sept_mean_recode  ~ (1|Block) + (1|Population/Family) + City_dist + (1|ID),
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020.S_urb_dist_m4)
# plot(res)
# # better but still not optimal
# 
# testDispersion(herb2020.S_urb_dist_m4) # is it underdispersed now?
# testZeroInflation(herb2020.S_urb_dist_m4)
# 
# # try binomial and then quantitative?


herb2020.S_urb_dist_m5 <- glmer((Herbivory.Sept_mean_binary) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herb2020.S_urb_dist_m5)
plot(res)
# looks great! but there's an outlier?
testOutliers(herb2020.S_urb_dist_m5) # no
summary(herb2020.S_urb_dist_m5)

car::Anova(herb2020.S_urb_dist_m5) # nothing sig

# main effects:
herb2020.S_urb_dist_m5_ME <- glmer((Herbivory.Sept_mean_binary) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))


# herb2020.S_urb_dist_m6 <- lmer(Herbivory.Sept_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_urb_dist_m6, type='diag') #very right-skewed... try cube root
# 
# herb2020.S_urb_dist_m7 <- lmer(Herbivory.Sept_mean^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_urb_dist_m7, type='diag') # still right-skewed... try log
# 
# herb2020.S_urb_dist_m8 <- lmer(log(Herbivory.Sept_mean) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_urb_dist_m8, type='diag') # looks good but still singular... try removing block
# 
# herb2020.S_urb_dist_m9 <- lmer(log(Herbivory.Sept_mean) ~  (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... try removing Fam instead
# 
# herb2020.S_urb_dist_m10 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population) + (1|Block) + City_dist* Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... remove block
# 
# herb2020.S_urb_dist_m11 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population) + City_dist* Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 

# try glmmTMB
# test1 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population) + City_dist* Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   family = gaussian) # it works!

herb2020.S_urb_dist_m12 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population/Family) + City_dist* Transect_ID,
  data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
  family = gaussian) # it works! use this

# test1 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population) + (1|Block) + City_dist* Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   family = gaussian) # singular


# main effects
herb2020.S_urb_dist_m12_ME <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population/Family) + City_dist + Transect_ID,
  data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
  family = gaussian)



# Urb sites / urb_score----------

# herb2020.S_urb_usc_m1 <- glmer(Herbivory.Sept_mean ~ (1|Block)  + (1|Population/Family) + Urb_score * Transect_ID,
#     data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#     family = binomial,
#   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# res <- simulateResiduals(herb2020.S_urb_usc_m1)
# plot(res)
# # major errors... try beta distribution
# 
# 
# herb2020.S_urb_usc_m2 <- glmmTMB(Herbivory.Sept_mean  ~ (1|Block) +  (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# # Error in eval(family$initialize) : y values must be 0 < y < 1
# # recode: 0s as 0.00001 & 1 as 0.999999
# 
# 
# herb2020.S_urb_usc_m3 <- glmmTMB(Herbivory.Sept_mean_recode  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020.S_urb_usc_m3)
# plot(res)
# # IT WORKS
# 
# summary(herb2020.S_urb_usc_m3)
# testDispersion(herb2020.S_urb_usc_m3)
# testZeroInflation(herb2020.S_urb_usc_m3)
# 
# # address overdispersion through an individual-level random effect
# 
# herb2020.S_urb_usc_m4 <- glmmTMB(Herbivory.Sept_mean_recode  ~ (1|Block) + (1|Population/Family) + Urb_score + (1|ID),
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020.S_urb_usc_m4)
# plot(res)
# # better but still not optimal
# 
# testDispersion(herb2020.S_urb_usc_m4) # is it underdispersed now?
# testZeroInflation(herb2020.S_urb_usc_m4)
# 
# # try binomial and then quantitative?


herb2020.S_urb_usc_m5 <- glmer((Herbivory.Sept_mean_binary) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herb2020.S_urb_usc_m5)
plot(res)
# looks great! 
summary(herb2020.S_urb_usc_m5)

car::Anova(herb2020.S_urb_usc_m5) # nothing sig


# main effects
herb2020.S_urb_usc_m5_ME <- glmer((Herbivory.Sept_mean_binary) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

# herb2020.S_urb_usc_m6 <- lmer(Herbivory.Sept_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_urb_usc_m6, type='diag') #very right-skewed... try cube root
# 
# herb2020.S_urb_usc_m7 <- lmer(Herbivory.Sept_mean^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_urb_usc_m7, type='diag') # still right-skewed... try log
# 
# herb2020.S_urb_usc_m8 <- lmer(log(Herbivory.Sept_mean) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_urb_usc_m8, type='diag') # looks great  but still singular... try removing block
# 
# herb2020.S_urb_usc_m9 <- lmer(log(Herbivory.Sept_mean) ~  (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... try removing Fam instead
# 
# herb2020.S_urb_usc_m10 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population) + (1|Block) + Urb_score* Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... remove block
# 
# herb2020.S_urb_usc_m11 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population) + Urb_score* Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 

# try glmmTMB
# test1 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population) + Urb_score* Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   family = gaussian) # it works!

herb2020.S_urb_usc_m12 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population/Family) + Urb_score* Transect_ID,
  data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
  family = gaussian) # it works! use this
# 
# test1 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population) + (1|Block) + Urb_score* Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   family = gaussian) # singular



# main effects
herb2020.S_urb_usc_m12_ME <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population/Family) + Urb_score + Transect_ID,
  data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
  family = gaussian) 


```
#### Entire gradient: *Marg sig for city_dist (nothing for urb_score)
##### City_dist
```{r}
car::Anova(herb2020.S_gr_dist_m5) # binomial: marginally sig
car::Anova(herb2020.S_gr_dist_m12) # quantitative: not sig


# ANy variation within families or populations?
m.1 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population/Family),
            data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
            REML = T,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

ranova(m.1)
# No for both


sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)

# even when I use glmmTMB model, I still get tiny variances- on par with the singular model.
## print(VarCorr(herb2020.S_gr_dist_m12),comp="Variance") 


write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_HerbivorySept_lmer_PVE.csv"), col.names=TRUE, sep=",")
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_HerbivorySept_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

##### Urb_score
```{r}
car::Anova(herb2020.S_gr_usc_m5) # binomial: not sig
car::Anova(herb2020.S_gr_usc_m12) # quantitative: not sig

```


#### Urban subtransects: *Nothing sig for either
##### City_dist
```{r}
car::Anova(herb2020.S_urb_dist_m5) # binomial: nothing sig
car::Anova(herb2020.S_urb_dist_m5_ME) # binomial: nothing sig
car::Anova(herb2020.S_urb_dist_m12) # quantitative: nothing sig
car::Anova(herb2020.S_urb_dist_m12_ME) # quantitative main effects: not sig

AIC(herb2020.S_urb_dist_m12, herb2020.S_urb_dist_m12_ME)
# main effects has lower AIC



# ANy variation among families or populations?
m.1 <- lmer(log(Herbivory.Sept_mean) ~  (1|Population/Family) + City_dist ,
  data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)),
  REML = T)

ranova(m.1)
# no

m.2 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population/Family) + Transect_ID,
              data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Urb_Rur == "Urban"),

            REML = F)
car::Anova(m.2)
# not among transects either


m.3 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population/Family) + Transect_ID,
              data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Urb_Rur == "Urban"),
            REML = T)
car::Anova(m.3)
# also not sig among transects


sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_HerbivorySept_urban_lmer_PVE.csv"), col.names=TRUE, sep=",")
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_HerbivorySept_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
write.table(car::Anova(m.2), here::here("./Figures_Tables/ranova_PVE/2020_HerbivorySept_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

##### Urb_score
```{r}
car::Anova(herb2020.S_urb_usc_m5) # binomial: ntohing sig
car::Anova(herb2020.S_urb_usc_m5_ME)# binomial: ntohing sig
car::Anova(herb2020.S_urb_usc_m12) # quantitative: nothing sig
car::Anova(herb2020.S_urb_usc_m12_ME) # quantitative main effects: not sig

AIC(herb2020.S_urb_usc_m12, herb2020.S_urb_usc_m12_ME)
# main effects has lower AIC
```



#### Export ANOVA
```{r}
anova_table_flx(herb2020.S_gr_dist_m5)
anova_table_flx(herb2020.S_gr_dist_m12)
anova_table_flx(herb2020.S_gr_usc_m5)
anova_table_flx(herb2020.S_gr_usc_m12)

anova_table_flx(herb2020.S_urb_dist_m5)
anova_table_flx(herb2020.S_urb_dist_m5_ME)
anova_table_flx(herb2020.S_urb_dist_m12)
anova_table_flx(herb2020.S_urb_dist_m12_ME)
anova_table_flx(herb2020.S_urb_usc_m5)
anova_table_flx(herb2020.S_urb_usc_m5_ME)
anova_table_flx(herb2020.S_urb_usc_m12)
anova_table_flx(herb2020.S_urb_usc_m12_ME)

AIC_compare.city_dist_transf_binomial(herb2020.S_urb_dist_m5,
                      herb2020.S_urb_dist_m5_ME)

AIC_compare.city_dist_transf_quantitative(herb2020.S_urb_dist_m12,
                      herb2020.S_urb_dist_m12_ME)
    
AIC_compare.urb_score_transf_binomial(herb2020.S_urb_usc_m5,
                      herb2020.S_urb_usc_m5_ME)

AIC_compare.urb_score_transf_quantitative(herb2020.S_urb_usc_m12,
                                          herb2020.S_urb_usc_m12_ME)

# list of models
# model_list <- append(model_list,
# 
# list(
# 
# herb2020.S_gr_dist_m5,
# herb2020.S_gr_dist_m12,
# herb2020.S_gr_usc_m5,
# herb2020.S_gr_usc_m12,
# herb2020.S_urb_dist_m5,
# herb2020.S_urb_dist_m5_ME,
# herb2020.S_urb_dist_m12,
# herb2020.S_urb_dist_m12_ME,
# herb2020.S_urb_usc_m5,
# herb2020.S_urb_usc_m5_ME,
# herb2020.S_urb_usc_m12,
# herb2020.S_urb_usc_m12_ME
#   
# ))
```


## Relative Growth Rate
### lmer: diagnostics
```{r}
# GRADIENT / CITY_DIST-----

# rgr_gr_city_m1 <- lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(rgr_gr_city_m1, type = "diag") # is singular, looks normal except for left tail (but otherwise looks fine... I think it's kurtotic)... try taking out block
# 
# diagnostic(resid(rgr_gr_city_m1)) # very kurtotic
# 
# rgr_gr_city_m2 <- lmer(rel_growth_rate ~  (1|Population/Family) + City_dist,
#   data = heights_both_2020, REML = F) # still singular... take out Fam
# 
# rgr_gr_city_m3 <- lmer(rel_growth_rate ~ (1|Block) +(1|Population) + City_dist,
#   data = heights_both_2020, REML = F)#  singular. take out block
# 
# rgr_gr_city_m4 <- lmer(rel_growth_rate ~ (1|Population) + City_dist,
#   data = heights_both_2020, REML = F)#  singular...
# 
# # try glmmtmb
# test1 <- glmmTMB(rel_growth_rate ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020,
#   family = gaussian) # singular. take out block
# 
# test1 <- glmmTMB(rel_growth_rate ~ (1|Population/Family) + City_dist,
#   data = heights_both_2020,
#   family = gaussian) # singular. take out Family
# 
# rgr_gr_city_m5 <- glmmTMB(rel_growth_rate ~ (1|Population) + City_dist,
#   data = heights_both_2020,
#   family = gaussian) # singular...

# try binomial, then removing zeroes and going from there


# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

# recode plants as having height or not
heights_both_2020$rel_growth_rate_binary <- heights_both_2020$rel_growth_rate
heights_both_2020$rel_growth_rate_binary[heights_both_2020$rel_growth_rate > 0] <- 1
heights_both_2020$rel_growth_rate_binary[heights_both_2020$rel_growth_rate <= 0] <- 0


rgr_gr_city_m6 <- glmer((rel_growth_rate_binary) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_both_2020,
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(rgr_gr_city_m6)
plot(res)
# looks great! 
summary(rgr_gr_city_m6)

car::Anova(rgr_gr_city_m6) # not sig


# rgr_gr_city_m7 <- lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(rgr_gr_city_m7, type='diag') #very right-skewed but otherwise aligns well with normal curve... try sqrt

rgr_gr_city_m8 <- lmer(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(rgr_gr_city_m8, type='diag') # looks great!






# GRADIENT / URB SCORE-----

# rgr_gr_usc_m1 <- lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(rgr_gr_usc_m1, type = "diag") # is singular, looks normal except for left tail (but otherwise looks fine... I think it's kurtotic)... take out block
# 
# rgr_gr_usc_m2 <- lmer(rel_growth_rate ~  (1|Population/Family) + Urb_score,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(rgr_gr_usc_m2, type = "diag") # still singular... take out Pop/Fam
# 
# rgr_gr_usc_m3 <- lmer(rel_growth_rate ~ (1|Block) + Urb_score,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(rgr_gr_usc_m3, type = "diag") # not singular. looks normal except for left tail (but otherwise looks fine... I think it's kurtotic)..
# 
# diagnostic(resid(rgr_gr_usc_m3)) # high kurtosis


# try binomial, then removing zeroes and going from there

# TAKING OUT PLANTS W/negative RGR & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

rgr_gr_usc_m6 <- glmer((rel_growth_rate_binary) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_both_2020,
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(rgr_gr_usc_m6)
plot(res)
# looks great! 
summary(rgr_gr_usc_m6)

car::Anova(rgr_gr_usc_m6) # not sig


# rgr_gr_usc_m7 <- lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(rgr_gr_usc_m7, type='diag') #very right-skewed but otherwise aligns well with normal curve... try sqrt

rgr_gr_usc_m8 <- lmer(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(rgr_gr_usc_m8, type='diag') # looks great!




# URB SUBTRANSECTS / CITY_DIST-----

# rgr_urbsubs_city_m1 <- lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(rgr_urbsubs_city_m1, type = "diag") # is singular, looks normal except for left tail (but otherwise looks fine... I think it's kurtotic)... take out block
# 
# rgr_urbsubs_city_m2 <- lmer(rel_growth_rate ~  (1|Population/Family) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F) # is singular,  take out Pop/Fam
# 
# rgr_urbsubs_city_m3 <- lmer(rel_growth_rate ~ (1|Block) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F)  # is singular... take out block and pop/fam
# 
# rgr_urbsubs_city_m4 <- lm(rel_growth_rate ~  City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"))
# sjPlot::plot_model(rgr_urbsubs_city_m4, type = "diag")
# 
# diagnostic(resid(rgr_urbsubs_city_m4)) # high kurtosis


# try binomial, then removing zeroes and going from there

# TAKING OUT PLANTS W/negative RGR & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

rgr_urbsubs_city_m5 <- glmer((rel_growth_rate_binary) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban" ),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(rgr_urbsubs_city_m5)
plot(res)
# looks great! 
summary(rgr_urbsubs_city_m5)

car::Anova(rgr_urbsubs_city_m5) # city_dist marg sig

# main effects:
rgr_urbsubs_city_m5_ME <- glmer((rel_growth_rate_binary) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban" ),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
car::Anova(rgr_urbsubs_city_m5_ME) # city_dist marg sig

# 
# rgr_urbsubs_city_m6 <- lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) +  City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(rgr_urbsubs_city_m6, type='diag') # singular... but first align it w/normal curve. do sqrt 
# 
# rgr_urbsubs_city_m7 <- lmer(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population/Family) +  City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(rgr_urbsubs_city_m7, type='diag') # meets expectations but still singular... try glmmTMB

rgr_urbsubs_city_m8 <- glmmTMB(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population/Family) +  City_dist * Transect_ID,
  data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
  family = gaussian) # it works! use this


# main effects
# rgr_urbsubs_city_m8_ME <- glmmTMB(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population/Family) +  City_dist + Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
#   family = gaussian) # singular... take out block

rgr_urbsubs_city_m8_ME.1 <- glmmTMB(sqrt(rel_growth_rate) ~ (1|Population/Family) +  City_dist + Transect_ID,
  data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
  family = gaussian) # it works. put back block and take out fam and see how it compares to full model
# 
# rgr_urbsubs_city_m8_ME.2 <- glmmTMB(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population) +  City_dist + Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
#   family = gaussian)
# 
# car::Anova(rgr_urbsubs_city_m8)
# car::Anova(rgr_urbsubs_city_m8_ME.1) # identical to model below!
# car::Anova(rgr_urbsubs_city_m8_ME.2)



# URB SUBTRANSECTS / URB SCORE-----

# rgr_urbsubs_usc_m1 <- lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(rgr_urbsubs_usc_m1, type = "diag") # is singular, looks normal except for left tail (but otherwise looks fine... I think it's kurtotic)... take out block
# 
# rgr_urbsubs_usc_m2 <- lmer(rel_growth_rate ~  (1|Population/Family) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F) # is singular,  take out Pop/Fam
# 
# rgr_urbsubs_usc_m3 <- lmer(rel_growth_rate ~ (1|Block) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F)  # is singular... take out block and pop/fam
# 
# rgr_urbsubs_usc_m4 <- lm(rel_growth_rate ~  Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"))
# sjPlot::plot_model(rgr_urbsubs_usc_m4, type = "diag") 
# 
# diagnostic(resid(rgr_urbsubs_usc_m4)) # high kurtosis


# try binomial, then removing zeroes and going from there

# TAKING OUT PLANTS W/negative RGR & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

rgr_urbsubs_usc_m5 <- glmer((rel_growth_rate_binary) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban" ),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(rgr_urbsubs_usc_m5)
plot(res)
# looks great! 
summary(rgr_urbsubs_usc_m5)

car::Anova(rgr_urbsubs_usc_m5) # nothing sig

# main effects:
rgr_urbsubs_usc_m5_ME <- glmer((rel_growth_rate_binary) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))


# rgr_urbsubs_usc_m6 <- lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) +  Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(rgr_urbsubs_usc_m6, type='diag') #very right-skewed but otherwise aligns well with normal curve... try sqrt (also singular)
# 
# rgr_urbsubs_usc_m7 <- lmer(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population/Family) +  Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(rgr_urbsubs_usc_m7, type='diag') # looks great! now address singularity... try glmmTMB

rgr_urbsubs_usc_m8 <- glmmTMB(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population/Family) +  Urb_score * Transect_ID,
  data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 & Urb_Rur == "Urban"),
  family = gaussian) # not singular! Use this


# main effects
# rgr_urbsubs_usc_m8_ME <- glmmTMB(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population/Family) +  Urb_score + Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 & Urb_Rur == "Urban"),
#   family = gaussian) # singular... remove block

rgr_urbsubs_usc_m8_ME.1 <- glmmTMB(sqrt(rel_growth_rate) ~ (1|Population/Family) +  Urb_score + Transect_ID,
  data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
  family = gaussian) # it works. put back block and take out fam and see how it compares to full model

# rgr_urbsubs_usc_m8_ME.2 <- glmmTMB(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population) +  Urb_score + Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
#   family = gaussian) # it works
# 
# car::Anova(rgr_urbsubs_usc_m8_ME)
# car::Anova(rgr_urbsubs_usc_m8_ME.1) # identical to model below!
# car::Anova(rgr_urbsubs_usc_m8_ME.2)



```

### Entire gradient: *Not sig for either
#### City_dist
```{r}
car::Anova(rgr_gr_city_m6) # not sig
car::Anova(rgr_gr_city_m8) # not sig


# ANy variation within families or populations?
m.1 <- lmer(sqrt(rel_growth_rate) ~ (1|Population/Family),
            data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1),
            control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)),
            REML = T)


ranova(m.1)
# nope
sum.1 <- summary(m.1)


variances1 <- print(VarCorr(m.1),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_growthrate_lmer_PVE.csv"), col.names=TRUE, sep=",")
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_growthrate_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

#### Urb_score
```{r}
car::Anova(rgr_gr_usc_m6) #not sig
car::Anova(rgr_gr_usc_m8) #not sig

```


### Urban subtransects: *Marg sig for city_dist (quant) & urb_score (quant)
#### City_dist
```{r}
car::Anova(rgr_urbsubs_city_m5) # binomial: nothing sig
car::Anova(rgr_urbsubs_city_m5_ME) # binomial: nothing sig
car::Anova(rgr_urbsubs_city_m8) # quantitative: transect sig & city_dist marg sig
car::Anova(rgr_urbsubs_city_m8_ME.1) # quantitative: transect marg sig & city_dist marg sig

AIC(rgr_urbsubs_city_m5, rgr_urbsubs_city_m5_ME) # ME model lower AIC
AIC(rgr_urbsubs_city_m8, rgr_urbsubs_city_m8_ME.1) # ME model lower AIC
summary(rgr_urbsubs_city_m8_ME.1)

# ANy variation among families or populations?
m.1 <- lmer(sqrt(rel_growth_rate) ~  (1|Population/Family) + City_dist ,
  data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 & Urb_Rur == "Urban"),
  REML = T)

ranova(m.1)
# no

m.2 <- lmer(sqrt(rel_growth_rate) ~ (1|Population/Family) + Transect_ID,
  data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 & Urb_Rur == "Urban"),
            REML = F)
car::Anova(m.2)
# not among transects either


m.3 <- lmer(sqrt(rel_growth_rate) ~ (1|Population/Family) + Transect_ID,
  data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
  REML = T)
car::Anova(m.3)
# also not sig among transects


sum.1 <- summary(m.1)

variances1 <- print(VarCorr(m.1),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)


write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_growthrate_urban_lmer_PVE.csv"), col.names=TRUE, sep=",")
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_growthrate_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
write.table(car::Anova(m.2), here::here("./Figures_Tables/ranova_PVE/2020_growthrate_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

#### Urb_score
```{r}
car::Anova(rgr_urbsubs_usc_m5) # binomial: nothing sig
car::Anova(rgr_urbsubs_usc_m5_ME) # binomial: nothing sig
car::Anova(rgr_urbsubs_usc_m8) # quantitative: interaxn marg sig
car::Anova(rgr_urbsubs_usc_m8_ME.1) # quantitative: nothing sig

AIC(rgr_urbsubs_usc_m8, rgr_urbsubs_usc_m8_ME.1) # ME model lower AIC but not significant difference
summary(rgr_urbsubs_usc_m8)
```


### Export ANOVA
```{r}
anova_table_flx(rgr_gr_city_m6)
anova_table_flx(rgr_gr_city_m8)
anova_table_flx(rgr_gr_usc_m6)
anova_table_flx(rgr_gr_usc_m8)

anova_table_flx(rgr_urbsubs_city_m5)
anova_table_flx(rgr_urbsubs_city_m5_ME)
anova_table_flx(rgr_urbsubs_city_m8)
anova_table_flx(rgr_urbsubs_city_m8_ME.1)
anova_table_flx(rgr_urbsubs_usc_m5)
anova_table_flx(rgr_urbsubs_usc_m5_ME)
anova_table_flx(rgr_urbsubs_usc_m8)
anova_table_flx(rgr_urbsubs_usc_m8_ME.1)

AIC_compare.city_dist_transf_binomial(rgr_urbsubs_city_m5 ,
                       rgr_urbsubs_city_m5_ME)
    
AIC_compare.city_dist_transf_quantitative( rgr_urbsubs_city_m8,
                       rgr_urbsubs_city_m8_ME.1) 

AIC_compare.urb_score_transf_binomial(rgr_urbsubs_usc_m5 ,
                       rgr_urbsubs_usc_m5_ME)
    
AIC_compare.urb_score_transf_quantitative( rgr_urbsubs_usc_m8,
                       rgr_urbsubs_usc_m8_ME.1) 

# list of models
# model_list <- append(model_list,
# 
# list(
# 
# rgr_gr_city_m6,
# rgr_gr_city_m8,
# rgr_gr_usc_m6,
# rgr_gr_usc_m8,
# rgr_urbsubs_city_m5,
# rgr_urbsubs_city_m5_ME,
# rgr_urbsubs_city_m8,
# rgr_urbsubs_city_m8_ME.1,
# rgr_urbsubs_usc_m5,
# rgr_urbsubs_usc_m5_ME,
# rgr_urbsubs_usc_m8,
# rgr_urbsubs_usc_m8_ME.1
#   
# ))
```


## Number of Ramets
### June ramets
#### glmer: diagnostics
```{r}
# GRADIENT / CITY_DIST-----

# rametsJ_gr_city_m1 <- glmer(Ramets_June ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsJ_gr_city_m1)
# plot(res)
# # convergence warning and dispersion significant...
# testOverdispersion(rametsJ_gr_city_m1) # add ID as random effect
# address overdispersion through an individual-level random effect
heights_both_2020$ID <- seq.int(nrow(heights_both_2020))

rametsJ_gr_city_m2 <- glmer(Ramets_June ~ (1|Block) + (1|Population/Family) + City_dist + (1|ID),
  data = heights_both_2020,
  family = poisson,
  control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))
res <- simulateResiduals(rametsJ_gr_city_m2)
plot(res)
# looks good!



# GRADIENT / URB SCORE-----

# rametsJ_gr_usc_m1 <- glmer(Ramets_June ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsJ_gr_usc_m1)
# plot(res)
# # dispersion significant...
# testOverdispersion(rametsJ_gr_usc_m1) # add ID as random effect


rametsJ_gr_usc_m2 <- glmer(Ramets_June ~ (1|Block) + (1|Population/Family) + Urb_score + (1|ID),
  data = heights_both_2020,
  family = poisson,
  control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))
res <- simulateResiduals(rametsJ_gr_usc_m2)
plot(res)
# looks good! says there's an outlier but I think it's fine



# URB SUBTRANSECTS / CITY_DIST-----

rametsJ_urbsubs_city_m1 <- glmer(Ramets_June ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = poisson,
  control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))
res <- simulateResiduals(rametsJ_urbsubs_city_m1)
plot(res)
# says there's an outlier but I think it's fine


# main effects
rametsJ_urbsubs_city_m1_ME <- glmer(Ramets_June ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = poisson,
  control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))



# URB SUBTRANSECTS / URB SCORE-----

# rametsJ_urbsubs_urbsubs_m1 <- glmer(Ramets_June ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsJ_urbsubs_urbsubs_m1)
# plot(res) # looks good but is singular... take out block
# 
# rametsJ_urbsubs_urbsubs_m2 <- glmer(Ramets_June ~ (1|Population/Family) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # still singular... take out Fam
# 
# rametsJ_urbsubs_urbsubs_m3 <- glmer(Ramets_June ~  (1|Population) + (1|Block) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsJ_urbsubs_urbsubs_m3)
# plot(res) # # dispersion significant...
# testOverdispersion(rametsJ_urbsubs_urbsubs_m3) # add ID as random effect
# 
# rametsJ_urbsubs_urbsubs_m4 <- glmer(Ramets_June ~ (1|Block) +(1|Population/Family) + (1|ID) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsJ_urbsubs_urbsubs_m4)
# plot(res)# looks good but still singular... take out block
# 
# rametsJ_urbsubs_urbsubs_m5 <- glmer(Ramets_June ~ (1|Population/Family) + (1|ID) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... take out Family
# 
# rametsJ_urbsubs_urbsubs_m6 <- glmer(Ramets_June ~ (1|Population) + (1|ID) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular...

# try glmmTMB
rametsJ_urbsubs_urbsubs_m7 <- glmmTMB(Ramets_June ~ (1|Block) +(1|Population/Family) + (1|ID) + Urb_score * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = poisson) # it works! use this



# main effects
rametsJ_urbsubs_urbsubs_m7_ME <- glmmTMB(Ramets_June ~ (1|Block) +(1|Population/Family) + (1|ID) + Urb_score + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = poisson) # it works! use this


```

#### Entire gradient: *Nothing sig for either
##### City_dist
```{r}
car::Anova(rametsJ_gr_city_m2) # not sig


# ANy variation within families or populations?

##### TACTIC 1: try bootstrapping #####
# NOT PERFECT b/c can't nest family within pop but trying a few ways to get at the correct answer.
# https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html#test-of-random-parameter
library(pbkrtest)
library(pbnm)


# JUST POPULATION
gmm <-  glmer(Ramets_June ~ City_dist + (1|Population), # can't leave in Family... doesn't work
  family = poisson,
              data = heights_both_2020,
  control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))



# IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
gmm1 <-  glmer(Ramets_June ~ City_dist + (1|Population/Family), 
  family = poisson,
              data = heights_both_2020,
  control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))


# POP:FAMILY
gmm2 <-  glmer(Ramets_June ~ City_dist + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
  family = poisson,
              data = heights_both_2020,
  control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))


# UNIQUE FAMILIES
heights_both_2020$Family_unique <- paste(heights_both_2020$Population, heights_both_2020$Family)
gmm3 <-  glmer(Ramets_June ~ City_dist + (1|Family_unique),
  family = poisson,
              data = heights_both_2020,
  control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))


# EQUIVALENT TO FAM NESTED W/IN POP
gmm4 <-  glmer(Ramets_June ~ City_dist + (1|Population:Family) + (1|Population),
  family = poisson,
              data = heights_both_2020,
  control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))



# REDUCED MODEL
gmmDG1 <- glm(Ramets_June ~ City_dist,
  family = poisson,
              data = heights_both_2020)

### RESULTS ###
# POPULATION (so, results are about populations)
pbgmmDg1 <- pbnm(gmm,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) %T>%
  summary() %>%
  print()   # p = 0.396 ... no var among pops

# EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
pbgmmDg4 <- pbnm(gmm4,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
ranova_pop <- summary(pbgmmDg4) %T>%
  print() # p =  0.159... no var among pops accounting for fams

# POP:FAMILY (so, results are about families)- accounts for fams being in same pop
pbgmmDg2 <- pbnm(gmm2,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
ranova_fam <- summary(pbgmmDg2) %T>%
  print() # p = 0.441 ... little var among families crossed w/ pops

# UNIQUE FAMILIES (so, results are about families)
pbgmmDg3 <- pbnm(gmm3,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) %T>%
  summary() %>%
  print() # p = 0.441 ... little var among families, period



##### use anova to test significance of terms (this isn't what we want, though): #####
## test Pop/Fam
anova(gmm1, gmmDG1) # p = 0.0001594 ***

## test Pop/Fam but expanded
anova(gmm4, gmmDG1) # p = 0.0001594 ***      # SAME AS ABOVE

## test Pop
anova(gmm, gmmDG1) # p = 0.024*

## test Fam
anova(gmm3, gmmDG1) # p =  3.155e-05 ***

## test pop:fam
anova(gmm2, gmmDG1) # p =  3.155e-05 ***    # SAME AS ABOVE



#--------- FINAL RESULTS: ----------#
# Bootstrapping:
# - Pop:    NOT SIGNIFICANT
# - Family: NOT SIGNIFICANT
# anova:
# - Pop:    SIGNIFICANT
# - Family: SIGNIFICANT

# --- DO THE 2 METHODS MATCH? ---#
#       [ ]    NO
#             



##### old code #####

sum.1 <- summary(gmm4)

variances1 <- print(VarCorr(gmm4),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)

# export percent variance explained
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Ramets_June_glmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)

# export ranova
sink(here::here("./Figures_Tables/ranova_PVE/2020_Ramets_June_glmer_ranova.csv"))
print("POPULATION", sep="\n\n")
print(ranova_pop, sep="\n\n")
  cat("\n")
print("FAMILY", sep="\n\n")
print(ranova_fam, sep="\n\n")
  cat("\n")
if (ranova_pop[1] <= 0.05){
  print ('There is variance among populations')}
if (ranova_pop[1] > 0.05){
  print ("There is not much variance among populations")}
if (ranova_fam[1] <= 0.05){
  print ("There is variance among families")}
if (ranova_fam[1] > 0.05){
  print ("There is not much variance among families")}
sink()


```

##### Urb_score
```{r}
car::Anova(rametsJ_gr_usc_m2) # not sig

```


#### Urban subtransects: *Nothing sig for city_dist; urb_score sig and transect marg sig
##### City_dist
```{r}
car::Anova(rametsJ_urbsubs_city_m1) # not sig
car::Anova(rametsJ_urbsubs_city_m1_ME) # not sig

AIC(rametsJ_urbsubs_city_m1, rametsJ_urbsubs_city_m1_ME) # ME has lower aic but <2

```

##### Urb_score
```{r}
car::Anova(rametsJ_urbsubs_urbsubs_m7)    # urb_score sig and transect marg sig
car::Anova(rametsJ_urbsubs_urbsubs_m7_ME) # urb_score sig and transect marg sig

AIC(rametsJ_urbsubs_urbsubs_m7, rametsJ_urbsubs_urbsubs_m7_ME) # ME has slightly lower aic but <2

```


#### Export ANOVA
```{r}
anova_table_flx(rametsJ_gr_city_m2)
anova_table_flx(rametsJ_gr_usc_m2)
anova_table_flx(rametsJ_urbsubs_city_m1)
anova_table_flx(rametsJ_urbsubs_city_m1_ME)
anova_table_flx(rametsJ_urbsubs_urbsubs_m7)
anova_table_flx(rametsJ_urbsubs_urbsubs_m7_ME)

AIC_compare.city_dist(rametsJ_urbsubs_city_m1,
                      rametsJ_urbsubs_city_m1_ME)
    
AIC_compare.urb_score(rametsJ_urbsubs_urbsubs_m7,
                      rametsJ_urbsubs_urbsubs_m7_ME) 

# list of models
# model_list <- append(model_list,
# 
# list(
# 
# rametsJ_gr_city_m2,
# rametsJ_gr_usc_m2,
# rametsJ_urbsubs_city_m1,
# rametsJ_urbsubs_city_m1_ME,
# rametsJ_urbsubs_urbsubs_m7,
# rametsJ_urbsubs_urbsubs_m7_ME
#   
# ))
```
### Sept ramets
#### glmer: diagnostics
```{r}
# GRADIENT / CITY_DIST-----

# rametsS_gr_city_m1 <- glmer(Ramets_Sept ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsS_gr_city_m1)
# plot(res) # looks good but singular... take out block
# 
# rametsS_gr_city_m2 <- glmer(Ramets_Sept ~  (1|Population/Family) + City_dist,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... take out fam
# 
# rametsS_gr_city_m3 <- glmer(Ramets_Sept ~ (1|Block) +  (1|Population) + City_dist,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... take out block
# 
# rametsS_gr_city_m4 <- glmer(Ramets_Sept ~ (1|Population) + City_dist,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... 

# try glmmTMB
# test1 <- glmmTMB(Ramets_Sept ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020,
#   family = poisson) # singular... take out block

rametsS_gr_city_m5 <- glmmTMB(Ramets_Sept ~  (1|Population/Family) + City_dist,
  data = heights_both_2020,
  family = poisson) # it works! use this

# test1 <- glmmTMB(Ramets_Sept ~ (1|Block) + (1|Population) + City_dist,
#   data = heights_both_2020,
#   family = poisson) # it works!
# 
# car::Anova(rametsS_gr_city_m5) # both are identical
# car::Anova(test1)



# GRADIENT / URB SCORE-----

# rametsS_gr_usc_m1 <- glmer(Ramets_Sept ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsS_gr_usc_m1)
# plot(res)
# # looks good! though singular... take out block
# 
# rametsS_gr_usc_m2 <- glmer(Ramets_Sept ~  (1|Population/Family) + Urb_score,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... take out fam
# 
# rametsS_gr_usc_m3 <- glmer(Ramets_Sept ~ (1|Block) + (1|Population) +  Urb_score,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... take out block
# 
# rametsS_gr_usc_m4 <- glmer(Ramets_Sept ~  (1|Population) +  Urb_score,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular...

# try glmmTMB
rametsS_gr_usc_m5 <- glmmTMB(Ramets_Sept ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_both_2020,
  family = poisson) # it works! use this



# URB SUBTRANSECTS / CITY_DIST-----

# rametsS_urbsubs_city_m1 <- glmer(Ramets_Sept ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsS_urbsubs_city_m1)
# plot(res) # looks good though singular... take out block
# 
# rametsS_urbsubs_city_m2 <- glmer(Ramets_Sept ~  (1|Population/Family) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... take out fam
# 
# rametsS_urbsubs_city_m3 <- glmer(Ramets_Sept ~ (1|Block) + (1|Population) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) #  singular... take out block
# 
# rametsS_urbsubs_city_m4 <- glm(Ramets_Sept ~ (1|Population) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson) # this works!

# try glmmTMB
rametsS_urbsubs_city_m5 <- glmmTMB(Ramets_Sept ~ (1|Block) + (1|Population/Family) +  City_dist * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = poisson) # it works! use this


# main effects
rametsS_urbsubs_city_m5_ME <- glmmTMB(Ramets_Sept ~ (1|Block) + (1|Population/Family) +  City_dist + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = poisson) # it works! use this



# URB SUBTRANSECTS / URB SCORE-----

# rametsS_urbsubs_urbsubs_m1 <- glmer(Ramets_Sept ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsS_urbsubs_urbsubs_m1)
# plot(res)
# # looks good but singular... take out block
# 
# rametsS_urbsubs_usc_m2 <- glmer(Ramets_Sept ~  (1|Population/Family) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... take out fam
# 
# rametsS_urbsubs_usc_m3 <- glmer(Ramets_Sept ~ (1|Block) + (1|Population) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... take out block
# 
# rametsS_urbsubs_usc_m4 <- glmer(Ramets_Sept ~  (1|Population) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular...

# try glmmTMB
rametsS_urbsubs_usc_m5 <- glmmTMB(Ramets_Sept ~ (1|Block) + (1|Population/Family) +  Urb_score * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = poisson) # it works! use this




# main effects
rametsS_urbsubs_usc_m5_ME <- glmmTMB(Ramets_Sept ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = poisson) # it works! use this

```

#### Entire gradient: *Sig for city_dist, not for urb_score
##### City_dist
```{r}
car::Anova(rametsS_gr_city_m5) # sig



# ANy variation within families or populations?

##### TACTIC 1: try bootstrapping #####
# NOT PERFECT b/c can't nest family within pop but trying a few ways to get at the correct answer.
# https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html#test-of-random-parameter
library(pbkrtest)
library(pbnm)

# can't handle glmmTMB so switching back to glmer

# JUST POPULATION
gmm <-  glmer(Ramets_Sept ~ City_dist + (1|Population), # can't leave in Family... doesn't work
  family = poisson,
              data = heights_both_2020)



# IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
gmm1 <-  glmer(Ramets_Sept ~ City_dist + (1|Population/Family), 
  family = poisson,
              data = heights_both_2020,
  control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))


# POP:FAMILY
gmm2 <-  glmer(Ramets_Sept ~ City_dist + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
  family = poisson,
              data = heights_both_2020,
  control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))


# UNIQUE FAMILIES
# heights_both_2020$Family_unique <- paste(heights_both_2020$Population, heights_both_2020$Family)
gmm3 <-  glmer(Ramets_Sept ~ City_dist + (1|Family_unique),
  family = poisson,
              data = heights_both_2020,
  control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))


# EQUIVALENT TO FAM NESTED W/IN POP
gmm4 <-  glmer(Ramets_Sept ~ City_dist + (1|Population:Family) + (1|Population),
  family = poisson,
              data = heights_both_2020)



# REDUCED MODEL
gmmDG1 <- glm(Ramets_Sept ~ City_dist,
  family = poisson,
              data = heights_both_2020)

### RESULTS ###
# POPULATION (so, results are about populations)
pbgmmDg1 <- pbnm(gmm,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
pbgmmDg1  %>%
  summary() %>%
  print()   # p = 1  ... no var among pops

# EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
pbgmmDg4 <- pbnm(gmm4,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
ranova_pop <- summary(pbgmmDg4) %T>%
  print() # p =  0.738  ... no var among pops accounting for fams

# POP:FAMILY (so, results are about families)- accounts for fams being in same pop
pbgmmDg2 <- pbnm(gmm2,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
ranova_fam <- summary(pbgmmDg2) %T>%
  print() # p = 1  ... little var among families crossed w/ pops

# UNIQUE FAMILIES (so, results are about families)
pbgmmDg3 <- pbnm(gmm3,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835)
pbgmmDg3 %>%
  summary() %>%
  print() # p = 1  ... little var among families, period



##### use anova to test significance of terms (this isn't what we want, though): #####
## test Pop/Fam
anova(gmm1, gmmDG1) # p =  1

## test Pop/Fam but expanded
anova(gmm4, gmmDG1) # p =   1    # SAME AS ABOVE

## test Pop
anova(gmm, gmmDG1) # p =  1

## test Fam
anova(gmm3, gmmDG1) # p =   1

## test pop:fam
anova(gmm2, gmmDG1) # p =   1    # SAME AS ABOVE



#--------- FINAL RESULTS: ----------#
# Bootstrapping:
# - Pop:    NOT SIGNIFICANT
# - Family: NOT SIGNIFICANT
# anova:
# - Pop:    NOT SIGNIFICANT
# - Family: NOT SIGNIFICANT

# --- DO THE 2 METHODS MATCH? ---#
#       [X]    YES
#             



##### old code #####

sum.1 <- summary(gmm4)

variances1 <- print(VarCorr(gmm4),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)

# export percent variance explained
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Ramets_Sept_glmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)

# export ranova
sink(here::here("./Figures_Tables/ranova_PVE/2020_Ramets_Sept_glmer_ranova.csv"))
print("POPULATION", sep="\n\n")
print(ranova_pop, sep="\n\n")
  cat("\n")
print("FAMILY", sep="\n\n")
print(ranova_fam, sep="\n\n")
  cat("\n")
# if (ranova_pop[1] <= 0.05){
#   print ('There is variance among populations')}
# if (ranova_pop[1] > 0.05){
  print ("There is not much variance among populations") #}
# if (ranova_fam[1] <= 0.05){
#   print ("There is variance among families")}
# if (ranova_fam[1] > 0.05){
  print ("There is not much variance among families") #}
sink()

```

##### Urb_score
```{r}
car::Anova(rametsS_gr_usc_m5) # not sig

```

#### Urban subtransects: *Sig for city_dist, not for urb_score
##### City_dist
```{r}
car::Anova(rametsS_urbsubs_city_m5) # city_dist sig
car::Anova(rametsS_urbsubs_city_m5_ME) # city_dist sig

AIC(rametsS_urbsubs_city_m5, rametsS_urbsubs_city_m5_ME) # <2 away from e.o. though ME is lower
```


##### Urb_score
```{r}
car::Anova(rametsS_urbsubs_usc_m5) # nothing sig
car::Anova(rametsS_urbsubs_usc_m5_ME) # nothing sig

AIC(rametsS_urbsubs_usc_m5, rametsS_urbsubs_usc_m5_ME) # <2 away from e.o. though ME is lower
```

#### Export ANOVA
```{r}
anova_table_flx(rametsS_gr_city_m5)
anova_table_flx(rametsS_gr_usc_m5)
anova_table_flx(rametsS_urbsubs_city_m5)
anova_table_flx(rametsS_urbsubs_city_m5_ME)
anova_table_flx(rametsS_urbsubs_usc_m5)
anova_table_flx(rametsS_urbsubs_usc_m5_ME)

AIC_compare.city_dist(rametsS_urbsubs_city_m5,
                      rametsS_urbsubs_city_m5_ME)
    
AIC_compare.urb_score(rametsS_urbsubs_usc_m5,
                      rametsS_urbsubs_usc_m5_ME) 

# # list of models
# model_list <- append(model_list,
# 
# list(
# 
# rametsS_gr_city_m5,
# rametsS_gr_usc_m5,
# rametsS_urbsubs_city_m5,
# rametsS_urbsubs_city_m5_ME,
# rametsS_urbsubs_usc_m5,
# rametsS_urbsubs_usc_m5_ME
#   
# ))
```

## Survival
### glmer: diagnostics
```{r}
# GRADIENT / CITY_DIST-----
surv20_gr_city_m1 <- glmer(dead_2020 ~ (1|Block) + (1|Population/Family) + City_dist,
  data = survival_2020,
  family = binomial(link = "logit"),
  nAGQ = 0)
res <- simulateResiduals(surv20_gr_city_m1)
plot(res)
# looks good!


# GRADIENT / URB SCORE-----
surv20_gr_usc_m1 <- glmer(dead_2020 ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = survival_2020,
  family = binomial(link = "logit"),
  nAGQ = 0,
    control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))
res <- simulateResiduals(surv20_gr_usc_m1)
plot(res)
# looks good!

# URB SUBTRANSECTS / CITY_DIST-----
surv20_urbsubs_city_m1 <- glmer(dead_2020 ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = survival_2020 %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ = 0,
    control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))
res <- simulateResiduals(surv20_urbsubs_city_m1)
plot(res)
# looks good!

# main effects
surv20_urbsubs_city_m1_ME <- glmer(dead_2020 ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = survival_2020 %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ = 0,
    control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))


# URB SUBTRANSECTS / URB SCORE-----
surv20_urbsubs_usc_m1 <- glmer(dead_2020 ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = survival_2020 %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ = 0,
    control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))
res <- simulateResiduals(surv20_urbsubs_usc_m1)
plot(res)
# looks good!

# main effects
surv20_urbsubs_usc_m1_ME <- glmer(dead_2020 ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = survival_2020 %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ = 0,
    control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))


```

### Entire gradient: *Nothing sig for either
#### City_dist
```{r}
car::Anova(surv20_gr_city_m1) # not sig




# ANy variation within families or populations?

##### TACTIC 1: try bootstrapping #####
# NOT PERFECT b/c can't nest family within pop but trying a few ways to get at the correct answer.
# https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html#test-of-random-parameter
library(pbkrtest)
library(pbnm)

# can't handle glmmTMB so switching back to glmer

# JUST POPULATION
gmm <-  glmer(dead_2020 ~ City_dist + (1|Population), # can't leave in Family... doesn't work
  family = binomial(link = "logit"),
  nAGQ = 0,
  data = survival_2020)



# IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
gmm1 <-  glmer(dead_2020 ~ City_dist + (1|Population/Family), 
  family = binomial(link = "logit"),
  nAGQ = 0,
  data = survival_2020)


# POP:FAMILY
gmm2 <-  glmer(dead_2020 ~ City_dist + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
  family = binomial(link = "logit"),
  nAGQ = 0,
  data = survival_2020)


# UNIQUE FAMILIES
survival_2020$Family_unique <- paste(survival_2020$Population, survival_2020$Family)
gmm3 <-  glmer(dead_2020 ~ City_dist + (1|Family_unique),
  family = binomial(link = "logit"),
  nAGQ = 0,
  data = survival_2020)


# EQUIVALENT TO FAM NESTED W/IN POP
gmm4 <-  glmer(dead_2020 ~ City_dist + (1|Population:Family) + (1|Population),
  family = binomial(link = "logit"),
  nAGQ = 0,
  data = survival_2020)



# REDUCED MODEL
gmmDG1 <- glm(dead_2020 ~ City_dist,
  family = binomial(link = "logit"),
  data = survival_2020)

### RESULTS ###
# POPULATION (so, results are about populations)
pbgmmDg1 <- pbnm(gmm,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
pbgmmDg1  %>%
  summary() %>%
  print()   # p = 0.063  ... MARG SIG- questionable var among pops

# EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
pbgmmDg4 <- pbnm(gmm4,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
ranova_pop <- summary(pbgmmDg4) %T>%
  print() # p =  0.098  ... MARG SIG- questionable var among pops accounting for fams

# POP:FAMILY (so, results are about families)- accounts for fams being in same pop
pbgmmDg2 <- pbnm(gmm2,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
ranova_fam <- summary(pbgmmDg2) %T>%
  print() # p = 0.237  ... little var among families crossed w/ pops

# UNIQUE FAMILIES (so, results are about families)
pbgmmDg3 <- pbnm(gmm3,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835)
pbgmmDg3 %>%
  summary() %>%
  print() # p = 0.237  ... little var among families, period



##### use anova to test significance of terms (this isn't what we want, though): #####
## test Pop/Fam
anova(gmm1, gmmDG1) # p =  0.51

## test Pop/Fam but expanded
anova(gmm4, gmmDG1) # p =   0.51    # SAME AS ABOVE

## test Pop
anova(gmm, gmmDG1) # p =  0.2462

## test Fam
anova(gmm3, gmmDG1) # p =   0.7278

## test pop:fam
anova(gmm2, gmmDG1) # p =  0.7278    # SAME AS ABOVE



#--------- FINAL RESULTS: ----------#
# Bootstrapping:
# - Pop:    MARGINALLY SIGNIFICANT
# - Family: NOT SIGNIFICANT
# anova:
# - Pop:    NOT SIGNIFICANT
# - Family: NOT SIGNIFICANT

# --- DO THE 2 METHODS MATCH? ---#
#       [...]    Mostly
#             



##### old code #####

sum.1 <- summary(gmm4)

variances1 <- print(VarCorr(gmm4),comp="Variance") %>%
  as.data.frame() %>%
  dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
  dplyr::select(., c(grp, vcov, PVE)) %>%
  dplyr::rename(., Group = grp,
                Variance = vcov)

# export percent variance explained
write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Survival_glmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)

# export ranova
sink(here::here("./Figures_Tables/ranova_PVE/2020_Survival_glmer_ranova.csv"))
print("POPULATION", sep="\n\n")
print(ranova_pop, sep="\n\n")
  cat("\n")
print("FAMILY", sep="\n\n")
print(ranova_fam, sep="\n\n")
  cat("\n")
if (ranova_pop[1] <= 0.05){
  print ('There is variance among populations')}
if (ranova_pop[1] > 0.05){
  print ("There is not much variance among populations") }
if (ranova_fam[1] <= 0.05){
  print ("There is variance among families")}
if (ranova_fam[1] > 0.05){
  print ("There is not much variance among families") }
sink()

```

#### Urb_score
```{r}
car::Anova(surv20_gr_usc_m1) # not sig
```


### Urban subtransects: *Nothing sig for either
#### City_dist
```{r}
car::Anova(surv20_urbsubs_city_m1) # not sig
car::Anova(surv20_urbsubs_city_m1_ME) # not sig
AIC(surv20_urbsubs_city_m1, surv20_urbsubs_city_m1_ME)
# AIC <2 apart; both "best models" though just main effects lower AIC
```

#### Urb_score
```{r}
car::Anova(surv20_urbsubs_usc_m1) # not sig
car::Anova(surv20_urbsubs_usc_m1_ME) # not sig
AIC(surv20_urbsubs_usc_m1, surv20_urbsubs_usc_m1_ME)
# AIC <2 apart; both "best models" though just main effects lower AIC
```

### Export ANOVA
```{r}
anova_table_flx(surv20_gr_city_m1)
anova_table_flx(surv20_gr_usc_m1)
anova_table_flx(surv20_urbsubs_city_m1)
anova_table_flx(surv20_urbsubs_city_m1_ME)
anova_table_flx(surv20_urbsubs_usc_m1)
anova_table_flx(surv20_urbsubs_usc_m1_ME)

AIC_compare.city_dist(surv20_urbsubs_city_m1,
                      surv20_urbsubs_city_m1_ME)
    
AIC_compare.urb_score(surv20_urbsubs_usc_m1,
                      surv20_urbsubs_usc_m1_ME) 

# list of models
# model_list <- append(model_list,
# 
# list(
# 
# surv20_gr_city_m1,
# surv20_gr_usc_m1,
# surv20_urbsubs_city_m1,
# surv20_urbsubs_city_m1_ME,
# surv20_urbsubs_usc_m1,
# surv20_urbsubs_usc_m1_ME
#   
# ))
```


## Export all models & model formulas as a key
```{r}
# list of all models-----
model_list <- list(
  
  flowering_gr_city_m1, # flowering success models
flowering_gr_urb_m1,
flowering_urbsubs_city_m1,
flowering_urbsubs_city_m1_ME,
flowering_urbsubs_usc_m1,
flowering_urbsubs_usc_m1_ME,
  
  Height_Jun20_gr_city_m5, # June height models
Height_Jun20_gr_usc_m2,
Height_Jun20_urbsubs_city_m2,
Height_Jun20_urbsubs_city_m2_ME,
Height_Jun20_urbsubs_usc_m2,
Height_Jun20_urbsubs_usc_m2_ME,
  
    Height_Sept20_gr_city_m2, # Sept height models
Height_Sept20_gr_usc_m5,
Height_Sept20_urbsubs_city_m5,
Height_Sept20_urbsubs_city_m5_ME,
Height_Sept20_urbsubs_usc_m2,
Height_Sept20_urbsubs_usc_m2_ME,
  
    weev_stn_gr_city_m3, # weevil damage (standardized) models
weev_stn_gr_city_m11,
weev_stn_gr_usc_m3,
weev_stn_gr_usc_m12,
weev_stn_urbsubs_city_m4,
weev_stn_urbsubs_city_m4_ME,
weev_stn_urbsubs_city_m11,
weev_stn_urbsubs_city_m11_ME.2,
weev_stn_urbsubs_usc_m4,
weev_stn_urbsubs_usc_m4_ME,
weev_stn_usc_usc_m10,
weev_stn_usc_usc_m10_ME.2,
  
    weev_gr_city_m3, # weevil damage models
weev_gr_city_m11,
weev_gr_usc_m3,
weev_gr_usc_m10,
weev_urbsubs_city_m4,
weev_urbsubs_city_m4_ME, 
weev_urbsubs_city_m11,
weev_urbsubs_city_m11_ME,
weev_urbsubs_usc_m4,
weev_urbsubs_usc_m4_ME,
weev_urbsubs_usc_m11,
weev_urbsubs_usc_m11_ME,
  
  herb2020_gr_dist_m5, # July herbivory models
herb2020_gr_dist_m8,
herb2020_gr_usc_m5,
herb2020_gr_usc_m8,
herb2020_urb_dist_m5,
herb2020_urb_dist_m5_ME,
herb2020_urb_dist_m8,
herb2020_urb_dist_m8_ME,
herb2020_urb_usc_m5,
herb2020_urb_usc_m5_ME,
herb2020_urb_usc_m8,
herb2020_urb_usc_m8_ME,
  
  herb2020.S_gr_dist_m5, # Sept herbivory models
herb2020.S_gr_dist_m12,
herb2020.S_gr_usc_m5,
herb2020.S_gr_usc_m12,
herb2020.S_urb_dist_m5,
herb2020.S_urb_dist_m5_ME,
herb2020.S_urb_dist_m12,
herb2020.S_urb_dist_m12_ME,
herb2020.S_urb_usc_m5,
herb2020.S_urb_usc_m5_ME,
herb2020.S_urb_usc_m12,
herb2020.S_urb_usc_m12_ME,

  rgr_gr_city_m6, # relative growth rate models
rgr_gr_city_m8,
rgr_gr_usc_m6,
rgr_gr_usc_m8,
rgr_urbsubs_city_m5,
rgr_urbsubs_city_m5_ME,
rgr_urbsubs_city_m8,
rgr_urbsubs_city_m8_ME.1,
rgr_urbsubs_usc_m5,
rgr_urbsubs_usc_m5_ME,
rgr_urbsubs_usc_m8,
rgr_urbsubs_usc_m8_ME.1,
  
  rametsJ_gr_city_m2, # June ramets models
rametsJ_gr_usc_m2,
rametsJ_urbsubs_city_m1,
rametsJ_urbsubs_city_m1_ME,
rametsJ_urbsubs_urbsubs_m7,
rametsJ_urbsubs_urbsubs_m7_ME,
  
  rametsS_gr_city_m5, # Sept ramets models
rametsS_gr_usc_m5,
rametsS_urbsubs_city_m5,
rametsS_urbsubs_city_m5_ME,
rametsS_urbsubs_usc_m5,
rametsS_urbsubs_usc_m5_ME,

  surv20_gr_city_m1, # survival models
surv20_gr_usc_m1,
surv20_urbsubs_city_m1,
surv20_urbsubs_city_m1_ME,
surv20_urbsubs_usc_m1,
surv20_urbsubs_usc_m1_ME
  
)

# list of all models, in quotes-----
all_models_2020 <- qq(
  flowering_gr_city_m1, # flowering success models
flowering_gr_urb_m1,
flowering_urbsubs_city_m1,
flowering_urbsubs_city_m1_ME,
flowering_urbsubs_usc_m1,
flowering_urbsubs_usc_m1_ME,
  
  Height_Jun20_gr_city_m5, # June height models
Height_Jun20_gr_usc_m2,
Height_Jun20_urbsubs_city_m2,
Height_Jun20_urbsubs_city_m2_ME,
Height_Jun20_urbsubs_usc_m2,
Height_Jun20_urbsubs_usc_m2_ME,
  
    Height_Sept20_gr_city_m2, # Sept height models
Height_Sept20_gr_usc_m5,
Height_Sept20_urbsubs_city_m5,
Height_Sept20_urbsubs_city_m5_ME,
Height_Sept20_urbsubs_usc_m2,
Height_Sept20_urbsubs_usc_m2_ME,
  
    weev_stn_gr_city_m3, # weevil damage (standardized) models
weev_stn_gr_city_m11,
weev_stn_gr_usc_m3,
weev_stn_gr_usc_m12,
weev_stn_urbsubs_city_m4,
weev_stn_urbsubs_city_m4_ME,
weev_stn_urbsubs_city_m11,
weev_stn_urbsubs_city_m11_ME.2,
weev_stn_urbsubs_usc_m4,
weev_stn_urbsubs_usc_m4_ME,
weev_stn_usc_usc_m10,
weev_stn_usc_usc_m10_ME.2,
  
    weev_gr_city_m3, # weevil damage models
weev_gr_city_m11,
weev_gr_usc_m3,
weev_gr_usc_m10,
weev_urbsubs_city_m4,
weev_urbsubs_city_m4_ME, 
weev_urbsubs_city_m11,
weev_urbsubs_city_m11_ME,
weev_urbsubs_usc_m4,
weev_urbsubs_usc_m4_ME,
weev_urbsubs_usc_m11,
weev_urbsubs_usc_m11_ME,
  
  herb2020_gr_dist_m5, # July herbivory models
herb2020_gr_dist_m8,
herb2020_gr_usc_m5,
herb2020_gr_usc_m8,
herb2020_urb_dist_m5,
herb2020_urb_dist_m5_ME,
herb2020_urb_dist_m8,
herb2020_urb_dist_m8_ME,
herb2020_urb_usc_m5,
herb2020_urb_usc_m5_ME,
herb2020_urb_usc_m8,
herb2020_urb_usc_m8_ME,
  
  herb2020.S_gr_dist_m5, # Sept herbivory models
herb2020.S_gr_dist_m12,
herb2020.S_gr_usc_m5,
herb2020.S_gr_usc_m12,
herb2020.S_urb_dist_m5,
herb2020.S_urb_dist_m5_ME,
herb2020.S_urb_dist_m12,
herb2020.S_urb_dist_m12_ME,
herb2020.S_urb_usc_m5,
herb2020.S_urb_usc_m5_ME,
herb2020.S_urb_usc_m12,
herb2020.S_urb_usc_m12_ME,

  rgr_gr_city_m6, # relative growth rate models
rgr_gr_city_m8,
rgr_gr_usc_m6,
rgr_gr_usc_m8,
rgr_urbsubs_city_m5,
rgr_urbsubs_city_m5_ME,
rgr_urbsubs_city_m8,
rgr_urbsubs_city_m8_ME.1,
rgr_urbsubs_usc_m5,
rgr_urbsubs_usc_m5_ME,
rgr_urbsubs_usc_m8,
rgr_urbsubs_usc_m8_ME.1,
  
  rametsJ_gr_city_m2, # June ramets models
rametsJ_gr_usc_m2,
rametsJ_urbsubs_city_m1,
rametsJ_urbsubs_city_m1_ME,
rametsJ_urbsubs_urbsubs_m7,
rametsJ_urbsubs_urbsubs_m7_ME,
  
  rametsS_gr_city_m5, # Sept ramets models
rametsS_gr_usc_m5,
rametsS_urbsubs_city_m5,
rametsS_urbsubs_city_m5_ME,
rametsS_urbsubs_usc_m5,
rametsS_urbsubs_usc_m5_ME,

  surv20_gr_city_m1, # survival models
surv20_gr_usc_m1,
surv20_urbsubs_city_m1,
surv20_urbsubs_city_m1_ME,
surv20_urbsubs_usc_m1,
surv20_urbsubs_usc_m1_ME)


# get model formulas --> export -----
all_models_2020_formulas <- lapply(model_list, formula) %>%
  lapply(., toString) %>%
  as.character()

# get df with model name and formula
modsum_1 <- data.frame(Model_Name1 = all_models_2020, 
       Formula = all_models_2020_formulas)
       # sapply(list1, r.squaredGLMM()[1]))

# get df with model family and formula 
modsum_2 <- tibble(Model_Name1 = all_models_2020,
                   col2 = lapply(model_list, family),
               Family = sub("\\,.*", "", col2)) %>%
   dplyr::select(-col2) %>%
  mutate(Family = str_remove(Family, "list"))
 
# modsum_2 <- tibble(lapply(list1, family)) %>%
#   t() %>%
#   as.data.frame() %>%
#   dplyr::select(., c(V7, V15)) %>%
#   unlist() %>%
#     as.data.frame()




# merge the two dfs
modsum_merge2 <- inner_join(modsum_1, modsum_2, by = "Model_Name1") %>%
  write.csv(here::here("./Figures_Tables/ANOVA_tables_images/Model_List.csv"))

# Get R-sq values here
capture.output(lapply(model_list, r.squaredGLMM), file = here::here("./Figures_Tables/ANOVA_tables_images/Model_R_squared_values.csv"))


# library(jtools)
# export_summs(model_list, digits = 3, to.file = "xlsx", file.name = here::here("./Figures_Tables/ANOVA_tables_images/R_sq_2020.xlsx"))

```

# Statistics: 2019-2020 (seems better to do per year)
## Heights
### Mid June height
#### lmer: diagnostics
```{r}
# Gradient / city_dist----------
height_gr_dist_m1 <- lmer(Total_Height_midJune ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height_gr_dist_m1, type='diag')
# looks like there's some heteroskedasticity and it's right-skewed... try sqrt transformation


height_gr_dist_m2 <- lmer(sqrt(Total_Height_midJune) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height_gr_dist_m2, type='diag')
# much better!



# Gradient / urb_score----------
height_gr_usc_m1 <- lmer(Total_Height_midJune ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score ,
  data = heights_19_20, REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height_gr_usc_m1, type='diag')
# looks like there's some heteroskedasticity and it's right-skewed... try sqrt transformation

height_gr_usc_m2 <- lmer(sqrt(Total_Height_midJune) ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score ,
  data = heights_19_20, REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height_gr_usc_m2, type='diag')
# much better!



# Urb sites / city_dist----------
height_urb_dist_m1 <- lmer(Total_Height_midJune  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height_urb_dist_m1, type='diag')
# looks like there's some heteroskedasticity and it's right-skewed... try sqrt transformation

height_urb_dist_m2 <- lmer(sqrt(Total_Height_midJune)  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height_urb_dist_m2, type='diag')
# much better!

# main effects:
height_urb_dist_m2_ME <- lmer(sqrt(Total_Height_midJune)  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist + Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))





# Urb sites / urb_score----------
height_urb_usc_m1 <- lmer(Total_Height_midJune  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height_urb_usc_m1, type='diag')
# looks like there's some heteroskedasticity and it's right-skewed... try sqrt transformation

height_urb_usc_m2 <- lmer(sqrt(Total_Height_midJune)  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height_urb_usc_m2, type='diag')
# much better!


# main effects:
height_urb_usc_m2_ME <- lmer(sqrt(Total_Height_midJune)  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score + Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
```

#### Entire gradient: *dist & urb score not sig
##### City_dist
```{r}
car::Anova(height_gr_dist_m2)
# dist not significant

r.squaredGLMM(height_gr_dist_m2)
```

##### Urb_score
```{r}
car::Anova(height_gr_usc_m2)
# dist not significant

r.squaredGLMM(height_gr_usc_m2)
```

#### Urban subtransects: *transect sig for both
##### City_dist
```{r}
car::Anova(height_urb_dist_m2)
# dist not significant but transect ID is!

r.squaredGLMM(height_urb_dist_m2)


# just main effects
car::Anova(height_urb_dist_m2_ME)
# transect sig

r.squaredGLMM(height_urb_dist_m2_ME)

AIC((height_urb_dist_m2),
    (height_urb_dist_m2_ME)) # better but <2 AIC from full model
```

##### Urb_score
```{r}
car::Anova(height_urb_usc_m2)
# urb score not significant but transect ID is!

r.squaredGLMM(height_urb_usc_m2)


# just main effects
car::Anova(height_urb_usc_m2_ME)
# transect sig

r.squaredGLMM(height_urb_usc_m2_ME)

AIC((height_urb_usc_m2),
    (height_urb_usc_m2_ME)) # better but <2 AIC from full model
```


### Sept height- nothing sig. Look at yearly data
#### lmer: diagnostics
```{r}
# Gradient / city_dist----------
height2_gr_dist_m1 <- lmer(Total_Height_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height2_gr_dist_m1, type='diag')
# looks like there's some heteroskedasticity and it's right-skewed... try sqrt transformation


height2_gr_dist_m2 <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height2_gr_dist_m2, type='diag')
# much better though still not good enough... two distinct clusters... try cube root

height2_gr_dist_m3 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height2_gr_dist_m3, type='diag')
# didn't help much... maybe this data isn't normal? is it bimodal?

hist(heights_19_20$Total_Height_Sept, breaks = 40)


# what do diagnostic plots look like for just 2020 data? (sqrt)
sjPlot::plot_model(lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2020,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))), type='diag')
# looks pretty good... and 2019 data?

sjPlot::plot_model(lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))), type='diag')
# better but still bimodal... take out zeros then do binomial- were plants alive (have heights > 0?), then look at quantitative measurements



# TAKING OUT PLANTS W/ZERO HEIGHT & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

# recode plants as having height or not
heights_19_20$Total_Height_Sept_binary <- heights_19_20$Total_Height_Sept
heights_19_20$Total_Height_Sept_binary[heights_19_20$Total_Height_Sept_binary > 0] <- 1

height2_gr_dist_m4 <- glmer((Total_Height_Sept_binary) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  family = "binomial"(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(height2_gr_dist_m4)
plot(res)
# looks great!
summary(height2_gr_dist_m4)

car::Anova(height2_gr_dist_m4) # not sig



height2_gr_dist_m5 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1),
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_gr_dist_m5, type='diag')
# looks ok... still heavy tails and two distinct clumps... does this go away when I separate the years?

# 2019
height2_gr_dist_m5.2019 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1 & Year == 2019),
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_gr_dist_m5.2019, type='diag')
# looks pretty good- one clump instead of two...

# 2020
height2_gr_dist_m5.2020 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1 & Year == 2020),
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_gr_dist_m5.2020, type='diag')
# again, looks pretty good- one clump instead of two...

car::Anova(height2_gr_dist_m5) # not sig
car::Anova(height2_gr_dist_m5.2019) # not sig
car::Anova(height2_gr_dist_m5.2020) # not sig


# look at correlation of height btwn years
heights_19_20_joined <- join(heights_2019[, c(1:6, 18)], heights_2020[,c(1:6, 12)], by = c("Row", "Column", "Population", "Block", "Replicate"))
heights_19_20_joined <- heights_19_20_joined[, -8]
colnames(heights_19_20_joined)[7] <- "Total_Height_Sept_2019"
colnames(heights_19_20_joined)[8] <- "Total_Height_Sept_2020"

ggplot(heights_19_20_joined, aes(x = Total_Height_Sept_2019, y = Total_Height_Sept_2020)) +
  geom_point() +
  geom_smooth(method = lm) +
  ggtitle("R-squared: ", summary(corr_heights_m1)$r.squared)

corr_heights_m1 <- lm(Total_Height_Sept_2019 ~ Total_Height_Sept_2020, heights_19_20_joined)
summary(corr_heights_m1)






# Gradient / urb_score----------
height2_gr_usc_m1 <- lmer(Total_Height_Sept ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score ,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_gr_usc_m1, type='diag')
# looks like there's some heteroskedasticity and it's right-skewed... try sqrt transformation

height2_gr_usc_m2 <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score ,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_gr_usc_m2, type='diag')
# same issues as above...


# TAKING OUT PLANTS W/ZERO HEIGHT & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

height2_gr_usc_m3 <- glmer((Total_Height_Sept_binary) ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
  data = heights_19_20,
  family = "binomial"(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(height2_gr_usc_m3)
plot(res)
# looks great!
summary(height2_gr_usc_m3)

car::Anova(height2_gr_usc_m3) # not sig



height2_gr_usc_m4 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_gr_usc_m4, type='diag')
# looks ok... still heavy tails and two distinct clumps... does this go away when I separate the years?

# 2019
height2_gr_usc_m4.2019 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1 & Year == 2019),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_gr_usc_m4.2019, type='diag')
# looks pretty good- one clump instead of two...

# 2020
height2_gr_usc_m4.2020 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1 & Year == 2020),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_gr_usc_m4.2020, type='diag')
# again, looks pretty good- one clump instead of two...

car::Anova(height2_gr_usc_m4) # not sig
car::Anova(height2_gr_usc_m4.2019) # not sig
car::Anova(height2_gr_usc_m4.2020) # not sig









# Urb sites / city_dist----------
height2_urb_dist_m1 <- lmer(Total_Height_Sept  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height2_urb_dist_m1, type='diag')
# looks like there's some heteroskedasticity and it's right-skewed... try sqrt transformation

height2_urb_dist_m2 <- lmer(sqrt(Total_Height_Sept)  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height2_urb_dist_m2, type='diag')
# same issues as above



# TAKING OUT PLANTS W/ZERO HEIGHT & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

height2_urb_dist_m3 <- glmer((Total_Height_Sept_binary) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
  data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(height2_urb_dist_m3)
plot(res)
# looks great!
summary(height2_urb_dist_m3)

car::Anova(height2_urb_dist_m3) # not sig



height2_urb_dist_m4 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_urb_dist_m4, type='diag')
# looks ok... still heavy tails and two distinct clumps... does this go away when I separate the years?

# 2019
height2_urb_dist_m4.2019 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1 & Year == 2019),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_urb_dist_m4.2019, type='diag')
# looks pretty good- one clump instead of two...

# 2020
height2_urb_dist_m4.2020 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1 & Year == 2020),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_urb_dist_m4.2020, type='diag')
# again, looks pretty good- one clump instead of two...

car::Anova(height2_urb_dist_m4) # city_dist MARGINALLY sig
car::Anova(height2_urb_dist_m4.2019) # not sig
car::Anova(height2_urb_dist_m4.2020) # not sig





# Urb sites / urb_score----------
height2_urb_usc_m1 <- lmer(Total_Height_Sept  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height2_urb_usc_m1, type='diag')
# looks like there's some heteroskedasticity and it's right-skewed... try sqrt transformation

height2_urb_usc_m2 <- lmer(sqrt(Total_Height_Sept)  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height2_urb_usc_m2, type='diag')
# same issues as above


# TAKING OUT PLANTS W/ZERO HEIGHT & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

height2_urb_usc_m3 <- glmer((Total_Height_Sept_binary) ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
  data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(height2_urb_usc_m3)
plot(res)
# looks great!
summary(height2_urb_usc_m3)

car::Anova(height2_urb_usc_m3) # not sig



height2_urb_usc_m4 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_urb_usc_m4, type='diag')
# looks ok... still heavy tails and two distinct clumps... does this go away when I separate the years?

# 2019
height2_urb_usc_m4.2019 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1 & Year == 2019),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_urb_usc_m4.2019, type='diag')
# looks pretty good- one clump instead of two...

# 2020
height2_urb_usc_m4.2020 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1 & Year == 2020),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_urb_usc_m4.2020, type='diag')
# again, looks pretty good- one clump instead of two...

car::Anova(height2_urb_usc_m4) # not sig
car::Anova(height2_urb_usc_m4.2019) # not sig
car::Anova(height2_urb_usc_m4.2020) # not sig


```
## Relative Growth Rate
### Mid-June through Sept
#### lmer: diagnostics
```{r}
# Gradient / city_dist----------
rgr_gr_dist_m1 <- lmer(rel_growth_rate ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_gr_dist_m1, type='diag')
# two clear clusters and tails


rgr_gr_dist_m2 <- lmer(sqrt(rel_growth_rate) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_gr_dist_m2, type='diag')
# much better!




# Gradient / urb_score----------
rgr_gr_usc_m1 <- lmer(rel_growth_rate ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score ,
  data = heights_19_20, REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(rgr_gr_usc_m1, type='diag')
# two clear clusters and tails


rgr_gr_usc_m2 <- lmer(sqrt(rel_growth_rate) ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score ,
  data = heights_19_20, REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(rgr_gr_usc_m2, type='diag')
# much better!



# Urb sites / city_dist----------
rgr_urb_dist_m1 <- lmer(rel_growth_rate  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_urb_dist_m1, type='diag')
# two clear clusters and tails

rgr_urb_dist_m2 <- lmer(sqrt(rel_growth_rate)  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_urb_dist_m2, type='diag')
# much better! still have some tails but this is the best model.


rgr_urb_dist_m3 <- lmer((rel_growth_rate)^(1/3)  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_urb_dist_m3, type='diag')
# too much

rgr_urb_dist_m4 <- lmer(log(rel_growth_rate + 1)  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_urb_dist_m4, type='diag')
# too much

hist(heights_19_20$rel_growth_rate)


# main effects:
rgr_urb_dist_m2_ME <- lmer(sqrt(rel_growth_rate)  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist + Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))





# Urb sites / urb_score----------
rgr_urb_usc_m1 <- lmer(rel_growth_rate  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_urb_usc_m1, type='diag')
# two clumps and left skew

rgr_urb_usc_m2 <- lmer(sqrt(rel_growth_rate)  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_urb_usc_m2, type='diag')
# much better! still tails though


rgr_urb_usc_m3 <- lmer((rel_growth_rate)^(1/3)  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_urb_usc_m3, type='diag')
# too much

# main effects:
rgr_urb_usc_m2_ME <- lmer(sqrt(rel_growth_rate)  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score + Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
```

#### Entire gradient: *Nothing sig
##### City_dist
```{r}
car::Anova(rgr_gr_dist_m2)
# dist not significant

r.squaredGLMM(rgr_gr_dist_m2)

```

##### Urb_score
```{r}
car::Anova(rgr_gr_usc_m2)
# dist not significant

r.squaredGLMM(rgr_gr_usc_m2)

```

#### Urban subtransects: *nothing sig
##### City_dist
```{r}
car::Anova(rgr_urb_dist_m2)
# nothing sig

r.squaredGLMM(rgr_urb_dist_m2)


# just main effects
car::Anova(rgr_urb_dist_m2_ME)
#  nothing sig

r.squaredGLMM(rgr_urb_dist_m2_ME)

AIC((rgr_urb_dist_m2),
    (rgr_urb_dist_m2_ME)) # better but <2 AIC from full model
```

##### Urb_score
```{r}
car::Anova(rgr_urb_usc_m2)
# nothing sig

r.squaredGLMM(rgr_urb_usc_m2)


# just main effects
car::Anova(rgr_urb_usc_m2_ME)
#  nothing sig

r.squaredGLMM(rgr_urb_usc_m2_ME)

AIC((rgr_urb_usc_m2),
    (rgr_urb_usc_m2_ME)) # better model
```


## No. Ramets- nothing sig
### Mid June ramets
#### glmer: diagnostics
```{r}
# Gradient / city_dist----------
ramets_gr_dist_m1 <- glmer(Ramets_midJune ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(ramets_gr_dist_m1)
plot(res)
testOutliers(ramets_gr_dist_m1)
# looks good.




# Gradient / urb_score----------
ramets_gr_usc_m1 <- glmer(Ramets_midJune ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
  data = heights_19_20,
  family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(ramets_gr_usc_m1)
plot(res)
testOutliers(ramets_gr_usc_m1)
# looks good.



# Urb sites / city_dist----------
ramets_urb_dist_m1 <- glmer(Ramets_midJune ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
    data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(ramets_urb_dist_m1)
plot(res)
# looks good.


# main effects:
ramets_urb_dist_m2_ME <- glmer(Ramets_midJune ~ (1|Block) + (1|Year) + (1|Population/Family) +  City_dist + Transect_ID,
    data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))




# Urb sites / urb_score----------
ramets_urb_usc_m1 <- glmer(Ramets_midJune ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
    data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(ramets_urb_usc_m1)
plot(res)
testOutliers(ramets_urb_usc_m1)
# looks good.


# main effects:
ramets_urb_usc_m2_ME <- glmer(Ramets_midJune ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score + Transect_ID,
    data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
```

#### Entire gradient: *NOT sig for city_dist or urb_score
##### City_dist
```{r}
car::Anova(ramets_gr_dist_m1)
# dist not significant

r.squaredGLMM(ramets_gr_dist_m1)
```

##### Urb_score
```{r}
car::Anova(ramets_gr_usc_m1)
# dist not significant

r.squaredGLMM(ramets_gr_usc_m1)

```

#### Urban subtransects: nothing sig
##### City_dist
```{r}
car::Anova(ramets_urb_dist_m1)
# nothing sig

r.squaredGLMM(ramets_urb_dist_m1)


# just main effects
car::Anova(ramets_urb_dist_m2_ME)
# nothing sig

r.squaredGLMM(ramets_urb_dist_m2_ME)

AIC((ramets_urb_dist_m1),
    (ramets_urb_dist_m2_ME)) # better but <2 AIC from full model
```

##### Urb_score
```{r}
car::Anova(ramets_urb_usc_m1)
# nothing sig

r.squaredGLMM(ramets_urb_usc_m1)


# just main effects
car::Anova(ramets_urb_usc_m2_ME)
# nothing sig

r.squaredGLMM(ramets_urb_usc_m2_ME)

AIC((ramets_urb_usc_m1),
    (ramets_urb_usc_m2_ME)) # better but <2 AIC from full model
```


### Sept ramets
#### glmer: diagnostics
```{r}
# Gradient / city_dist----------
ramets2_gr_dist_m1 <- glmer(Ramets_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(ramets2_gr_dist_m1)
plot(res)
# looks good.




# Gradient / urb_score----------
ramets2_gr_usc_m1 <- glmer(Ramets_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
  data = heights_19_20,
  family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(ramets2_gr_usc_m1)
plot(res)
# looks good though try negative binomial to see if that'll satisfy KS test

ramets2_gr_usc_m2 <- glmmTMB(Ramets_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
  data = heights_19_20,
  family = nbinom1(),
  REML = F)
res <- simulateResiduals(ramets2_gr_usc_m2)
plot(res)
# model convergence problem... using poisson (though it doesn't make a difference... see anovas below)
car::Anova(ramets2_gr_usc_m1)
car::Anova(ramets2_gr_usc_m2)


# Urb sites / city_dist----------
ramets2_urb_dist_m1 <- glmer(Ramets_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
    data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(ramets2_urb_dist_m1)
plot(res)
# looks good.


# main effects:
ramets2_urb_dist_m2_ME <- glmer(Ramets_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) +  City_dist + Transect_ID,
    data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))




# Urb sites / urb_score----------
ramets2_urb_usc_m1 <- glmer(Ramets_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
    data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(ramets2_urb_usc_m1)
plot(res)
# looks good.


# main effects:
ramets2_urb_usc_m2_ME <- glmer(Ramets_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score + Transect_ID,
    data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
```

#### Entire gradient: *NOT sig for city_dist or urb_score
##### City_dist
```{r}
car::Anova(ramets2_gr_dist_m1)
# dist not significant

r.squaredGLMM(ramets2_gr_dist_m1)
```

##### Urb_score
```{r}
car::Anova(ramets2_gr_usc_m1)
# dist not significant

r.squaredGLMM(ramets2_gr_usc_m1)

```

#### Urban subtransects: nothing sig
##### City_dist
```{r}
car::Anova(ramets2_urb_dist_m1)
# nothing sig

r.squaredGLMM(ramets2_urb_dist_m1)


# just main effects
car::Anova(ramets2_urb_dist_m2_ME)
# nothing sig

r.squaredGLMM(ramets2_urb_dist_m2_ME)

AIC((ramets2_urb_dist_m1),
    (ramets2_urb_dist_m2_ME)) # better but <2 AIC from full model
```

##### Urb_score
```{r}
car::Anova(ramets2_urb_usc_m1)
# nothing sig

r.squaredGLMM(ramets2_urb_usc_m1)


# just main effects
car::Anova(ramets2_urb_usc_m2_ME)
# nothing sig

r.squaredGLMM(ramets2_urb_usc_m2_ME)

AIC((ramets2_urb_usc_m1),
    (ramets2_urb_usc_m2_ME)) # better but <2 AIC from full model
```

## Herbivory- DON'T USE THIS- LOOKING AT YEARLY DATA. MODELS NOT MEETING ASSUMPTIONS WELL AND YEARS HAVE PRETTY DIFFERENT DATA.
### Sept
#### glmer: diagnostics
```{r}
# Gradient / city_dist----------
herbivory_gr_dist_m1 <- glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = herbivory_19_20,
  family = "binomial"(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herbivory_gr_dist_m1)
plot(res)
testDispersion(herbivory_gr_dist_m1)
# qqplot looks very off... try  ????
hist(herbivory_19_20$Herbivory_mean_Sept, breaks = 30)
summary(herbivory_gr_dist_m1)


herbivory_gr_dist_m2 <- glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Family) + City_dist,
  data = herbivory_19_20,
  family = "binomial"(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
res <- simulateResiduals(herbivory_gr_dist_m2)
plot(res)

# try removing pop and making families unique
herbivory_19_20[,"FamPop"] <- paste0(herbivory_19_20$Family, "-", herbivory_19_20$Population)

herbivory_gr_dist_m3 <- glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + City_dist,
  data = herbivory_19_20,
  family = "binomial"(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

summary(herbivory_gr_dist_m3)
# trying to find where all the variance is being eaten up/accounted for and still not finding it... try beta distribution


herbivory_gr_dist_m4 <- glmmTMB(Herbivory_mean_Sept  ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = herbivory_19_20,
  family = beta_family(link="logit"))
# Error in eval(family$initialize) : y values must be 0 < y < 1
# recode: 0s as 0.00001 & 1 as 0.999999

herbivory_19_20_recode <- herbivory_19_20
herbivory_19_20_recode$Herbivory_mean_Sept[herbivory_19_20_recode$Herbivory_mean_Sept == 1] <- 0.999999
herbivory_19_20_recode$Herbivory_mean_Sept[herbivory_19_20_recode$Herbivory_mean_Sept == 0] <- 0.000001



herbivory_gr_dist_m5 <- glmmTMB(Herbivory_mean_Sept  ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = herbivory_19_20_recode,
  family = beta_family(link="logit"))
res <- simulateResiduals(herbivory_gr_dist_m5)
plot(res)
# IT WORKS

hist(herbivory_19_20$Herbivory_mean_Sept, breaks = 30)
summary(herbivory_gr_dist_m5)


herbivory_gr_dist_m6 <- glmmTMB(Herbivory_mean_Sept  ~ (1|Block) + Year + (1|Population/Family) + City_dist,
  data = herbivory_19_20_recode,
  family = beta_family(link="logit"))
res <- simulateResiduals(herbivory_gr_dist_m6)
plot(res)

herbivory_gr_dist_m7 <- glmmTMB(Herbivory_mean_Sept  ~ (1|Block) + Year + (1|FamPop) + City_dist,
  data = herbivory_19_20_recode,
  family = beta_family(link="logit"))
res <- simulateResiduals(herbivory_gr_dist_m7)
plot(res)

herbivory_gr_dist_m8 <- glmmTMB(Herbivory_mean_Sept  ~  Year + (1|FamPop) + City_dist,
  data = herbivory_19_20_recode,
  family = beta_family(link="logit"))
res <- simulateResiduals(herbivory_gr_dist_m8)
plot(res)

car::Anova(herbivory_gr_dist_m7) # doesn't run
car::Anova(herbivory_gr_dist_m8)



# Gradient / urb_score----------
herbivory_gr_usc_m1 <- glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
  data = herbivory_19_20,
  family = binomial,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herbivory_gr_usc_m1)
plot(res)
# try beta

herbivory_gr_usc_m2 <- glmmTMB(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
  data = herbivory_19_20_recode,
  family = beta_family(link="logit"))

res <- simulateResiduals(herbivory_gr_usc_m2)
plot(res)


# Urb sites / city_dist----------
herbivory_urb_dist_m1 <- glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
    data = herbivory_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = binomial,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herbivory_urb_dist_m1)
plot(res)
# try beta

herbivory_urb_dist_m2 <- glmmTMB(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
  data = herbivory_19_20_recode %>% dplyr::filter(., Transect_ID != "Rural"),
  family = beta_family(link="logit"))

res <- simulateResiduals(herbivory_urb_dist_m2)
plot(res)


# main effects:
herbivory_urb_dist_m2_ME <- herbivory_urb_dist_m2 <- glmmTMB(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist + Transect_ID,
  data = herbivory_19_20_recode %>% dplyr::filter(., Transect_ID != "Rural"),
  family = beta_family(link="logit"))




# Urb sites / urb_score----------
herbivory_urb_usc_m1 <- glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
    data = herbivory_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = binomial,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herbivory_urb_usc_m1)
plot(res)
# try beta

herbivory_urb_usc_m2 <- glmmTMB(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
  data = herbivory_19_20_recode %>% dplyr::filter(., Transect_ID != "Rural"),
  family = beta_family(link="logit"))

res <- simulateResiduals(herbivory_urb_usc_m2)
plot(res)


# # main effects:
herbivory_urb_usc_m2_ME <- glmmTMB(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score + Transect_ID,
  data = herbivory_19_20_recode %>% dplyr::filter(., Transect_ID != "Rural"),
  family = beta_family(link="logit"))
```

#### Entire gradient: *NOT sig for city_dist or urb_score
##### City_dist
```{r}
car::Anova(herbivory_gr_dist_m5)
# doesn't converge with all terms... 

r.squaredGLMM(herbivory_gr_dist_m5)
```

##### Urb_score
```{r}
car::Anova(ramets_gr_usc_m1)
# dist not significant

r.squaredGLMM(ramets_gr_usc_m1)

```

#### Urban subtransects: nothing sig
##### City_dist
```{r}
car::Anova(ramets_urb_dist_m1)
# nothing sig

r.squaredGLMM(ramets_urb_dist_m1)


# just main effects
car::Anova(ramets_urb_dist_m2_ME)
# nothing sig

r.squaredGLMM(ramets_urb_dist_m2_ME)

AIC((ramets_urb_dist_m1),
    (ramets_urb_dist_m2_ME)) # better but <2 AIC from full model
```

##### Urb_score
```{r}
car::Anova(ramets_urb_usc_m1)
# nothing sig

r.squaredGLMM(ramets_urb_usc_m1)


# just main effects
car::Anova(ramets_urb_usc_m2_ME)
# nothing sig

r.squaredGLMM(ramets_urb_usc_m2_ME)

AIC((ramets_urb_usc_m1),
    (ramets_urb_usc_m2_ME)) # better but <2 AIC from full model
```


## Survival
### glmer: diagnostics
```{r}
# Gradient / city_dist----------
survival_gr_dist_m1 <- glmer(Dead ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
                               nAGQ=0,
  data = survival_19_20,
  family = binomial(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(survival_gr_dist_m1)
plot(res)
# looks great!



# Gradient / urb_score----------
survival_gr_usc_m1 <- glmer(Dead ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
  data = survival_19_20,
  family = binomial(link = "logit"), 
  nAGQ=0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(survival_gr_usc_m1)
plot(res)
# looks great!


# Urb sites / city_dist----------
survival_urb_dist_m1 <- glmer(Dead ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
 data = survival_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
   nAGQ=0,
 family = binomial(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(survival_gr_dist_m1)
plot(res)
# looks good!


# main effects:
survival_urb_dist_m1_ME <- glmer(Dead ~ (1|Block) + (1|Year) + (1|Population/Family) +  City_dist + Transect_ID,
    data = survival_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
       nAGQ=0,
    family = binomial(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))




# Urb sites / urb_score----------
survival_urb_usc_m1 <- glmer(Dead ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
    data = survival_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = binomial(link = "logit"),
       nAGQ=0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(survival_urb_usc_m1)
plot(res)
# looks good though it doesn't pass the KS test... I think it's fine though


# main effects:
survival_urb_usc_m1_ME <- glmer(Dead ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score + Transect_ID,
    data = survival_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = binomial,
       nAGQ=0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
```

### Entire gradient: *Nothing sig for either
#### City_dist
```{r}
car::Anova(survival_gr_dist_m1)
# dist not significant

r.squaredGLMM(survival_gr_dist_m1)

```

#### Urb_score
```{r}
car::Anova(survival_gr_usc_m1)
# dist not significant

r.squaredGLMM(survival_gr_usc_m1)

```


### Urban subtransects: *Interaxn sig for city_dist but nothing sig for urb_score
#### City_dist
```{r}
car::Anova(survival_urb_dist_m1)
# interaction sig!

r.squaredGLMM(survival_urb_dist_m1)


# just main effects
car::Anova(survival_urb_dist_m2_ME)
#  nothing sig

r.squaredGLMM(survival_urb_dist_m2_ME)

AIC((survival_urb_dist_m1),
    (survival_urb_dist_m1_ME)) # full model better
```


#### Urb_score
```{r}
car::Anova(survival_urb_usc_m1)
# nothing sig

r.squaredGLMM(survival_urb_usc_m1)


# just main effects
car::Anova(survival_urb_usc_m1_ME)
#  nothing sig

r.squaredGLMM(survival_urb_usc_m1_ME)

AIC((survival_urb_usc_m1),
    (survival_urb_usc_m1_ME)) # better but <2 AIC from full model
```

