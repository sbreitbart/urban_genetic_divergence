---
title: "KSR_2019_Height_Survival_Analysis3"
author: "Sophie Breitbart"
output:
  html_document:
    number_sections: true
    df_print: paged
    toc: yes
    toc_depth: 6
    toc_float:
      collapsed: yes
  pdf_document:
    toc: yes
    toc_depth: '2'
editor_options: 
  chunk_output_type: console
---

NOTES:

# Set up notebook
## Load packages

```{r}
library(dplyr)
library(reshape)
library(reshape2)
library(tidyr)
library(ggplot2)
library(ggExtra)
library("ggpubr")
library(devtools)
library(rpart)
library("tibble", lib.loc="~/R/win-library/3.5")
library(ISLR)
library(MASS)
library(car)
library(data.table)
library(plyr)
library(dplyr)
library(ggplot2)
library(gridExtra)
library(Hmisc)
library(lme4)
library(nlme)
library(reshape)
library(lmerTest)
library(tidyverse)
library(vegan)
library(lindia)
library(e1071)
library(ggpubr)
library(forcats)
library(car)
library(multcomp)
library(lsmeans)
library(ggbiplot)
library(ggplot2)
require(MASS)
require(scales)
require(car)
require(ggplot2)
require(ggiraph)
require(ggiraphExtra)
library(geosphere)
```

## Import data
```{r, import}
Data <- read.csv("~/R_Projects/chapter_two/CommonGardenExperiment_2019Data/raw_data/FINAL_3rdmeasuredheight_survival.csv",header=T, na.strings=c("NO PLANT", "none"), blank.lines.skip=TRUE)


Distances <- read.csv("~/R_Projects/chapter_two/CommonGardenExperiment_2019Data/raw_data/Transect_Milkweed_HaversineData_forjoining.csv", na.strings=c("NO PLANT", "none"), blank.lines.skip=TRUE, header=TRUE, sep=",")
```

## Set theme
```{r}
theme_set(theme_classic())
```

### Add City_dist values with Haversine formula
```{r}
# Ref lat and longs are for Yonge & Dundas intersection in downtown Toronto
Distances$Ref_Lat <- "43.656327"
Distances$Ref_Long <- "-79.380904"

# Make lat/long cols numeric
Distances$Latitude <- as.numeric(as.character(Distances$Latitude))
Distances$Longitude <- as.numeric(as.character(Distances$Longitude))
Distances$Ref_Lat <- as.numeric(as.character(Distances$Ref_Lat))
Distances$Ref_Long <- as.numeric(as.character(Distances$Ref_Long))

# Find distances from Yonge/Dundas to sample sites (in meters)
Distances <- Distances %>% mutate(CTD_m = distHaversine(cbind(Longitude, Latitude), cbind(Ref_Long, Ref_Lat)))

# conver to km
Distances$City_dist <- Distances$CTD / 1000

# drop ref lat, long, and city_dist (in m) cols
Distances <- Distances[,-c(7:9)]

```

## Clean data
```{r}
# Remove rows without plants, empty columns
# Though 46 holes were dug per 21 rows of the field plot, each hole was not filled with a plant- ex. Row 1 has empty holes until plot column 13. Removing those empty spreadsheet rows as well as empty spreadsheet columns.
b <- is.na(Data$Block) == TRUE
b2 <- c(1:nrow(Data))[b]
Data <- Data[-b2,]
names(Data)[1]<-"Row"
Data <- Data %>% filter(!is.na(Population)) #there was no plant in this pot anymore... may have been taken by raccoons



## Make certain columns factors / check classes are correct
Data$Block <- factor(Data$Block)
Data$Population <- factor(Data$Population)
Data$Family <- factor(Data$Family)
Data$Replicate <- factor(Data$Replicate)
Data$Comment <- factor(Data$Comment)
Data$Dead_DC1 <- factor(Data$Dead_DC1)
Data$Dead_DC2 <- factor(Data$Dead_DC2)
Data$Dead_DC3 <- factor(Data$Dead_DC3)
Data$Exp_rhiz_binary <- factor(Data$Exp_rhiz_binary)

# str(Data)



## Reclassify Monarch damage & deer damage entries
# Raw data included several indications of damage- "yes", "1,2" (signifying ramets 1 & 2 experienced damage but, for example, ramet 3 didn't)... so this chunk is about converting those indicators of damage into simple yes' and no's.

# MONARCH DAMAGE
# Remove all specific indicators
Data$Monarch_dam <- gsub('all', '1', Data$Monarch_dam)
Data$Monarch_dam <- gsub('no', '0', Data$Monarch_dam)
Data$Monarch_dam <- gsub('yes', '1', Data$Monarch_dam)
Data$Monarch_dam <- gsub('0', '0', Data$Monarch_dam)
Data$Monarch_dam <- gsub('1, 1', '1', Data$Monarch_dam)
Data$Monarch_dam <- gsub('1, 2', '1', Data$Monarch_dam)
Data$Monarch_dam <- gsub('2', '1', Data$Monarch_dam)
Data$Monarch_dam <- gsub('3', '1', Data$Monarch_dam)
Data$Monarch_dam <- gsub('5', '1', Data$Monarch_dam)

# Make column factor
Data$Monarch_dam <- factor(Data$Monarch_dam)


# DEER DAMAGE
Data$Deer_dam <- gsub('yes', '1', Data$Deer_dam)
Data$Deer_dam <- gsub('no', '0', Data$Deer_dam)
Data$Deer_dam <- gsub('8', '1', Data$Deer_dam)
Data$Deer_dam <- gsub('y', '1', Data$Deer_dam)
Data$Deer_dam <- gsub('n', '0', Data$Deer_dam)
Data$Deer_dam <- gsub('0o', '0', Data$Deer_dam)
Data$Deer_dam <- gsub('1es', '1', Data$Deer_dam)


# Make column factor
Data$Deer_dam <- factor(Data$Deer_dam)

# str(Data)



## Remove empty columns
# These columns are empty (all NA's) as seen from str(Data)
Data <- Data[,-c(32:38)]

# Join city_dist to Data
Data <- merge(x = Data, y = Distances, by = "Population", all.x = TRUE)

# Make urban subset of Data
Data_urban <- Data %>% filter(Transect_ID != 'Rural')

# export cleaned data
write.csv(Data,"~/R_Projects/Chapter2_KSR/CommonGardenExperiment_2019Data/clean_data/clean_data_2019KSR.csv", row.names = FALSE)

```

## Find how many replicates and families represented
```{r}
# basic summary stats per family
garden_summary <- Data %>% group_by(Population, Family) %>% dplyr::summarise(
  replicates = n_distinct(Replicate))

## mean
mean(garden_summary$replicates)

## range
min(garden_summary$replicates)
max(garden_summary$replicates)


# basic summary stats per population
garden_summary2 <- Data %>% group_by(Population) %>% dplyr::summarise(
  families = n_distinct(Family)
)

## mean
mean(garden_summary2$families)

## range
min(garden_summary2$families)
max(garden_summary2$families)


# basic summary stats for the whole garden
Data$Replicate <- as.integer(Data$Replicate)
garden_summary3 <- Data %>% group_by(Population) %>% dplyr::summarise(
  n())

sum(garden_summary3$`n()`)

## mean
mean(garden_summary3$`n()`)

## range
min(garden_summary3$`n()`)
max(garden_summary3$`n()`)
```

## Find average height per plant
```{r}
# Selecting rows (plants) that aren't dead and have at least 1 ramet whose height was recorded
Alive <- Data[!(Data$Dead_DC3=="1"),]
Alive <- Alive[!(is.na(Alive$Height_ram1_cm)),]

# Mean height and number of ramets used to calculate mean height
Alive$Mean_height <- rowMeans(Alive[,c(16,18,20,22,24,26,28,30)], na.rm = T)
Alive$Ramets_measured_height <- rowSums(!is.na(Alive[,c(16,18,20,22,24,26,28,30)]))

```

## Find average herbivory per plant - find out how I could've used lapply here
```{r}
# Mean herbivory per plant
## Ramet 1
### Replace non-numeric entries with NA and remove dashes (which symbolize no leaf) 
Alive$Herbiv_ram1 <- gsub('too small', NA, Alive$Herbiv_ram1)
Alive$Herbiv_ram1 <- gsub('too', NA, Alive$Herbiv_ram1)
Alive$Herbiv_ram1 <- gsub('no leaves', NA, Alive$Herbiv_ram1)
Alive$Herbiv_ram1 <- gsub('-', "", Alive$Herbiv_ram1)
Alive$Herbiv_ram1 <- gsub(' ', ",", Alive$Herbiv_ram1)

library(stringi)
### Calculate mean herbivory for ramet 1 in new column
Alive$Herbiv_ram1_pct <- sapply(strsplit(as.character(Alive$Herbiv_ram1), ",", fixed=T), function(x) mean(as.numeric(x)))



## Ramet 2
### Replace non-numeric entries with NA and remove dashes (which symbolize no leaf) 
Alive$Herbiv_ram2 <- gsub('too small', NA, Alive$Herbiv_ram2)
Alive$Herbiv_ram2 <- gsub('too', NA, Alive$Herbiv_ram2)
Alive$Herbiv_ram2 <- gsub('no leaves', NA, Alive$Herbiv_ram2)
Alive$Herbiv_ram2 <- gsub('-', "", Alive$Herbiv_ram2)
Alive$Herbiv_ram2 <- gsub(' ', ",", Alive$Herbiv_ram2)

### Calculate mean herbivory for ramet 2 in new column
Alive$Herbiv_ram2_pct <- sapply(strsplit(as.character(Alive$Herbiv_ram2), ",", fixed=T), function(x) mean(as.numeric(x)))



## Ramet 3
### Replace non-numeric entries with NA and remove dashes (which symbolize no leaf) 
Alive$Herbiv_ram3 <- gsub('too small', NA, Alive$Herbiv_ram3)
Alive$Herbiv_ram3 <- gsub('too', NA, Alive$Herbiv_ram3)
Alive$Herbiv_ram3 <- gsub('no leaves', NA, Alive$Herbiv_ram3)
Alive$Herbiv_ram3 <- gsub('-', "", Alive$Herbiv_ram3)
Alive$Herbiv_ram3 <- gsub(' ', ",", Alive$Herbiv_ram3)

### Calculate mean herbivory for ramet 3in new column
Alive$Herbiv_ram3_pct <- sapply(strsplit(as.character(Alive$Herbiv_ram3), ",", fixed=T), function(x) mean(as.numeric(x)))



## Ramet 4
### Replace non-numeric entries with NA and remove dashes (which symbolize no leaf) 
Alive$Herbiv_ram4 <- gsub('too small', NA, Alive$Herbiv_ram4)
Alive$Herbiv_ram4 <- gsub('too', NA, Alive$Herbiv_ram4)
Alive$Herbiv_ram4 <- gsub('no leaves', NA, Alive$Herbiv_ram4)
Alive$Herbiv_ram4 <- gsub('-', "", Alive$Herbiv_ram4)
Alive$Herbiv_ram4 <- gsub(' ', ",", Alive$Herbiv_ram4)

### Calculate mean herbivory for ramet 4 in new column
Alive$Herbiv_ram4_pct <- sapply(strsplit(as.character(Alive$Herbiv_ram4), ",", fixed=T), function(x) mean(as.numeric(x)))




## Ramet 5
### Replace non-numeric entries with NA and remove dashes (which symbolize no leaf) 
Alive$Herbiv_ram5 <- gsub('too small', NA, Alive$Herbiv_ram5)
Alive$Herbiv_ram5 <- gsub('too', NA, Alive$Herbiv_ram5)
Alive$Herbiv_ram5 <- gsub('no leaves', NA, Alive$Herbiv_ram5)
Alive$Herbiv_ram5 <- gsub('-', "", Alive$Herbiv_ram5)
Alive$Herbiv_ram5 <- gsub(' ', ",", Alive$Herbiv_ram5)

### Calculate mean herbivory for ramet 5 in new column
Alive$Herbiv_ram5_pct <- sapply(strsplit(as.character(Alive$Herbiv_ram5), ",", fixed=T), function(x) mean(as.numeric(x)))




## Ramet 6
### Replace non-numeric entries with NA and remove dashes (which symbolize no leaf) 
Alive$herbiv_Ram6 <- gsub('too small', NA, Alive$herbiv_Ram6)
Alive$herbiv_Ram6 <- gsub('too', NA, Alive$herbiv_Ram6)
Alive$herbiv_Ram6 <- gsub('no leaves', NA, Alive$herbiv_Ram6)
Alive$herbiv_Ram6 <- gsub('-', "", Alive$herbiv_Ram6)
Alive$herbiv_Ram6 <- gsub(' ', ",", Alive$herbiv_Ram6)

### Calculate mean herbivory for ramet 6 in new column
Alive$herbiv_Ram6_pct <- sapply(strsplit(as.character(Alive$herbiv_Ram6), ",", fixed=T), function(x) mean(as.numeric(x)))



## Ramet 7
### Replace non-numeric entries with NA and remove dashes (which symbolize no leaf) 
Alive$herbiv_Ram7 <- gsub('too small', NA, Alive$herbiv_Ram7)
Alive$herbiv_Ram7 <- gsub('too', NA, Alive$herbiv_Ram7)
Alive$herbiv_Ram7 <- gsub('no leaves', NA, Alive$herbiv_Ram7)
Alive$herbiv_Ram7 <- gsub('-', "", Alive$herbiv_Ram7)
Alive$herbiv_Ram7 <- gsub(' ', ",", Alive$herbiv_Ram7)

### Calculate mean herbivory for ramet 7 in new column
Alive$herbiv_Ram7_pct <- sapply(strsplit(as.character(Alive$herbiv_Ram7), ",", fixed=T), function(x) mean(as.numeric(x)))




## Ramet 8
### Replace non-numeric entries with NA and remove dashes (which symbolize no leaf) 
Alive$herbiv_Ram8 <- gsub('too small', NA, Alive$herbiv_Ram8)
Alive$herbiv_Ram8 <- gsub('too', NA, Alive$herbiv_Ram8)
Alive$herbiv_Ram8 <- gsub('no leaves', NA, Alive$herbiv_Ram8)
Alive$herbiv_Ram8 <- gsub('-', "", Alive$herbiv_Ram8)
Alive$herbiv_Ram8 <- gsub(' ', ",", Alive$herbiv_Ram8)

### Calculate mean herbivory for ramet 8 in new column
Alive$herbiv_Ram8_pct <- sapply(strsplit(as.character(Alive$herbiv_Ram8), ",", fixed=T), function(x) mean(as.numeric(x)))



# ALL RAMETS
# Mean height and number of ramets used to calculate mean height
Alive$Mean_herbiv <- rowMeans(Alive[,c(44:51)], na.rm = T)
Alive$Ramets_measured_herbiv <- rowSums(!is.na(Alive[,c(44:51)]))


```




## Make new df that removes heights, herbivory measurements per indiv (Alive_sum)
```{r}
Alive_sum <- Alive[,c(1, 4:6,11:15, 32:34, 42:53)]

# add transect and location data
Alive_sum1 <- merge(x = Alive_sum, y = Distances, by = "Population", all.x = TRUE)
# names(Alive_sum1)[24] <- "City_dist"

# Only urban entries:
Alive_sum1_urban <- Alive_sum1 %>% filter(Transect_ID != 'Rural')

```


# Analyze herbivory & height
## Find average herbivory & height per family & population
```{r}
# Create new data table with only pertinent columns
Herbiv_df <- Alive[,c(1, 4:6, 12:34, 42:53)]

# Add transect data via merge
Herbiv_df <- merge(x = Herbiv_df, y = Distances, by = "Population", all.x = TRUE)

# Add column for sqrt(height) as per diagnostic testing
Herbiv_df$Mean_height_sqrt <- Herbiv_df$Mean_height^(1/2)

# Find family means
fams_herbiv <- ddply(Herbiv_df, .(Population, Family), summarise,
    sum_replicates = n_distinct(Replicate),
    mean_height = mean(Mean_height),
    mean_height_sqrt = mean(Mean_height_sqrt),
    sum_height = sum(Ramets_measured_height),
    mean_herbiv = mean(Mean_herbiv, na.rm=T),
    sum_herbiv = sum(Ramets_measured_herbiv),
    dist_cc = first(City_dist),
    transect = first(Transect_ID))


# Find population means
pops_herbiv <- ddply(Herbiv_df, ~Population, summarise,
    sum_fams = n_distinct(Family),
    sum_replicates = n_distinct(Replicate),
    mean_height = mean(Mean_height),
    sum_height = sum(Ramets_measured_height),
    mean_height_sqrt = mean(Mean_height_sqrt),
    mean_herbiv = mean(Mean_herbiv, na.rm=T),
    sum_herbiv = sum(Ramets_measured_herbiv),
    dist_cc = first(City_dist),
    transect = first(Transect_ID))


# Use SummarySE to get stats per family & population
## Herbivory
SSE_fams_herb <- summarySE(Herbiv_df, measurevar="Mean_herbiv", groupvars=c("Population", "Family"), na.rm=TRUE)
SSE_fams_herb <- merge(x = SSE_fams_herb, y = Distances, by = "Population", all.x = TRUE)

SSE_pops_herb <- summarySE(Herbiv_df, measurevar="Mean_herbiv", groupvars=c("Population"), na.rm=TRUE)
SSE_pops_herb <- merge(x = SSE_pops_herb, y = Distances, by = "Population", all.x = TRUE)
SSE_pops_herb_urban <- SSE_pops_herb %>% filter(Transect_ID != 'Rural')

## Height
### NOT TRANSFORMED
SSE_fams_height <- summarySE(Herbiv_df, measurevar="Mean_height", groupvars=c("Population", "Family"), na.rm=TRUE)
SSE_fams_height <- merge(x = SSE_fams_height, y = Distances, by = "Population", all.x = TRUE)

SSE_pops_height <- summarySE(Herbiv_df, measurevar="Mean_height", groupvars=c("Population"), na.rm=TRUE)
SSE_pops_height <- merge(x = SSE_pops_height, y = Distances, by = "Population", all.x = TRUE)


### TRANSFORMED- DON'T USE THIS
# SSE_fams_height_sqrt <- summarySE(Herbiv_df, measurevar="Mean_height_sqrt", groupvars=c("Population", "Family"), na.rm=TRUE)
# SSE_fams_height_sqrt <- merge(x = SSE_fams_height_sqrt, y = Distances, by = "Population", all.x = TRUE)
# 
# SSE_pops_height_sqrt <- summarySE(Herbiv_df, measurevar="Mean_height_sqrt", groupvars=c("Population"), na.rm=TRUE)
# SSE_pops_height_sqrt <- merge(x = SSE_pops_height_sqrt, y = Distances, by = "Population", all.x = TRUE)
# 

```


# Analyze survival
## Create survival table
Table (then, data frame) shows each population x family combination (up to 5 families per population), alongside how many plants per population's family is definitely alive (column "no") or is not alive because there was no plant found in the pot (column "no"). These 2 categories are answers to the question, "is the plant dead?". 
```{r}
#SURVIVAL TABLE FROM DATA COLLECTION 1 (June 3-7, 2019):

surv_1a <- table(Data$Population,Data$Family, Data$Dead_DC1)
surv_1 <- as.data.frame(surv_1a)
names(surv_1)[1]<-"Population"
names(surv_1)[2]<-"Family"
names(surv_1)[3]<-"Dead"

DC1_survival <- spread(surv_1, Dead, Freq)
# Adding a "Total" column showing the total number of plants per population family. If the "Total" column = 0, removing that row. Before planting, that family had not been represented with replicates in the first place.

DC1_survival$Total <- rowSums(DC1_survival[3:4])
DC1_survival<-DC1_survival[!(DC1_survival$Total==0),] # removing rows corresponding to populations' a priori empty families

names(DC1_survival)[3]<-"Maybe_dead" 
names(DC1_survival)[4]<-"Not_dead"
names(DC1_survival)[5]<-"Probably_dead" # there was "nothing there" in the pot



#SURVIVAL TABLE FROM DATA COLLECTION 2 (June 16-19, 2019):

surv_2a <- table(Data$Population,Data$Family, Data$Dead_DC2)
surv_2 <- as.data.frame(surv_2a)
names(surv_2)[1]<-"Population"
names(surv_2)[2]<-"Family"
names(surv_2)[3]<-"Dead"

DC2_survival <- spread(surv_2, Dead, Freq)
DC2_survival$Total <- rowSums(DC2_survival[3:4])
DC2_survival<-DC2_survival[!(DC2_survival$Total==0),] # removing rows corresponding to populations' a priori empty families

names(DC2_survival)[3]<-"Not_dead" 
names(DC2_survival)[4]<-"Dead" 



#SURVIVAL TABLE FROM DATA COLLECTION 3 (August 30-Sept 4, 2019):

surv_3a <- table(Data$Population,Data$Family, Data$Dead_DC3)
surv_3 <- as.data.frame(surv_3a)
names(surv_3)[1]<-"Population"
names(surv_3)[2]<-"Family"
names(surv_3)[3]<-"Dead"

DC3_survival <- spread(surv_3, Dead, Freq)
DC3_survival$Total <- rowSums(DC3_survival[3:4])
DC3_survival<-DC3_survival[!(DC3_survival$Total==0),] # removing rows corresponding to populations' a priori empty families

names(DC3_survival)[3]<-"Not_dead" 
names(DC3_survival)[4]<-"Dead" 

#############################################################################################
#################### LOOK INTO WHY A FEW POPS HAVE >5 PLANTS IN THEM ########################
##############################################################################################

# DC3_survival$yes <- as.numeric(DC3_survival$yes)
# DC3_survival$no <- as.numeric(DC3_survival$no)

```

## Find current survival percentages
```{r}

# Per family
## Adding column to indicate the percentage of plants per family that are definitely alive.

DC3_survival$Pct_Survival_Definite <- DC3_survival$Not_dead/DC3_survival$Total
DC3_survival$Pct_Survival_Definite <- signif(DC3_survival$Pct_Survival_Definite, 2)*100


hist(DC3_survival$Pct_Survival_Definite,
     labels = TRUE,
     main="Histogram of Family Survival Rates",
     xlab="Percentage of families that survived 2019 field season",
     breaks = 10)


# Per population
## Same idea as above except percentages are for each population (combining each populations' families).
DC3_survival_pops <- ddply(DC3_survival,~Population,summarise,
                           families = n_distinct(Family),
                           sum_not_dead = sum(Not_dead),
                           sum_dead = sum(Dead),
                           sum_total = sum(Total))

DC3_survival_pops$Pct_Survival_Definite <- DC3_survival_pops$sum_not_dead/DC3_survival_pops$sum_total
DC3_survival_pops$Pct_Survival_Definite <- signif(DC3_survival_pops$Pct_Survival_Definite, 2)*100

hist(DC3_survival_pops$Pct_Survival_Definite,
     labels = TRUE,
     main="Histogram of Population Survival Rates",
     xlab="Percentage of populations that survived 2019 field season",
     breaks = 10)


# per plant
DC3_survival_plants <- DC3_survival %>%
  group_by(Population) %>%
  summarise(
    sum_not_dead = sum(Not_dead),
    sum_dead = sum(Dead),
    sum_total = sum(Total))

DC3_survival_plants$Pct_Survival_Definite <- DC3_survival_plants$sum_no/DC3_survival_plants$sum_total
DC3_survival_plants$Pct_Survival_Definite <- signif(DC3_survival_plants$Pct_Survival_Definite, 2)*100

```

## SummarySE
```{r}
SSE_fams_surv <- summarySE(DC3_survival, measurevar="Pct_Survival_Definite", groupvars=c("Population", "Family"), na.rm=TRUE)
SSE_fams_surv <- merge(x = SSE_fams_surv, y = Distances, by = "Population", all.x = TRUE)

SSE_pops_surv <- summarySE(DC3_survival, measurevar="Pct_Survival_Definite", groupvars=c("Population"), na.rm=TRUE)
SSE_pops_surv <- merge(x = SSE_pops_surv, y = Distances, by = "Population", all.x = TRUE)

```

## OLD: Plots of survival per population vs. distance from city center
```{r}
# When population location is spread over a few sites (e.g. there are several AS identifiers and only 1 MW identifier), coordinates chosen correspond to first AS site. E.g. For MW003, there are two AS sites- AS003 & AS004. AS003 will be designated to show the location of MW003. Same practice for MW004, 005, 006, 007.

Dist_merged <- merge(x = DC3_survival_pops, y = Distances, by = "Population", all.x = TRUE)


# Plot and stats for percent survival vs. distance from city center (weighted by total plants per population)
ggplot(Dist_merged, aes(x = City_dist, y = Pct_Survival_Definite, weights=Dist_merged$sum_total)) +
  labs(x = "Distance to urban center (km)", y = "Survival Rate (Definite)") +
  geom_point(shape=21) +
  geom_smooth(method = "lm", se = T, mapping = aes(weight = Dist_merged$sum_total)) +
  scale_y_continuous(breaks=c(0,20, 40, 60,80,100), limits=c(0,100)) + 
  ggtitle('Weighted Definite Population Survival Rate vs. Distance from City Center')



# Plot and stats for definite percent survival vs. distance from city center
ggplot(Dist_merged, aes(x = City_dist, y = Pct_Survival_Definite)) +
  labs(x = "Distance to urban center (km)", y = "Survival Rate (Definite)") +
  geom_point(shape=21) +
  geom_smooth(method = "lm", se = T) +
  scale_y_continuous(breaks=c(0,20, 40, 60,80,100), limits=c(0,100)) + 
  ggtitle('Definite Population Survival Rate vs. Distance from City Center')

surv_lm_2 <- lm(Pct_Survival_Definite ~ City_dist, data=Dist_merged)
par(mfrow=c(2,2))
plot(surv_lm_2)
summary(surv_lm_2)



## Analyzing survival by transect

transect_survival <- ddply(Dist_merged,~Transect_ID,summarise,
    sum_populations = n_distinct(Population),
    sum_families = sum(families),
    sum_not_dead = sum(sum_not_dead),
    sum_dead = sum(sum_dead),
    sum_total = sum(sum_total))

transect_survival$Pct_Survival <- transect_survival$sum_not_dead/transect_survival$sum_total
transect_survival$Pct_Survival <- signif(transect_survival$Pct_Survival, 2)*100

# Incredibly equal! 88,89, and 90% survival depending on transect!

```

# Analyze No. of Ramets
```{r}
# Use SummarySE to get stats per family & population
SSE_fams_rams <- summarySE(Herbiv_df, measurevar="Ramets_measured_height", groupvars=c("Population", "Family"), na.rm=TRUE)
SSE_fams_rams <- merge(x = SSE_fams_rams, y = Distances, by = "Population", all.x = TRUE)

SSE_pops_rams <- summarySE(Herbiv_df, measurevar="Ramets_measured_height", groupvars=c("Population"), na.rm=TRUE)
SSE_pops_rams <- merge(x = SSE_pops_rams, y = Distances, by = "Population", all.x = TRUE)

```

# Analyze growth- IGNORE FOR NOW. MAY BE MOOT. TOTAL HEIGHTS ACCOMPLISH SAME GOAL
## Plot growth per population vs. distance from city center

```{r}

Data_Growth <- Data[,c(4:7, 11, 12)]
Data_Growth$Total_Height_DC0 <- NA

#DC means "data collection" episode. DC0 means the benchmark for all plants' heights when they were planted at KSR = 0mm tall.

#DC1 means "data collection 1"- which took place from June 3-7, just about 2 weeks since all plants were in the ground (Wednesday, May 22, 2019).

#DC2 means "data collection 2"- which took place from June 16-19, just about 4 weeks since all plants were in the ground (Wednesday, May 22, 2019).

Data_Growth$Total_Height_DC0 <- 0
- DON'T USEData_Growth<-Data_Growth[!(Data_Growth$Total_Height_DC2==0),] # removing rows corresponding to currently dead plants

# g is a new data frame with new columns corresponding to each population's plants' total heights: each plant's ramet's heights, added, and totaled per population.
g <- Data_Growth %>% group_by(Population) %>% summarise(DC0_total_pop_heights = sum(Total_Height_DC0),
                                                        DC1_total_pop_heights  = sum(Total_Height_DC1),
                                                        DC2_total_pop_heights  = sum(Total_Height_DC2))

Data_Growth_Distances <- merge(x = g, y = Distances, by = "Population", all.x = TRUE)
Data_Growth_Distances$Pop_Size <- Dist_merged$sum_total

Data_Growth_Distances <- Data_Growth_Distances[,-(5:8)] #removing unnecessary cols

Data_Growth_Distances$Avg_Height_DC0to1 <- NA 
Data_Growth_Distances$Avg_Height_DC1to2  <- NA
Data_Growth_Distances$Avg_Growth_Rate_DC0to1 <- NA
Data_Growth_Distances$Avg_Growth_Rate_DC1to2 <- NA


Data_Growth_Distances$Avg_Height_DC0to1  <- Data_Growth_Distances[3] / Data_Growth_Distances[7] #this col represents each population's average of all the combined heights of each plant's ramets for data collection 1.
Data_Growth_Distances$Avg_Height_DC1to2 <- Data_Growth_Distances[4] / Data_Growth_Distances[7] #this col represents each population's average of all the combined heights of each plant's ramets for data collection 2.
Data_Growth_Distances$Avg_Growth_Rate_DC0to1 <- Data_Growth_Distances[3]/ Data_Growth_Distances[7] #this col represents each population's average amount of mm of height grown by each ramet per plant per population from the first data collection event (when all plants were at height 0) to the actual first data collection event.
Data_Growth_Distances$Avg_Growth_Rate_DC1to2 <- (Data_Growth_Distances[4] - Data_Growth_Distances[3])/ Data_Growth_Distances[7] #this col represents each population's average amount of mm of height grown by each ramet per plant per population from the actual first data collection event to the second data collection event.



##### Converting Data_Growth_Distances df into one without nesting data frames (last 3 cols)

  # Find all columns that are data.frame
  # Assuming your data frame is stored in variable 'y'
  data.frame.cols <- unname(sapply(Data_Growth_Distances, function(x) class(x) == "data.frame"))
  z <- Data_Growth_Distances[, !data.frame.cols]

  # All columns of class "data.frame"
  dfs <- Data_Growth_Distances[, data.frame.cols]

  # Recursively unnest each of these columns
  unnest_dataframes <- function(x) {
    Data_Growth_Distances <- do.call(data.frame, x)
    if("data.frame" %in% sapply(Data_Growth_Distances, class)) {
        unnest_dataframes(Data_Growth_Distances)
    } else {
        cat('Nested data.frames successfully unpacked\n')
      }
    Data_Growth_Distances
  }

  df2 <- unnest_dataframes(dfs)

  # Combine with original data
  Data_Growth_Distances2 <- cbind(z, df2)
  
#####
  
names(Data_Growth_Distances2)[8] <- "Avg_Height_DC0to1"
names(Data_Growth_Distances2)[9] <- "Avg_Height_DC1to2"
names(Data_Growth_Distances2)[10] <- "Avg_Growth_Rate_DC0to1"
names(Data_Growth_Distances2)[11] <- "Avg_Growth_Rate_DC1to2"



DGD2_sorted <- Data_Growth_Distances2 %>% arrange(City_dist)
# DGD2_sorted$City_dist <- factor(DGD2_sorted$City_dist, levels = DGD2_sorted$City_dist[order(DGD2_sorted$Growth_Rate_DC12)])

p1 <- ggplot(DGD2_sorted, aes(x=City_dist, y=Avg_Growth_Rate_DC0to1, color=Transect_ID, shape=Transect_ID)) + 
    labs(title="Average Amount Grown per Plant per Population", subtitle = "Between Start and Data Collection Event 1", x = "Population's distance to urban center (km)", y = "Amount Grown (mm)") +
  geom_point(shape=21, size= 4) +
  geom_smooth(method = "lm", se = T)
p1

p1_stats <- lm(Avg_Growth_Rate_DC0to1 ~ City_dist, data=DGD2_sorted)
par(mfrow=c(2,2))
plot(p1_stats)
summary(p1_stats)


p2 <- ggplot(DGD2_sorted, aes(x=City_dist, y=Avg_Growth_Rate_DC1to2, color=Transect_ID, shape=Transect_ID)) + 
    labs(title="Average Amount Grown per Plant per Population", subtitle = "Between Data Collection Events 1-2", x = "Population's distance to urban center (km)", y = "Amount Grown (mm)") +
  geom_point(shape=21, size= 4) +
  geom_smooth(method = "lm", se = T) 
p2

p2_stats <- lm(Avg_Growth_Rate_DC1to2 ~ City_dist, data=DGD2_sorted)
par(mfrow=c(2,2))
plot(p2_stats)
summary(p2_stats)

p3 <- ggplot(DGD2_sorted, aes(x=City_dist, y=Avg_Height_DC0to1, color=Transect_ID, shape=Transect_ID)) + 
    labs(title="Average Height per Plant per Population", subtitle = "At Data Collection Event 1", x = "Population's distance to urban center (km)", y = "Average Plant Height (mm)") +
  geom_point(shape=21, size= 4) +
  geom_smooth(method = "lm", se = T) 
p3

p3_stats <- lm(Avg_Height_DC0to1 ~ City_dist, data=DGD2_sorted)
par(mfrow=c(2,2))
plot(p3_stats)
summary(p3_stats)

p4 <- ggplot(DGD2_sorted, aes(x=City_dist, y=Avg_Height_DC1to2, color=Transect_ID, shape=Transect_ID)) + 
    labs(title="Average Height per Plant per Population", subtitle = "At Data Collection Event 2", x = "Population's distance to urban center (km)", y = "Average Plant Height (mm)") +
  geom_point(shape=21, size= 4) +
  geom_smooth(method = "lm", se = T) 
p4

p4_stats <- lm(Avg_Growth_Rate_DC1to2 ~ City_dist, data=DGD2_sorted)
par(mfrow=c(2,2))
plot(p4_stats)
summary(p4_stats)



library(ggpubr)
 multi.page <- ggarrange(p1, p2, p3, p4, nrow = 2, ncol = 1)
 ggexport(multi.page, filename = "multi.page.ggplot2.1.pdf")

```

## Box plots for each growth period

```{r}
library(dplyr)
library(ggplot2)



ggboxplot(DGD2_sorted, x = "Transect_ID", y = "Avg_Height_DC0to1", 
          color = "Transect_ID", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
          order = c("North", "South", "Rural"),
          ylab = "Growth Rate- DC0 to 1", xlab = "Transect")

ggboxplot(DGD2_sorted, x = "Transect_ID", y = "Avg_Height_DC1to2", 
          color = "Transect_ID", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
          order = c("North", "South", "Rural"),
          ylab = "Growth Rate- DC1 to 2", xlab = "Transect")

ggboxplot(DGD2_sorted, x = "Transect_ID", y = "Avg_Growth_Rate_DC0to1", 
          color = "Transect_ID", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
          order = c("North", "South", "Rural"),
          ylab = "Growth Rate- DC0 to 2", xlab = "Transect")

ggboxplot(DGD2_sorted, x = "Transect_ID", y = "Avg_Growth_Rate_DC1to2", 
          color = "Transect_ID", palette = c("#00AFBB", "#E7B800", "#FC4E07"),
          order = c("North", "South", "Rural"),
          ylab = "Growth Rate- DC0 to 2", xlab = "Transect")

```

## Plotting all plants as individuals (I know this isn't statistically the best idea)

```{r}
test1 <- merge(x = Data_Growth, y = Distances, by = "Population", all.x = TRUE)

ggplot(data = test1, aes(x=City_dist, y=Total_Height_DC1, color=Transect_ID, shape=Transect_ID)) + geom_point() + geom_smooth(method="lm")


ggplot(data = test1, aes(x=City_dist, y=Total_Height_DC2,color=Transect_ID, shape=Transect_ID)) + geom_point() + geom_smooth(method="lm")

```


## ____

```{r}

growth_means <- aggregate(DGD2_sorted[, 9:11], list(DGD2_sorted$Transect_ID), mean)
growth_means <- growth_means[,c(1,4,3,2)]
names(growth_means)[1] <- "Transect"
names(growth_means)[2] <- "Growth_0to1"
names(growth_means)[3] <- "Growth_1to2"
names(growth_means)[4] <- "Growth_0to2"



```

# Plots of vars among transects & dist from city center
## Pictorial Variation among families
```{r}
# Reorder so plot's x axis shows pops in  order of IQR
SSE_fams_herb$Population <- reorder(SSE_fams_herb$Population, SSE_fams_herb$se)

ggplot(SSE_fams_herb, aes(x=Population, y=Mean_herbiv)) + geom_boxplot()


# Herbiv
ggplot(Alive_sum1, aes(x=Population, y=Mean_herbiv, fill = Family_unique)) +
  geom_dotplot(binaxis='y', stackdir='center', dotsize=0.5) +
  theme(legend.position = "none") 

# Height
ggplot(Alive_sum1, aes(x=Population, y=Mean_height, fill = Family_unique)) +
  geom_dotplot(binaxis='y', stackdir='center', dotsize=0.5) +
  theme(legend.position = "none") 

# No. Ramets
ggplot(Alive_sum1, aes(x=Population, y=Alive_ram, fill = Family_unique)) +
  geom_dotplot(binaxis='y', stackdir='center', dotsize=0.5) +
  theme(legend.position = "none")

# Survival
ggplot(Data, aes(x=Population, y=Dead_DC3, fill = Family_unique)) +
  geom_dotplot(binaxis='y', stackdir='center', dotsize=0.5) +
  theme(legend.position = "none")
```

## Herbivory
#### All transects
```{r}
# Basic scatterplot w/regression line
ggplot(pops_herbiv, aes(x=dist_cc, y=mean_herbiv)) +
  geom_point() +
  geom_smooth(method=lm)

# get p-val and r-sq
modsum1 <- lm(Mean_herbiv ~ City_dist, SSE_pops_herb)
modsum <- summary(modsum1)
r2 = modsum$adj.r.squared # = 0.04
my.p = modsum$coefficients[2,4] # = 0.075

# Means w/error bars scatterplot w/regression line
herbiv_mean_plot1 <- ggplot(SSE_pops_herb, aes(x=City_dist, y=Mean_herbiv)) + 
  geom_point(stat="identity", position=position_dodge()) +
  geom_errorbar(aes(ymin=Mean_herbiv-se, ymax=Mean_herbiv+se), width = 0.5) +
    geom_smooth(color = "red", method = lm,  se = FALSE) +
  theme(text = element_text(size=14)) +
  labs(x = "Distance to Urban Center (km)",
    y="Herbivory")  

## BOXPLOTS
# Reorder so plot's x axis shows pops in dist_cc order
SSE_fams_herb$Population <- reorder(SSE_fams_herb$Population, SSE_fams_herb$City_dist)
ggplot(SSE_fams_herb, aes(x=Population, y=Mean_herbiv)) + geom_boxplot()


# Reorder so plot's x axis shows pops in  order of IQR
SSE_fams_herb$Population <- reorder(SSE_fams_herb$Population, SSE_fams_herb$se)

ggplot(SSE_fams_herb, aes(x=Population, y=Mean_herbiv)) + geom_boxplot()

```

#### Urban subtransects
```{r}
# Basic scatterplot w/regression line, by transect
ggplot(pops_herbiv %>% filter(transect == c("North", "South")), aes(x=dist_cc, y=mean_herbiv, color = transect)) +
  geom_point() +
  geom_smooth(method=lm)


#### subset of only urban subtransects:
# SSE_pops_herb_urban <- SSE_pops_herb %>% filter(Transect_ID != 'Rural')

## With error bars
herb_mean_urban_plot1 <- ggplot(SSE_pops_herb_urban, aes(x=City_dist, y=Mean_herbiv, color= Transect_ID)) + 
  geom_point(aes(colour=Transect_ID, shape=Transect_ID, fill=Transect_ID), size = 3, stat="identity", position=position_dodge()) +
  geom_errorbar(aes(ymin=Mean_herbiv-se, ymax=Mean_herbiv+se), width = 0.5) +
    geom_smooth( method = lm, se = F) +
  theme(text = element_text(size=14),
        legend.position = c(0.2, 0.85)) +
  labs(x = "Distance to Urban Center (km)",
    y="Herbivory") +
  scale_shape_discrete(name  ="Sample Site Subtransect",
                       breaks = c("North", "South"),
                       labels=c("Urban: Non-Corridor", "Urban: Corridor")) +
  scale_colour_discrete(name  ="Sample Site Subtransect",
                        breaks = c("North", "South"),
                        labels=c("Urban: Non-Corridor", "Urban: Corridor")) +
  scale_fill_discrete(name  ="Sample Site Subtransect",
                        breaks = c("North", "South"),
                        labels=c("Urban: Non-Corridor", "Urban: Corridor"))

# Violin plot
ggplot(SSE_pops_herb_urban, aes(Transect_ID, Mean_herbiv)) +
 geom_violin(aes(fill = Transect_ID), trim = FALSE) + 
  geom_boxplot(width = 0.2)+
  scale_fill_manual(values = c("#00AFBB", "#E7B800", "#FC4E07"))+
  stat_compare_means(method = "wilcox.test", label = "p.format", size=6,label.x = 1.5, label.y = 4) +
  theme(text = element_text(size=18),
        legend.position = "none") +
  labs(x = "Subtransect",
    y = "Herbivory") 

```


## Height (Cumulative Ramet Length)
#### All transects
```{r}
# Basic scatterplot w/regression line
ggplot(pops_herbiv, aes(x=dist_cc, y=mean_height)) +
  geom_point() +
  geom_smooth(method=lm)


# get p-val and r-sq
modsum1 <- lm(Mean_height ~ City_dist, SSE_pops_height)
modsum <- summary(modsum1)
r2 = modsum$adj.r.squared # = -0.02
my.p = modsum$coefficients[2,4] # = 0.71

# Means w/error bars scatterplot w/regression line
heights_mean_plot1 <- ggplot(SSE_pops_height, aes(x=City_dist, y=Mean_height)) + 
  geom_point(stat="identity", position=position_dodge()) +
  geom_errorbar(aes(ymin=Mean_height-se, ymax=Mean_height+se), width = 0.5) +
    geom_smooth(color = "red", method = lm,  se = FALSE) +
  theme(text = element_text(size=14)) +
  labs(x = "Distance to Urban Center (km)",
    y="Cumulative \n Ramet Length (cm)")  

## BOXPLOTS
# Reorder so plot's x axis shows pops in dist_cc order
SSE_fams_height$Population <- reorder(SSE_fams_height$Population, SSE_fams_height$City_dist)

ggplot(SSE_fams_height, aes(x=Population, y=Mean_height)) + geom_boxplot()

```

#### Urban subtransects
```{r}
ggplot(pops_herbiv, aes(x=dist_cc, y=mean_height, color = transect)) +
  geom_point() +
  geom_smooth(method=lm)

#### subset of only urban subtransects:
SSE_pops_height_urban <- SSE_pops_height %>% filter(Transect_ID != 'Rural')

## With error bars
heights_mean_urban_plot1 <- ggplot(SSE_pops_height_urban, aes(x=City_dist, y=Mean_height, color= Transect_ID)) + 
  geom_point(aes(colour=Transect_ID, shape=Transect_ID, fill=Transect_ID), size = 3, stat="identity", position=position_dodge()) +
  geom_errorbar(aes(ymin=Mean_height-se, ymax=Mean_height+se), width = 0.5) +
    geom_smooth( method = lm, se = F) +
  theme(text = element_text(size=14),
        legend.position = c(0.65, 0.9),
        legend.direction = "horizontal") +
  labs(x = "Distance to Urban Center (km)",
    y="Cumulative \n Ramet Length (cm)") +
  scale_shape_discrete(name  ="Sample Site Subtransect",
                       breaks = c("North", "South"),
                       labels=c("Urban: Non-Corridor", "Urban: Corridor")) +
  scale_colour_discrete(name  ="Sample Site Subtransect",
                        breaks = c("North", "South"),
                        labels=c("Urban: Non-Corridor", "Urban: Corridor")) +
  scale_fill_discrete(name  ="Sample Site Subtransect",
                        breaks = c("North", "South"),
                        labels=c("Urban: Non-Corridor", "Urban: Corridor"))

# Violin plot
ggplot(SSE_pops_height_urban, aes(Transect_ID, Mean_height)) +
 geom_violin(aes(fill = Transect_ID), trim = FALSE) + 
  geom_boxplot(width = 0.2)+
  scale_fill_manual(values = c("#00AFBB", "#E7B800", "#FC4E07"))+
  stat_compare_means(method = "wilcox.test", label = "p.format", size=6,label.x = 1.5, label.y = 4) +
  theme(text = element_text(size=18),
        legend.position = "none") +
  labs(x = "Subtransect",
    y = "Total Height of Ramets (cm)") 

```

## Survival
### All transects
```{r}
# Basic scatterplot w/regression line
ggplot(SSE_pops_surv, aes(x=City_dist, y=Pct_Survival_Definite)) +
  geom_point() +
  geom_smooth(method=lm)


# get p-val and r-sq
modsum1 <- lm(Pct_Survival_Definite ~ City_dist, SSE_pops_surv)
modsum <- summary(modsum1)
r2 = modsum$adj.r.squared # = -0.004
my.p = modsum$coefficients[2,4] # = 0.37

# Means w/error bars scatterplot w/regression line
surv_mean_plot1 <- ggplot(SSE_pops_surv, aes(x=City_dist, y=Pct_Survival_Definite)) + 
  geom_point(stat="identity", position=position_dodge()) +
  geom_errorbar(aes(ymin=Pct_Survival_Definite-se, ymax=Pct_Survival_Definite+se), width = 0.5) +
    geom_smooth(color = "red", method = lm,  se = FALSE) +
  theme(text = element_text(size=14)) +
  labs(x = "Distance to Urban Center (km)",
    y="Survival Rate")
surv_mean_plot1

## BOXPLOTS
# Reorder so plot's x axis shows pops in dist_cc order
SSE_fams_surv$Population <- reorder(SSE_fams_surv$Population, SSE_fams_surv$City_dist)

ggplot(SSE_fams_surv, aes(x=Population, y=Pct_Survival_Definite)) + geom_boxplot()

```

### Urban subtransects
```{r}
ggplot(SSE_pops_surv, aes(x=City_dist, y=Pct_Survival_Definite, color = Transect_ID)) +
  geom_point() +
  geom_smooth(method=lm)

#### subset of only urban subtransects:
SSE_pops_surv_urban <- SSE_pops_surv %>% filter(Transect_ID != 'Rural')

## With error bars
surv_mean_urban_plot1 <- ggplot(SSE_pops_surv_urban, aes(x=City_dist, y=Pct_Survival_Definite, color= Transect_ID)) + 
  geom_point(aes(colour=Transect_ID, shape=Transect_ID, fill=Transect_ID), size = 3, stat="identity", position=position_dodge()) +
  geom_errorbar(aes(ymin=Pct_Survival_Definite-se, ymax=Pct_Survival_Definite+se), width = 0.5) +
    geom_smooth( method = lm, se = F) +
  theme(text = element_text(size=14),
        legend.position = c(0.85, 0.1))+
  labs(x = "Distance to Urban Center (km)",
    y="Survival Rate") +
  scale_shape_discrete(name  ="Sample Site Subtransect",
                       breaks = c("North", "South"),
                       labels=c("Urban: Non-Corridor", "Urban: Corridor")) +
  scale_colour_discrete(name  ="Sample Site Subtransect",
                        breaks = c("North", "South"),
                        labels=c("Urban: Non-Corridor", "Urban: Corridor")) +
  scale_fill_discrete(name  ="Sample Site Subtransect",
                        breaks = c("North", "South"),
                        labels=c("Urban: Non-Corridor", "Urban: Corridor"))
surv_mean_urban_plot1

# Violin plot
ggplot(SSE_pops_height_urban, aes(Transect_ID, Mean_height)) +
 geom_violin(aes(fill = Transect_ID), trim = FALSE) + 
  geom_boxplot(width = 0.2)+
  scale_fill_manual(values = c("#00AFBB", "#E7B800", "#FC4E07"))+
  stat_compare_means(method = "wilcox.test", label = "p.format", size=6,label.x = 1.5, label.y = 4) +
  theme(text = element_text(size=18),
        legend.position = "none") +
  labs(x = "Subtransect",
    y = "Total Height of Ramets (cm)") 

```

## No. Ramets
### All transects 
```{r}
# Basic scatterplot w/regression line
ggplot(SSE_pops_rams, aes(x=City_dist, y=Ramets_measured_height)) +
  geom_point() +
  geom_smooth(method=lm)


# get p-val and r-sq
modsum1 <- lm(Ramets_measured_height ~ City_dist, SSE_pops_rams)
modsum <- summary(modsum1)
r2 = modsum$adj.r.squared # = -0.02
my.p = modsum$coefficients[2,4] # = 0.94

# Means w/error bars scatterplot w/regression line
rams_mean_plot1 <- ggplot(SSE_pops_rams, aes(x=City_dist, y=Ramets_measured_height)) +
  geom_point(stat="identity", position=position_dodge()) +
  geom_errorbar(aes(ymin=Ramets_measured_height-se, ymax=Ramets_measured_height+se), width = 0.5) +
    geom_smooth(color = "red", method = lm,  se = FALSE) +
  theme(text = element_text(size=14)) +
  labs(x = "Distance to Urban Center (km)",
    y="No. of Ramets")
rams_mean_plot1

## BOXPLOTS
# Reorder so plot's x axis shows pops in dist_cc order
SSE_fams_rams$Population <- reorder(SSE_fams_rams$Population, SSE_fams_rams$City_dist)

ggplot(SSE_fams_rams, aes(x=Population, y=Ramets_measured_height)) + geom_boxplot()

```

### Urban subtransects
```{r}
ggplot(SSE_pops_rams, aes(x=City_dist, y=Ramets_measured_height, color = Transect_ID)) +
  geom_point() +
  geom_smooth(method=lm)


#### subset of only urban subtransects:
SSE_pops_rams_urban <- SSE_pops_rams %>% filter(Transect_ID != 'Rural')

## With error bars
rams_mean_urban_plot1 <- ggplot(SSE_pops_rams_urban, aes(x=City_dist, y=Ramets_measured_height, color= Transect_ID)) + 
  geom_point(aes(colour=Transect_ID, shape=Transect_ID, fill=Transect_ID), size = 3, stat="identity", position=position_dodge()) +
  geom_errorbar(aes(ymin=Ramets_measured_height-se, ymax=Ramets_measured_height+se), width = 0.5) +
    geom_smooth( method = lm, se = F) +
  theme(text = element_text(size=14),
        legend.position = c(0.85, 0.9)) +
  labs(x = "Distance to Urban Center (km)",
    y="No. of Ramets") +
  scale_shape_discrete(name  ="Sample Site Subtransect",
                       breaks = c("North", "South"),
                       labels=c("Urban: Non-Corridor", "Urban: Corridor")) +
  scale_colour_discrete(name  ="Sample Site Subtransect",
                        breaks = c("North", "South"),
                        labels=c("Urban: Non-Corridor", "Urban: Corridor")) +
  scale_fill_discrete(name  ="Sample Site Subtransect",
                        breaks = c("North", "South"),
                        labels=c("Urban: Non-Corridor", "Urban: Corridor"))
rams_mean_urban_plot1

# Violin plot
ggplot(SSE_pops_rams_urban, aes(Transect_ID, Ramets_measured_height)) +
 geom_violin(aes(fill = Transect_ID), trim = FALSE) + 
  geom_boxplot(width = 0.2)+
  scale_fill_manual(values = c("#00AFBB", "#E7B800", "#FC4E07"))+
  stat_compare_means(method = "wilcox.test", label = "p.format", size=6,label.x = 1.5, label.y = 4) +
  theme(text = element_text(size=18),
        legend.position = "none") +
  labs(x = "Subtransect",
    y = "No. of Ramets (per Family)") 

```

## Growth- ignoring for now
## Composite figures
#### All transects
```{r}
library(ggpubr)
Q1_regressions <- ggarrange(heights_mean_plot1, surv_mean_plot1, rams_mean_plot1, herbiv_mean_plot1 + font("x.text"), ncol = 2, nrow = 2, align = "v",labels = c("A", "B", "C", "D"), font.label = list(size=16, color = "black"), common.legend = TRUE, legend = "top")
Q1_regressions

# annotate_figure(Q1_regressions, bottom = text_grob("Distance to Urban Center (km)", size=14))
```

#### Urban subtransects
```{r}
library(ggpubr)
Q2_regressions <- ggarrange(heights_mean_urban_plot1, surv_mean_urban_plot1, herb_mean_urban_plot1, rams_mean_urban_plot1 + font("x.text"), ncol = 2, nrow = 2, align = "v", labels = c("A", "B", "C", "D"), font.label = list(size=16, color = "black"), common.legend = TRUE, legend = "bottom")
Q2_regressions

# annotate_figure(Q2_regressions, bottom = text_grob("Distance to Urban Center (km)", size=14))
```


# Diagnostics (check normality, etc.)
## Herbivory- can't fit a normal distr.
```{r}

### This cool package not installing
# devtools::install_github("neuropsychology/report")
# library("report")

# Alive_sum1 dataset = all alive plants


# copy of lm
diag_herb_1 <- lm(Mean_herbiv ~ Transect_ID * City_dist, data=Alive_sum1)

par(mfrow=c(2,2))
summary(diag_herb_1)
plot(diag_herb_1, na.rm=T)
## Not very randomly distributed

qplot(Alive_sum1$Mean_herbiv, na.rm=T)
summary(Alive_sum1$Mean_herbiv, na.rm=T)
ggqqplot(Alive_sum1$Mean_herbiv, na.rm=T)
## It's extremely right-skewed


# Trying square root transformation
plot(lm(Mean_herbiv^(1/2) ~ Transect_ID * City_dist, data=Alive_sum1), na.rm=T)
## Better but not by much

# Trying cube root
plot(lm(Mean_herbiv^(1/3) ~ Transect_ID * City_dist, data=Alive_sum1), na.rm=T)
## Better but not by much

# Trying log transformation
plot(lm(log(Mean_herbiv+1) ~ Transect_ID * City_dist, data=Alive_sum1), na.rm=T)
## Looks a little better, but still not normal.

### SHOULD I USE A NON-PARAMETRIC TEST HERE???

```

## Height
```{r}
diag_height_1_lm <- lm(Mean_height ~ Transect_ID * City_dist, data=SSE_pops_height)

summary(diag_height_1_lm, na.rm = T)
par(mfrow=c(2,2))
plot(diag_height_1_lm, na.rm = T)
## Looks good.
```

## Survival
```{r}
diag_surv_1_lm <- lm(Pct_Survival_Definite ~ City_dist * Transect_ID, data=SSE_pops_surv)
par(mfrow=c(2,2))
plot(surv_lm_1)
summary(surv_lm_1, na.rm = T)
## Looks good.
```

## Number of Ramets
```{r}
diag_rams_1_lm <- lm(Ramets_measured_height ~ City_dist * Transect_ID, data=SSE_pops_rams)
par(mfrow=c(2,2))
plot(diag_rams_1_lm)
summary(diag_rams_1_lm, na.rm = T)
## Looks good.
```

# ANOVA
## Using mean values per population
### Herbivory
```{r}

##########################################################################################
## CAN'T USE LM BECAUSE DATA CAN'T BE TRANSFORMED TO FIT A NORMAL DISTRIBUTION.
##########################################################################################
##########################################################################################
## SO NOW I'M USING GLM.
##########################################################################################

# Q1
glm((Mean_herbiv/100) ~ City_dist , data = SSE_pops_herb, family = "binomial")
summary(glm((Mean_herbiv/100) ~ City_dist , data = SSE_pops_herb, family = "binomial"))
jj <- car::Anova(glm((Mean_herbiv/100) ~ City_dist , data = SSE_pops_herb, family = "binomial"))
# City_dist not significant.

# Q2
glm((Mean_herbiv/100) ~ City_dist*Transect_ID , data = SSE_pops_herb_urban, family = "binomial")
summary(glm((Mean_herbiv/100) ~ City_dist*Transect_ID  , data = SSE_pops_herb_urban, family = "binomial"))
jk <- car::Anova(glm((Mean_herbiv/100) ~ City_dist *Transect_ID , data = SSE_pops_herb_urban, family = "binomial"))
# interaction not significant, so removing

glm((Mean_herbiv/100) ~ City_dist+Transect_ID , data = SSE_pops_herb_urban, family = "binomial")
summary(glm((Mean_herbiv/100) ~ City_dist+Transect_ID  , data = SSE_pops_herb_urban, family = "binomial"))
car::Anova(glm((Mean_herbiv/100) ~ City_dist+Transect_ID , data = SSE_pops_herb_urban, family = "binomial"))
# both terms not significant

glm((Mean_herbiv/100) ~ City_dist , data = SSE_pops_herb_urban, family = "binomial")
summary(glm((Mean_herbiv/100) ~ City_dist  , data = SSE_pops_herb_urban, family = "binomial"))
jl <- car::Anova(glm((Mean_herbiv/100) ~ City_dist , data = SSE_pops_herb_urban, family = "binomial"))
# City_dist not significant

glm((Mean_herbiv/100) ~ Transect_ID , data = SSE_pops_herb_urban, family = "binomial")
summary(glm((Mean_herbiv/100) ~ Transect_ID  , data = SSE_pops_herb_urban, family = "binomial"))
jm <- car::Anova(glm((Mean_herbiv/100) ~ Transect_ID , data = SSE_pops_herb_urban, family = "binomial"))
# Transect_ID not significant





lsmeans_herb <- lsmeans(glm((Mean_herbiv/100) ~ Transect_ID , data = SSE_pops_herb_urban, family = "binomial"), ~Transect_ID)
lsmeans_herb 
# North has (3.32-3.8)/((3.32+3.8)/2) = 13% less herbivory, on average, than South transect

```

### Height
I think I have the same "story" here as with the lmer tests (nothing significant)
```{r}
# Q1:
summary(lm(Mean_height ~ City_dist, data = SSE_pops_height ))
aa <- car::Anova(lm(Mean_height ~ City_dist, data = SSE_pops_height))
## Just dist_city term: not significant


# Q2:
summary(lm(Mean_height ~ City_dist * Transect_ID, data = SSE_pops_height_urban ))
ab <- car::Anova(lm(Mean_height ~ City_dist * Transect_ID, data = SSE_pops_height_urban))
# A & B plus AxB are not significant, so removing

summary(lm(Mean_height ~ City_dist + Transect_ID, data = SSE_pops_height_urban))
car::Anova(lm(Mean_height ~ City_dist + Transect_ID, data = SSE_pops_height_urban))
## Neither term significant

summary(lm(Mean_height ~ Transect_ID, data = SSE_pops_height_urban ))
ac <- car::Anova(lm(Mean_height ~ Transect_ID, data = SSE_pops_height_urban))
## Just transect term: not significant

summary(lm(Mean_height ~ City_dist, data = SSE_pops_height_urban))
ad <-car::Anova(lm(Mean_height ~ City_dist, data = SSE_pops_height_urban))
## Just city_dist term: not significant



lsmeans_height <- lsmeans(lm(Mean_height ~ Transect_ID, data = SSE_pops_height_urban), ~Transect_ID)
lsmeans_height 
# North has (8-9)/((8+9)/2) = 12% less height, on average, than South transect

```

### Survival
```{r}

### USE GLM BECAUSE IT'S PROPORTION DATA.

# Q1:
summary(glm((Pct_Survival_Definite/100) ~ City_dist, data = SSE_pops_surv, family = "binomial"))
bb <- car::Anova(glm((Pct_Survival_Definite/100) ~ City_dist, data = SSE_pops_surv, family = "binomial"))
## Just dist_city term: not significant


# Q2:
glm((Pct_Survival_Definite/100) ~ City_dist*Transect_ID, data = SSE_pops_surv_urban, family = "binomial")
bc <- car::Anova(glm((Pct_Survival_Definite/100) ~ City_dist*Transect_ID, data = SSE_pops_surv_urban, family = "binomial"))
#  AxB are not significant, so removing

summary(glm((Pct_Survival_Definite/100) ~ City_dist+Transect_ID, data = SSE_pops_surv_urban, family = "binomial"))
car::Anova(glm((Pct_Survival_Definite/100) ~ City_dist+Transect_ID, data = SSE_pops_surv_urban, family = "binomial"))
## Neither term significant

summary(glm((Pct_Survival_Definite/100) ~ Transect_ID, data = SSE_pops_surv_urban, family = "binomial"))
bd <- car::Anova(glm((Pct_Survival_Definite/100) ~ Transect_ID, data = SSE_pops_surv_urban, family = "binomial"))
## Just transect term: not significant

summary(glm((Pct_Survival_Definite/100) ~ City_dist, data = SSE_pops_surv_urban, family = "binomial"))
be <- car::Anova(glm((Pct_Survival_Definite/100) ~ City_dist, data = SSE_pops_surv_urban, family = "binomial"))
## Just city_dist term: not significant


lsmeans_survival <- lsmeans(glm((Pct_Survival_Definite/100) ~ Transect_ID, data = SSE_pops_surv_urban, family = "binomial"), ~Transect_ID)
lsmeans_survival
# North has (2.08-2.03)/((2.08+2.03)/2) = 2% higher survival, on average, than South transect

```

#### OLD- used lm instead of glm
```{r}
# Q1:
# summary(lm(Pct_Survival_Definite ~ City_dist, data = SSE_pops_surv ))
# bb <- car::Anova(lm(Pct_Survival_Definite ~ City_dist, data = SSE_pops_surv))
# ## Just dist_city term: not significant
# 
# 
# # Q2:
# summary(lm(Pct_Survival_Definite ~ City_dist * Transect_ID, data = SSE_pops_surv_urban))
# bc <- car::Anova(lm(Pct_Survival_Definite ~ City_dist * Transect_ID, data = SSE_pops_surv_urban))
# # A & B plus AxB are not significant, so removing
# 
# summary(lm(Pct_Survival_Definite ~ City_dist + Transect_ID, data = SSE_pops_surv_urban))
# car::Anova(lm(Pct_Survival_Definite ~ City_dist + Transect_ID, data = SSE_pops_surv_urban))
# ## Neither term significant
# 
# summary(lm(Pct_Survival_Definite ~ Transect_ID, data = SSE_pops_surv_urban))
# bd <- car::Anova(lm(Pct_Survival_Definite ~ Transect_ID, data = SSE_pops_surv_urban))
# ## Just transect term: not significant
# 
# summary(lm(Pct_Survival_Definite ~ City_dist, data = SSE_pops_surv_urban))
# be <- car::Anova(lm(Pct_Survival_Definite ~ City_dist, data = SSE_pops_surv_urban))
# ## Just city_dist term: not significant

```



### Number of ramets
```{r}

# Q1:
summary(lm(Ramets_measured_height ~ City_dist, data = SSE_pops_rams))
cc <- car::Anova(lm(Ramets_measured_height ~ City_dist, data = SSE_pops_rams))
## Just dist_city term: not significant


# Q2:
summary(lm(Ramets_measured_height ~ City_dist * Transect_ID, data = SSE_pops_rams_urban))
cd <- car::Anova(lm(Ramets_measured_height ~ City_dist * Transect_ID, data = SSE_pops_rams_urban))
# A & B plus AxB are not significant, so removing

summary(lm(Ramets_measured_height ~ City_dist + Transect_ID, data = SSE_pops_rams_urban))
car::Anova(lm(Ramets_measured_height ~ City_dist + Transect_ID, data = SSE_pops_rams_urban))
## Neither term significant

summary(lm(Ramets_measured_height ~ Transect_ID, data = SSE_pops_rams_urban))
ce <- car::Anova(lm(Ramets_measured_height ~ Transect_ID, data = SSE_pops_rams_urban))
## Just transect term: not significant

summary(lm(Ramets_measured_height ~ City_dist, data = SSE_pops_rams_urban))
cf <- car::Anova(lm(Ramets_measured_height ~ City_dist, data = SSE_pops_rams_urban))
## Just city_dist term: not significant



lsmeans_num.ramets <- lsmeans(lm(Ramets_measured_height ~ Transect_ID, data = SSE_pops_rams_urban), ~Transect_ID)
lsmeans_num.ramets
# North has (2.07-1.89)/((2.07+1.89/2) = 6% more ramets, on average, than South transect

```

### Export all ANOVA outputs to CSV
```{r}

# herbivory- NEW GLM- 4/1
# Q1: jj (no. ram ~ Dist_city)
# Q2: jk (no. ram  ~ Dist_city * subtransect)
# Q2: jl (no. ram  ~  subtransect)
# Q2: jm (no. ram  ~ Dist_city)
write.csv(rbind(jj, jk, jl, jm), "ANOVAs_herbivory_1.csv")


# cumulative ramet length- OLD 3/31- LM
# Q1: aa (CRL ~ Dist_city)
# Q2: ab (CRL ~ Dist_city * subtransect)
# Q2: ac (CRL ~  subtransect)
# Q2: ad (CRL ~ Dist_city)
write.csv(rbind(aa, ab, ac, ad), "ANOVAs_height_1.csv")


# survival- NEW 4/1- GLM
# Q1: bb (surv ~ Dist_city)
# Q2: bc (surv ~ Dist_city * subtransect)
# Q2: bd (surv ~  subtransect)
# Q2: be (surv ~ Dist_city)
write.csv(rbind(bb, bc, bd, be), "ANOVAs_survival_1.csv")


# no. of ramets- OLD 3/31- LM
# Q1: cc (no. ram ~ Dist_city)
# Q2: cd (no. ram  ~ Dist_city * subtransect)
# Q2: ce (no. ram  ~  subtransect)
# Q2: cf (no. ram  ~ Dist_city)
write.csv(rbind(cc, cd, ce, cf), "ANOVAs_numberoframets_1.csv")

```

## Using linear mixed models
### Creating new column that has unique family identifier
```{r}
Data$Family_unique <- paste(Data$Population, "-", Data$Family)

Alive_sum1$Family_unique <- paste(Alive_sum1$Population, "-", Alive_sum1$Family)

Alive_sum1_urban$Family_unique <- paste(Alive_sum1_urban$Population, "-", Alive_sum1_urban$Family)

Alive_sum1_urban$Family_unique <- as.factor(Alive_sum1_urban$Family_unique)
```

### Herbivory- only on alive plant dataset- "same story" as lm- nothing significant
```{r}
# most complex model
# model_herb1 <- lmer(Mean_herbiv ~  (1|Block) + (1|Population/Family) + (1|Monarch_dam) + (1|Deer_dam) + (1|Exp_rhiz_binary) + Transect_ID + City_dist, data=Alive_sum1, REML = T)
# summary(model_herb1)
# ranova(model_herb1)
# # issingular
# # p-values for deer damage and exposed rhizomes both = 1, so removing those
# 
# model_herb2 <- lmer(Mean_herbiv ~  (1|Block) + (1|Population/Family) + (1|Monarch_dam) + (1|Deer_dam) + (1|Exp_rhiz_binary) + Transect_ID + City_dist, data=Alive_sum1, REML = T)
# summary(model_herb2)
# ranova(model_herb2)
# ## this has a lower AIC score than model 1- the only difference is that I didn't explicity nest family within population- so from here forward I'll nest them as in model1.
# 
# model_herb3 <- lmer(Mean_herbiv ~ (1|Block) +  (1|Population/Family) + (1|Monarch_dam) + Transect_ID + City_dist, data=Alive_sum1, REML = T)
# summary(model_herb3)
# ranova(model_herb3)
# # monarch damage p = 1 now, so removing that

########################################################
###### USING THIS FOR MY APPRAISAL REPORT RESULTS ######
########################################################

# Ruth advised me to use a quasibinomial distribution (family) but that only works with glm (not glmer), so she said binomial is - safine. Q-bin is a specific type of binomial distr anyway.

# Make new columns that treat mean herbivory as a decimal:
Alive_sum1$Mean_herbiv_dec <- Alive_sum1$Mean_herbiv/100
Alive_sum1_urban$Mean_herbiv_dec <- Alive_sum1_urban$Mean_herbiv/100

# should I add link = "logit" here?? didn't make a difference in the summary...

# Q1: ALL DATA
model_herb4 <- glmer(Mean_herbiv_dec ~ (1|Block) + (1|Population/Family) + City_dist, data=Alive_sum1, family = "binomial")
gg <- summary(model_herb4)
# City_dist not sig
oo <- car::Anova(model_herb4)
# transect*city_dist interaction not sig (0.57) so removing that term



# Q2: ONLY URBAN SUBTRANSECT SUBPOPULATIONS
model_herb5 <- glmer(Mean_herbiv_dec ~ (1|Block) + (1|Population/Family) + Transect_ID * City_dist, data=Alive_sum1_urban, family = "binomial")
gh <- summary(model_herb5)
# Interaction not significant; will remove it

# ranova(model_herb5)
op <- car::Anova(model_herb5)

model_herb6 <- glmer(Mean_herbiv_dec ~ (1|Block) + (1|Population/Family) + Transect_ID + City_dist, data=Alive_sum1_urban, family = "binomial")
summary(model_herb6)
# Neither main effect sig

# ranova(model_herb6)
# car::Anova(model_herb6)

model_herb7 <- glmer(Mean_herbiv_dec ~ (1|Block) + (1|Population/Family) + City_dist, data=Alive_sum1_urban, family = "binomial")
gi <- summary(model_herb7)
# City_dist not sig

# ranova(model_herb7)
oq <- car::Anova(model_herb7)

model_herb8 <- glmer(Mean_herbiv_dec ~ (1|Block) + (1|Population/Family) + Transect_ID, data=Alive_sum1_urban, family = "binomial")
gj <- summary(model_herb8)
# Transect_ID not sig

# ranova(model_herb6)
or <-  car::Anova(model_herb8)





# # Look at variance among families
# car::Anova(glm((Mean_herbiv/100) ~ Family_unique, data=Alive_sum1, family = "binomial"))
# 
# # Look at variance among populations
# car::Anova(glm((Mean_herbiv/100) ~ Population, data=Alive_sum1, family = "binomial"))
# 

ranova(lmer((Mean_herbiv/100) ~ (1|Population/Family), data=Alive_sum1))
summary(lmer((Mean_herbiv/100) ~ (1|Population/Family), data=Alive_sum1))

```

#### Trying out changing block to fixed and unnesting
```{r}
# NO CHANGE
trial1 <- glmer(Mean_herbiv_dec ~ (1|Block) + (1|Population/Family) + City_dist, data=Alive_sum1, family = "binomial")
summary(trial1)
car::Anova(trial1)
# isSingular
# summary: std devs and variances are basically 0
# AIC: 101.2


# BLOCK TO FIXED
trial2 <- glmer(Mean_herbiv_dec ~ (1|Population/Family) + City_dist + Block, data=Alive_sum1, family = "binomial")
summary(trial2)
car::Anova(trial2)
# isSingular
# summary: std devs and variances are basically 0
# AIC: 99.2


# UNNESTING POP/FAM
trial3 <- glmer(Mean_herbiv_dec ~ (1|Block) + (1|Population:Family) + City_dist, data=Alive_sum1, family = "binomial")
summary(trial3)
car::Anova(trial3)
# isSingular
# summary: std devs and variances are basically 0
# AIC: 99.2

# BLOCK TO FIXED + UNNESTING POP/FAM
trial4<- glmer(Mean_herbiv_dec ~ (1|Population:Family) + City_dist + Block, data=Alive_sum1, family = "binomial")
summary(trial4)
car::Anova(trial4)
# isSingular
# summary: std devs and variances are basically 0
# AIC: 97.2



####### ALL IN ALL:
# p-values for each anova very similar
# AIC score lowest for trial 4 (unnested pop/fam and fixed blocks)
```


#### Trying to remove pop from model and make block fixed
```{r}
# Q1: ALL DATA
model_herb1_no.pop <- glmer(Mean_herbiv_dec ~ Block + (1|Family_unique) + City_dist, data=Alive_sum1, family = "binomial")
summary(model_herb1_no.pop)
car::Anova(model_herb1_no.pop)
# STILL SINGULAR.

```

#### Trying to do analysis w/family means
```{r}

SSE_fams_herb$Mean_herbiv_dec <- SSE_fams_herb$Mean_herbiv/100

SSE_fams_herb$Family_unique <- paste(SSE_fams_herb$Population, "-", SSE_fams_herb$Family)

SSE_fams_herb$Family_unique <- as.factor(SSE_fams_herb$Family_unique)

# Q1: ALL DATA
model_herb1_fams <- glmer(Mean_herbiv_dec ~ (1|Family_unique), data=SSE_fams_herb, family = "binomial")
summary(model_herb1_fams)
car::Anova(model_herb1_fams)
# STILL SINGULAR.

# ______________________

# Trying w/logit  log(p/(1-p))

lmer(log(Mean_herbiv_dec+1/(1-Mean_herbiv_dec)) ~ (1|Population) + City_dist, data=SSE_fams_herb)
# Still singular

```

### Height- only on alive plant dataset- "same story" as lm- nothing significant
#### NEW- block is fixed effect and pop:fam
```{r}
###### USING THIS FOR MY APPRAISAL REPORT RESULTS ######

# Q1: ALL DATA
model_height1 <- lmer(Mean_height ~ Block + (1|Population:Family) + City_dist, data=Alive_sum1, REML = T)
hh <- summary(model_height1)
rr <- car::Anova(model_height1)
# City_dist MARGINALLY sig (P = 0.081)


# Q2: ONLY URBAN SUBTRANSECT SUBPOPULATIONS
model_height2 <- lmer(Mean_height ~  Block + (1|Population:Family) + Transect_ID * City_dist, data = Alive_sum1_urban, REML = T)
hi <- summary(model_height2)
rs <- car::Anova(model_height2)
# Interaction not significant

model_height3 <- lmer(Mean_height ~ Block + (1|Population:Family) + Transect_ID + City_dist, data = Alive_sum1_urban, REML = T, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(model_height3)
car::Anova(model_height3)
# transect and city_dist not sig

model_height4 <- lmer(Mean_height ~ Block + (1|Population:Family) + City_dist, data = Alive_sum1_urban, REML = T)
hj <- summary(model_height4)
rt <- car::Anova(model_height4)
# City_dist not significant

model_height5 <- lmer(Mean_height ~ Block + (1|Population:Family) + Transect_ID, data = Alive_sum1_urban, REML = T)
hk <- summary(model_height5)
ru <- car::Anova(model_height5)
# Transect not significant




# 
# # Look at variance among families
# car::Anova(lm(Mean_height ~ Family_unique, data=Alive_sum1))
# 
# # Look at variance among populations
# car::Anova(lm(Mean_height ~ Population, data=Alive_sum1))


ranova(lmer(Mean_height ~ (1|Population/Family), data=Alive_sum1))
summary(lmer(Mean_height ~ (1|Population/Family), data=Alive_sum1))
```

#### OLD- block was random effect and pop/fam nested
```{r}
# ###### USING THIS FOR MY APPRAISAL REPORT RESULTS ######
# 
# # Q1: ALL DATA
# model_height1 <- lmer(Mean_height ~  (1|Block) + (1|Population/Family) + City_dist, data=Alive_sum1, REML = T)
# hh <- summary(model_height1)
# # ranova(model_height1)
# rr <- car::Anova(model_height1)
# # City_dist not sig
# 
# 
# # Q2: ONLY URBAN SUBTRANSECT SUBPOPULATIONS
# model_height2 <- lmer(Mean_height ~  (1|Block) + (1|Population/Family) + Transect_ID * City_dist, data = Alive_sum1_urban, REML = T)
# hi <- summary(model_height2)
# # ranova(model_height2)
# rs <- car::Anova(model_height2)
# # Interaction not significant
# 
# model_height3 <- lmer(Mean_height ~ (1|Block) + (1|Population/Family) + Transect_ID + City_dist, data = Alive_sum1_urban, REML = T, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# summary(model_height3)
# # ranova(model_height3)
# car::Anova(model_height3)
# # MODEL IS SINGULAR...
# ## TRYING MAIN EFFECTS SEPARATELY
# 
# model_height4 <- lmer(Mean_height ~ (1|Block) + (1|Population/Family) + City_dist, data = Alive_sum1_urban, REML = T)
# hj <- summary(model_height4)
# # ranova(model_height4)
# rt <- car::Anova(model_height4)
# # City_dist not significant
# 
# model_height5 <- lmer(Mean_height ~ (1|Block) + (1|Population/Family) + Transect_ID, data = Alive_sum1_urban, REML = T)
# hk <- summary(model_height5)
# # ranova(model_height5)
# ru <- car::Anova(model_height5)
# # Transect not significant- 
```

##### Using INCORRECTLY transformed data (Mean_height_sqrt)- DON'T USE
```{r}
###### USING THIS FOR MY APPRAISAL REPORT RESULTS ###### 
# model_height1 <- lmer(Mean_height_sqrt ~ (1|Block) + (1|Population/Family) + Transect_ID * City_dist, data=Alive_sum1, REML = T,
#                       lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# summary(model_height1)
# ranova(model_height1)
# car::Anova(model_height1)
# # NOT CONVERGING if I don't use the optimizer (but I am, so it's fine)
# # transect*city_dist interaction not sig (0.60) so removing that term
# 
# model_height2 <- lmer(Mean_height_sqrt ~  (1|Block) + (1|Population/Family) + Transect_ID + City_dist, data=Alive_sum1, REML = T)
# summary(model_height2)
# ranova(model_height2)
# car::Anova(model_height2)
# # Neither term significant
# # Varied among blocks significantly though
# 
# model_height3 <- lmer(Mean_height_sqrt ~  (1|Block) + (1|Population/Family) + City_dist, data=Alive_sum1, REML = T)
# summary(model_height3)
# ranova(model_height3)
# car::Anova(model_height3)
# # city_dist not significant
```

###### Quick look at how blocks varied, as boxplot
```{r}
### I DON'T THINK THIS IS VALID THOUGH- EACH DATA POINT ASSUMED TO BE INDEPENDENT HERE, AND IN FACT THEY ARE NESTED/HIERARCHICAL
ggplot(Alive_sum1, aes(x=Block, y=Mean_height_sqrt)) + 
  geom_boxplot(outlier.colour="red", outlier.shape=8,
                outlier.size=4)



## Try finding population means by block
# Find population means
pops_height_byblock <- ddply(Herbiv_df, .(Population, Block), summarise,
    sum_fams = n_distinct(Family),
    sum_replicates = n_distinct(Replicate),
    mean_height = mean(Mean_height),
    sum_height = sum(Ramets_measured_height),
    mean_herbiv = mean(Mean_herbiv, na.rm=T),
    sum_herbiv = sum(Ramets_measured_herbiv),
    dist_cc = first(City_dist),
    transect = first(Transect_ID))

SSE_pops_height_byblock <- summarySE(Herbiv_df, measurevar="Mean_height", groupvars=c("Population", "Block"), na.rm=TRUE)

# Box plot
ggplot(SSE_pops_height_byblock, aes(x=Block, y=Mean_height)) + 
  geom_boxplot(outlier.colour="red", outlier.shape=8, outlier.size=4)
## Block 3 does seem like it has a smaller spread than the other blocks, plus a higher mean
### All blocks have a pretty normal distribution (not very skewed)

# Find block means
pops_height_byblock_perblock <- ddply(Herbiv_df, .(Block), summarise,
    sum_pops = n_distinct(Population),
    sum_fams = n_distinct(Family),
    sum_replicates = n_distinct(Replicate),
    mean_height = mean(Mean_height),
    sum_height = sum(Ramets_measured_height),
    mean_herbiv = mean(Mean_herbiv, na.rm=T),
    sum_herbiv = sum(Ramets_measured_herbiv),
    dist_cc = first(City_dist),
    transect = first(Transect_ID))
## Each block has nearly the same number of populations (Range = 48-51 pops/block)

```

### Survival
#### New format
```{r}
###### USING THIS FOR MY APPRAISAL REPORT RESULTS ######

# Q1: ALL DATA
model_survival1 <- glmer(Dead_DC3 ~  Block + (1|Population:Family) + City_dist, data=Data, family = "binomial", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(model_survival1)
ss <- car::Anova(model_survival1)
## City_dist not sig


# Q2: ONLY URBAN SUBTRANSECT SUBPOPULATIONS
model_survival2 <- glmer(Dead_DC3 ~  Block + (1|Population:Family) + City_dist*Transect_ID, data=Data_urban, family = "binomial", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(model_survival2)
st <- car::Anova(model_survival2)
# Interaction not sig

model_survival3 <- glmer(Dead_DC3 ~  Block + (1|Population:Family) + City_dist + Transect_ID, data=Data_urban, family = "binomial", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(model_survival3)
car::Anova(model_survival3)
# Nothing sig

model_survival4 <- glmer(Dead_DC3 ~  Block + (1|Population:Family) + City_dist, data=Data_urban, family = "binomial", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(model_survival4)
su <- car::Anova(model_survival4)
# Nothing sig

model_survival5 <- glmer(Dead_DC3 ~  Block + (1|Population:Family) + Transect_ID, data=Data_urban, family = "binomial", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(model_survival5)
sv <- car::Anova(model_survival5)
# Nothing sig







# # Look at variance among families
# car::Anova(glm(Dead_DC3 ~ Family_unique, data=Data, family = "binomial"))
# 
# # Look at variance among populations
# car::Anova(glm(Dead_DC3 ~ Population, data=Data, family = "binomial"))
# 

ranova(lmer(as.numeric(Dead_DC3) ~ (1|Population/Family), data=Data))
summary(lmer(as.numeric(Dead_DC3) ~ (1|Population/Family), data=Data))

```

#### Old format- pop/family nested + block is random effect- ALL MODELS ARE SINGULAR...
```{r}
# ###### USING THIS FOR MY APPRAISAL REPORT RESULTS ######
# 
# # Q1: ALL DATA
# model_ramets1 <- lmer(Ramets_measured_height ~  (1|Block) + (1|Population/Family) + City_dist, data=Alive_sum1, REML = T, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# summary(model_ramets1)
# # ranova(model_ramets1)
# car::Anova(model_ramets1)
# ## ISSINGULAR... ???
# 
# 
# # Q2: ONLY URBAN SUBTRANSECT SUBPOPULATIONS
# model_ramets2 <- lmer(Ramets_measured_height ~  (1|Block) + (1|Population/Family) + Transect_ID * City_dist, data = Alive_sum1_urban, REML = T, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# summary(model_ramets2)
# ## ISSINGULAR... ???
# 
# # ranova(model_ramets2)
# car::Anova(model_ramets2)
# 
# 
# model_ramets3 <- lmer(Ramets_measured_height ~ (1|Block) + (1|Population/Family) + Transect_ID + City_dist, data = Alive_sum1_urban, REML = T, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# summary(model_ramets3)
# ## ISSINGULAR... ???
# 
# # ranova(model_ramets3)
# car::Anova(model_ramets3)
# 
# 
# model_ramets4 <- lmer(Ramets_measured_height ~ (1|Block) + (1|Population/Family) + City_dist, data = Alive_sum1_urban, REML = T, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# summary(model_ramets4)
# ## ISSINGULAR... ???
# 
# # ranova(model_ramets4)
# car::Anova(model_ramets4)
# # City_dist not significant
# 
# model_ramets5 <- lmer(Ramets_measured_height ~ (1|Block) + (1|Population/Family) + Transect_ID, data = Alive_sum1_urban, REML = T, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# summary(model_ramets5)
# ## ISSINGULAR... ???
# 
# # ranova(model_ramets5)
# car::Anova(model_ramets5)
# # Transect not significant
```

### Number of ramets
```{r}
###### USING THIS FOR MY APPRAISAL REPORT RESULTS ######

# Q1: ALL DATA
model_ramets1 <- glmer(Alive_ram ~  Block + (1|Population:Family) +  City_dist, data=Alive_sum1, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(model_ramets1)
tt <- car::Anova(model_ramets1)
# Nothing sig



# Q2: ONLY URBAN SUBTRANSECT SUBPOPULATIONS
model_ramets2 <-  glmer(Alive_ram ~  Block + (1|Population:Family) +  City_dist*Transect_ID, data=Alive_sum1_urban, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(model_ramets2)
tu <- car::Anova(model_ramets2)
# Nothing sig

model_ramets3 <-  glmer(Alive_ram ~  Block + (1|Population:Family) +  City_dist + Transect_ID, data=Alive_sum1_urban, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(model_ramets3)
car::Anova(model_ramets3)
# Nothing sig

model_ramets4 <- glmer(Alive_ram ~  Block + (1|Population:Family) + Transect_ID, data=Alive_sum1_urban, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(model_ramets4)
tv <- car::Anova(model_ramets4)
# Nothing sig

model_ramets5 <- glmer(Alive_ram ~  Block + (1|Population:Family) +  City_dist, data=Alive_sum1_urban, family = "poisson", glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
summary(model_ramets5)
tw <- car::Anova(model_ramets5)
# Nothing sig





# 
# # Look at variance among families
# car::Anova(glm(Alive_ram ~ Family_unique, data=Alive_sum1, family = "poisson"))
# 
# # Look at variance among populations
# car::Anova(glm(Alive_ram ~ Population, data=Alive_sum1, family = "poisson"))

ranova(lmer(Alive_ram ~ (1|Population/Family), data=Alive_sum1, REML = TRUE))
summary(lmer(Alive_ram ~ (1|Population/Family), data=Alive_sum1, REML = TRUE))
```

#### OLD- used block as random effect and pop/fam
```{r}
# ###### USING THIS FOR MY APPRAISAL REPORT RESULTS ######
# 
# # Q1: ALL DATA
# model_ramets1 <- lmer(Alive_ram ~  (1|Block) + (1|Population/Family) +  City_dist, data=Alive_sum1, REML = T, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# summary(model_ramets1)
# # ranova(model_ramets1)
# car::Anova(model_ramets1)
# ## ISSINGULAR... ???
# 
# 
# # Q2: ONLY URBAN SUBTRANSECT SUBPOPULATIONS
# model_ramets2 <- lmer(Alive_ram ~ (1|Block) + (1|Population/Family) + Transect_ID * City_dist, data=Alive_sum1_urban, REML = T, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# summary(model_ramets2)
# # ranova(model_ramets2)
# car::Anova(model_ramets2)
# ## ISSINGULAR... ???
# 
# model_ramets3 <- lmer(Alive_ram ~  (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data=Alive_sum1_urban, REML = T, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# summary(model_ramets3)
# # ranova(model_ramets3)
# car::Anova(model_ramets3)
# ## ISSINGULAR... ???
# 
# model_ramets4 <- lmer(Alive_ram ~  (1|Block) + (1|Population/Family) + Transect_ID, data=Alive_sum1_urban, REML = T, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# summary(model_ramets4)
# # ranova(model_ramets4)
# car::Anova(model_ramets4)
# ## ISSINGULAR... ???
# 
# model_ramets5 <- lmer(Alive_ram ~  (1|Block) + (1|Population/Family) + City_dist, data=Alive_sum1_urban, REML = T, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# summary(model_ramets5)
# # ranova(model_ramets5)
# car::Anova(model_ramets5)
# ## ISSINGULAR... ???
```

### Export all ANOVA outputs to CSV
```{r}
######### herbivory- NO MODELS WORKING FOR (G)LMER SO NOT EXPORTING ANYTHING. ######### 
# Q1: oo (CRL ~ Dist_city + random effects...)
# Q2: op (CRL ~ Dist_city * subtransect...)
# Q2: oq (CRL ~ subtransect...)
# Q2: or (CRL ~ Dist_city...)

# # Now export to txt
# out<-capture.output(oo)
# cat(out,file="ANOVA_lmer_herbiv.txt",sep="\n",append=TRUE)
# out<-capture.output(op)
# cat(out,file="ANOVA_lmer_herbiv.txt",sep="\n",append=TRUE)
# out<-capture.output(oq)
# cat(out,file="ANOVA_lmer_herbiv.txt",sep="\n",append=TRUE)
# out<-capture.output(or)
# cat(out,file="ANOVA_lmer_herbiv.txt",sep="\n",append=TRUE)





# cumulative ramet length
# Q1: rr (CRL ~ Dist_city + random effects...)
# Q2: rs (CRL ~ Dist_city * subtransect...)
# Q2: rt (CRL ~ subtransect...)
# Q2: ru (CRL ~ Dist_city...)

# Now export to txt
out<-capture.output(rr)
cat(out,file="lmer_heights.txt",sep="\n",append=TRUE)
out<-capture.output(rs)
cat(out,file="lmer_heights.txt",sep="\n",append=TRUE)
out<-capture.output(rt)
cat(out,file="lmer_heights.txt",sep="\n",append=TRUE)
out<-capture.output(ru)
cat(out,file="lmer_heights.txt",sep="\n",append=TRUE)





# survival
# Q1: ss (surv ~ Dist_city + random effects...)
# Q2: st (surv ~ Dist_city * subtransect...)
# Q2: su (surv ~ subtransect...)
# Q2: sv (surv ~ Dist_city...)

# Now export to txt
out<-capture.output(ss)
cat(out,file="lmer_survival.txt",sep="\n",append=TRUE)
out<-capture.output(st)
cat(out,file="lmer_survival.txt",sep="\n",append=TRUE)
out<-capture.output(su)
cat(out,file="lmer_survival.txt",sep="\n",append=TRUE)
out<-capture.output(sv)
cat(out,file="lmer_survival.txt",sep="\n",append=TRUE)




# no. ramets
# Q1: tt (surv ~ Dist_city + random effects...)
# Q2: tu (surv ~ Dist_city * subtransect...)
# Q2: tv (surv ~ subtransect...)
# Q2: tw (surv ~ Dist_city...)

# Now export to txt
out<-capture.output(tt)
cat(out,file="lmer_numramets.txt",sep="\n",append=TRUE)
out<-capture.output(tu)
cat(out,file="lmer_numramets.txt",sep="\n",append=TRUE)
out<-capture.output(tv)
cat(out,file="lmer_numramets.txt",sep="\n",append=TRUE)
out<-capture.output(tw)
cat(out,file="lmer_numramets.txt",sep="\n",append=TRUE)



```

#### SUMMARIES- NOT USING ANYMORE
```{r}
# herbivory
# Q1: gg (CRL ~ Dist_city + random effects...)
# Q2: gh (CRL ~ Dist_city * subtransect...)
# Q2: gi (CRL ~ subtransect...)
# Q2: gj (CRL ~ Dist_city...)

# Now export to txt
# out<-capture.output(gg)
# cat(out,file="lmer_herbiv.txt",sep="\n",append=TRUE)
# out<-capture.output(gh)
# cat(out,file="lmer_herbiv.txt",sep="\n",append=TRUE)
# out<-capture.output(gi)
# cat(out,file="lmer_herbiv.txt",sep="\n",append=TRUE)
# out<-capture.output(gj)
# cat(out,file="lmer_herbiv.txt",sep="\n",append=TRUE)


# cumulative ramet length
# Q1: hh (CRL ~ Dist_city + random effects...)
# Q2: hi (CRL ~ Dist_city * subtransect...)
# Q2: hj (CRL ~ subtransect...)
# Q2: hk (CRL ~ Dist_city...)

# Now export to txt
# out<-capture.output(hh)
# cat(out,file="lmer_heights.txt",sep="\n",append=TRUE)
# out<-capture.output(hi)
# cat(out,file="lmer_heights.txt",sep="\n",append=TRUE)
# out<-capture.output(hj)
# cat(out,file="lmer_heights.txt",sep="\n",append=TRUE)
# out<-capture.output(hk)
# cat(out,file="lmer_heights.txt",sep="\n",append=TRUE)



# survival- NOT DONE BECAUSE ALL MODELS SINGULAR
# Q1: bb (surv ~ Dist_city + random effects...)
# Q2: bc (surv ~ Dist_city * subtransect)
# Q2: bd (surv ~  subtransect)
# Q2: be (surv ~ Dist_city)
# write.csv(rbind(bb, bc, bd, be), "ANOVAs_survival.csv")

# no. of ramets- NOT DONE BECAUSE ALL MODELS SINGULAR
# Q1: cc (no. ram ~ Dist_city + random effects...)
# Q2: cd (no. ram  ~ Dist_city * subtransect)
# Q2: ce (no. ram  ~  subtransect)
# Q2: cf (no. ram  ~ Dist_city)
# write.csv(rbind(cc, cd, ce, cf), "ANOVAs_numberoframets.csv")

```

# Unused code- stepAIC
```{r}
# make df with only variables relevant to model selection, then try stepAIC
## THE PROBLEM IS that stepAIC can't analyze random effects, so this seems moot
# relevant_vars <- Alive_sum1[,c(1,4,5,12:18,23,24)]
# sum(is.na(relevant_vars))
# relevant_vars = na.omit(relevant_vars)
# relvars.lm <- lm(Mean_herbiv ~., data = relevant_vars)
# step <- stepAIC(relvars.lm, direction = "both")
# step

```