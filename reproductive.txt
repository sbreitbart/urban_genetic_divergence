## reproductive
### Plants that flowered
#### Flowering success
##### Sig difference between urb vs rural? (Odds ratio)
```{r}
# # How many plants flowered per subtransect? using 2019 alive plants
# tib1 <- reproductive %>%
#   filter(Alive_DC1 != '0')%>%
#   group_by(Flowered2020, Urb_Rur) %>%
#   tally()
# tib1
# 
# 
# Flowered_ttest <- matrix(c(21, 3, 556, 282), nrow = 2,
#                          dimnames = list(
#                            c("Urban", "Rural"),
#                            c("Flowered", "Didn't Flower")))
# 
# fisher.test(Flowered_ttest, alternative = "two.sided")
# # odds ratio = 3.5464
# # p = 0.02859
# # medium effect size


# How many plants flowered per subtransect? using 2020 alive plants

tib2 <- reproductive %>%
  filter(Alive_DC1 == 1) %>%
  group_by(Flowered2020, Urb_Rur) %>%
  tally()
tib2


Flowered_ttest2 <- matrix(c(
  as.integer(tib2[2,3]),
  as.integer(tib2[4,3]),
  as.integer(tib2[4,3]),
  as.integer(tib2[3,3])),
  nrow = 2,
  dimnames = list(
    c("Rural", "Urban"),
    c("Flowered", "Didn't Flower")))

fisher.test(Flowered_ttest2, alternative = "two.sided")
# odds ratio = 3.761
# p = 0.0655
# Medium effect size

chisq.test(Flowered_ttest2)
# X-squared = 3.823, df = 1, p-value = 0.05055





# How many populations had at least one plant flower per subtransect? using 2020 alive plants

tib3 <- reproductive %>%
  group_by(Population, Flowered2020, Urb_Rur) %>%
  dplyr::summarise(Pops = n_distinct(Population),
                   Urb_Rur = first(Urb_Rur)) %>%
  group_by(Population, Urb_Rur) %>%
  dplyr::summarise(Flowered = sum(as.integer(Flowered2020)),
                   Urb_Rur = first(Urb_Rur)) %>%
  group_by(Urb_Rur, Flowered) %>%
  dplyr::summarise(Pops = n_distinct(Population))
  
tib3
# Flowered = 1: Flowered
# Flowered = 0: Didn't flower



Flowered_ttest3 <- matrix(c(
  as.integer(tib3[2,3]),
  as.integer(tib3[4,3]),
  as.integer(tib3[4,3]),
  as.integer(tib3[3,3])),
  nrow = 2,
  dimnames = list(
    c("Rural", "Urban"),
    c("Flowered", "Didn't Flower")))

fisher.test(Flowered_ttest3, alternative = "two.sided")
# odds ratio = 0.5064
# p = 0.5034
# Medium effect size


chisq.test(Flowered_ttest3)
# X-squared = 0.3782, df = 1, p-value = 0.5386
```



##### Sig difference between urb:north vs urb:south? (Odds ratio)
```{r}
# How many plants flowered per subtransect? using 2020 alive plants

tib4 <- reproductive %>%
  filter(., Transect_ID != 'Rural') %>%
  group_by(Flowered2020, Transect_ID) %>%
  tally()
tib4


Flowered_ttest4 <- matrix(c(
  as.integer(tib4[3,3]),
  as.integer(tib4[4,3]),
  as.integer(tib4[1,3]),
  as.integer(tib4[2,3])),
  nrow = 2,
  dimnames = list(
    c("North", "South"),
    c("Flowered", "Didn't Flower"))) %T>%
  print()

fisher.test(Flowered_ttest4, alternative = "two.sided")
# odds ratio = 0.782
# p = 0.660 (CAN'T REJECT THE NULL)
# negligible effect size

chisq.test(Flowered_ttest4)
# X-squared = 0.081128, df = 1, p-value = 0.7758






# How many populations had at least one plant flower per subtransect? using 2020 alive plants

tib5 <- reproductive %>%
  filter(., Transect_ID != "Rural") %>%
  group_by(Population, Flowered2020, Transect_ID) %>%
  dplyr::summarise(Pops = n_distinct(Population),
                   Transect_ID = first(Transect_ID)) %>%
  group_by(Population, Transect_ID) %>%
  dplyr::summarise(Flowered = sum(as.integer(Flowered2020)),
                   Transect_ID = first(Transect_ID)) %>%
  group_by(Transect_ID, Flowered) %>%
  dplyr::summarise(Pops = n_distinct(Population))
  
tib5
# Flowered = 0: Didn't flower
# Flowered = 1: Did flower



Flowered_ttest5 <- matrix(c(
  as.integer(tib5[1,3]),
  as.integer(tib5[3,3]),
  as.integer(tib5[2,3]),
  as.integer(tib5[4,3])),
  nrow = 2,
  dimnames = list(
    c("North", "South"),
    c("Didn't Flower", "Flowered"))) %T>%
  print()

fisher.test(Flowered_ttest5, alternative = "two.sided")
# odds ratio = 0.851
# p = 1 (NOT SIGNIFICANT; CAN'T REJECT NULL)
# small effect size

chisq.test(Flowered_ttest5)
# X-squared = 0.41878, df = 1, p-value = 0.5175
```


##### Block effect?
```{r}
glmer(Flowered2020 ~ Block + (1|Population/Family),
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=1,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))

car::Anova(glmer(Flowered2020 ~ Block + (1|Population/Family),
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=1,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# Block is significant, so yes, the number of plants that flowered DID significantly vary by block.

summary(glmer(Flowered2020 ~ Block + (1|Population/Family),
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=1,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
```

#### Flower count: HOLD OFF until 2021- too few plants and will probably overfit all models
##### Mean flower count/inflorescence
###### Sig difference along gradient?
####### glmer: diagnostics (No)
```{r}
flowercount_2020_lmer_gradient <- glmmTMB(mean_flower_count ~
                                          (1|Block) +
                                          (1|Population/Family) +
                                          City_dist, 
                                        data = flowering_2020,
                                        family = nbinom1())
res <- simulateResiduals(flowercount_2020_lmer_gradient)
plot(res)
testDispersion(flowercount_2020_lmer_gradient)
hist(flowering_2020$mean_flower_count, breaks = 20)


```

####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----

# ANOVA
car::Anova(flowercount_2020_lmer_gradient)
# distance is not sig

# library(MuMIn) # Multi-Model Inference # Multi-Model Inference # Multi-Model Inference
# r.squaredGLMM(flowercount_2020_lmer_gradient)


# ### CROSSED RANDOM EFFECTS-----
# lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F)
# # singular
# 
# car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F))
# # distance is sig
# 
# 
# # ANy variation among families or populations?
# ranova(lmer(mean_flower_count ~ (1|Population/Family), data = flowering_2020, REML = T))
# # no... is singular
```

####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
flowercount_2020_lmer_gradient_urbscore <- lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
# is singular

# ANOVA
car::Anova(flowercount_2020_lmer_gradient_urbscore)
# sig

library(MuMIn) # Multi-Model Inference # Multi-Model Inference # Multi-Model Inference
r.squaredGLMM(flowercount_2020_lmer_gradient_urbscore)


### CROSSED RANDOM EFFECTS-----
lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F))
#  sig

```

##### Sig difference btwn urban subtransects?
###### lmer: *NO: Nothing sig for city_dist or urb_score
###### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
flowercount_2020_lmer_subtr <- lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(flowercount_2020_lmer_subtr)
# nothing sig
AIC(flowercount_2020_lmer_subtr)

car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# nothing sig

r.squaredGLMM(flowercount_2020_lmer_subtr)
# is this worth doing, since I have two regression lines?

AIC(lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig


car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig



# ANy variation among families or populations?
ranova(lmer(mean_flower_count ~ (1|Population/Family), data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = T))
# no... is singular
car::Anova(lmer(mean_flower_count ~ (1|Population/Family) + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# no... is singular

```
###### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
flowercount_2020_lmer_subtr_urbscore <- lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(flowercount_2020_lmer_subtr_urbscore)
# nothing sig
AIC(flowercount_2020_lmer_subtr_urbscore)

car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# nothing sig

r.squaredGLMM(flowercount_2020_lmer_subtr_urbscore)
# is this worth doing, since I have two regression lines?

AIC(lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig


car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig

```

##### Total flower count
###### Sig difference along gradient?
####### glmer: *sig for city_dist, insig for urb_score
######## City_dist
```{r}
### nested RANDOM EFFECTS-----
flowercountsum_2020_glmer_gradient <- glmmTMB(total_flower_count ~
                                                # (1|Block) +
                                                (1|Population/Family) +
                                                City_dist,
                                              data = flowering_2020,
                                              family = nbinom1())


# ANOVA
car::Anova(flowercountsum_2020_glmer_gradient)
# distance is sig

r.squaredGLMM(flowercountsum_2020_glmer_gradient)



# sjPlot: show points
sjPlot::plot_model(flowercountsum_2020_glmer_gradient,
                   type = "pred",
                   terms = c("City_dist"),
                   show.data = T,
                   geom_size = 1) +
  labs(x = "Dist CC") 




# ANy variation among families or populations?
# ranova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, family = 'poisson'))
```

######## Urb_score
```{r}
### nested RANDOM EFFECTS-----
flowercountsum_2020_glmer_gradient_urbscore <- glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, family = 'poisson')
# is singular...


# ANOVA
car::Anova(flowercountsum_2020_glmer_gradient_urbscore)
# not sig

r.squaredGLMM(flowercountsum_2020_glmer_gradient_urbscore)


### CROSSED RANDOM EFFECTS-----
glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, family = 'poisson')
# NOT singular!


# ANOVA
car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, family = 'poisson')
)
# not sig

```

###### Sig difference btwn urban subtransects?
####### glmer: *NO for both city_dist & urb_score
######## City_dist
```{r}
### NESTED RANDOM EFFECTS-----
flowercountsum_2020_glmer_subtr <- glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
                                     data = flowering_2020 %>% filter(Transect_ID != "Rural"))
# singular

# ANOVA
car::Anova(flowercountsum_2020_glmer_subtr)
AIC(flowercountsum_2020_glmer_subtr)
# nothing sig


car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural")))
# nothing sig

car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural")))
# nothing sig



### CROSSED RANDOM EFFECTS-----
glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
# singular

# ANOVA
car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
)
AIC(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
)
# nothing sig


car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
)
# nothing sig
AIC(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
)

```

######## Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
flowercountsum_2020_glmer_subtr_urbscore <- glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
                                     data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
# singular

# ANOVA
car::Anova(flowercountsum_2020_glmer_subtr_urbscore)
AIC(flowercountsum_2020_glmer_subtr_urbscore)
# nothing sig


car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson))
# nothing sig

car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson))
# nothing sig



### CROSSED RANDOM EFFECTS-----
glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
# NOT singular

# ANOVA
car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
)
AIC(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
)
# nothing sig


car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
)
# nothing sig
AIC(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
)

```


#### Flower size: HOLD OFF until 2021- too few plants and will probably overfit all models
##### Mean flower size/inflorescence
###### lmer
####### gradient: *NOt sig for either city_dist or urb_score
######## City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
# is singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)
# distance not sig

library(MuMIn) # Multi-Model Inference # Multi-Model Inference # Multi-Model Inference
r.squaredGLMM(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F))
# distance not sig


# ANy variation among families or populations?
ranova(lmer(Overall_mean ~ (1|Population/Family), data = flowering_2020, REML = T))
# no
```


######## Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020,
     REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)
# not sig

library(MuMIn) # Multi-Model Inference # Multi-Model Inference # Multi-Model Inference
r.squaredGLMM(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F))
# urb_score not sig

```

####### urban subtransects: *Main effects sig for both; interaxn sig for city_dist (marg sig for urb_score)
######## City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Overall_mean ~ (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# main effects and interaxn sig

car::Anova(lmer(Overall_mean ~  (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular,  everything  sig

AIC(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# both main effects sig

r.squaredGLMM(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# very high r-sq...is this worth doing, since I have two regression lines?

AIC(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# NOT singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# everything sig


car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects sig



# ANy variation among families or populations?
ranova(lmer(Overall_mean ~ (1|Population/Family), data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = T))
# no
car::Anova(lmer(Overall_mean ~ (1|Population/Family) + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# YES... variance DOES differ by subtransect... is singular

```
######## Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Overall_mean ~ (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# main effects sig

car::Anova(lmer(Overall_mean ~  (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular, main effects sig

AIC(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# both main effects sig

r.squaredGLMM(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# very high r-sq...is this worth doing, since I have two regression lines?

AIC(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects sig


car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects sig

```

#### Pods: HOLD OFF until 2021- too few plants and will probably overfit all models
##### lmer
###### gradient: *NOt sig for either city_dist or urb_score
####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
# is singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)
# distance not sig

r.squaredGLMM(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F))
# distance not sig


# ANy variation among families or populations?
ranova(lmer(Pods ~ (1|Population/Family), data = flowering_2020, REML = T))
# no
```


####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020,
     REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)
# not sig

r.squaredGLMM(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F))
# urb_score not sig

```

###### urban subtransects: *Main effects marg sig for city_dist; nothing sig for urb_score)
####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Pods ~ (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# main effects marg sig

car::Anova(lmer(Pods ~  (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular, main effects marg  sig

AIC(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# both main effects marg sig

r.squaredGLMM(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# very high r-sq...is this worth doing, since I have two regression lines?

AIC(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
#  singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects marg sig


car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects marg sig



# ANy variation among families or populations?
ranova(lmer(Pods ~ (1|Population/Family), data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = T))
# no
car::Anova(lmer(Pods ~ (1|Population/Family) + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# no ...variance doesn't differ by subtransect

```
####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Pods ~ (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# nothing sig

car::Anova(lmer(Pods ~  (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular,nothing sig

AIC(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# both main effects NOT sig

r.squaredGLMM(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

AIC(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig

car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig

```

#### Peduncles (Inflorescences): HOLD OFF until 2021- too few plants and will probably overfit all models
##### lmer
###### gradient: *NOt sig for either city_dist or urb_score
####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
# is singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)
# distance not sig

r.squaredGLMM(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F))
# distance not sig


# ANy variation among families or populations?
ranova(lmer(Peduncles ~ (1|Population/Family), data = flowering_2020, REML = T))
# no
```


####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020,
     REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)
# not sig

r.squaredGLMM(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F))
# urb_score not sig

```

###### urban subtransects: *nothing sig for city_dist (transect marg sig when interaction included but becomes non-sig when only main effects present); transect marg sig for urb_score)
####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Peduncles ~ (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# transect marg sig

car::Anova(lmer(Peduncles ~  (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular, transect marg  sig

AIC(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# nothing sig

r.squaredGLMM(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

AIC(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
#  singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# transect marg sig


car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig



# ANy variation among families or populations?
ranova(lmer(Peduncles ~ (1|Population/Family), data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = T))
# no
car::Anova(lmer(Peduncles ~ (1|Population/Family) + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# no ...variance doesn't differ by subtransect

```
####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Peduncles ~ (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# transect is marg sig

car::Anova(lmer(Peduncles ~  (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular, transect marg sig

AIC(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# transect marg sig

r.squaredGLMM(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

AIC(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# transect marg sig

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# transect marg sig

```


### All plants
#### Regressions (is urbanization related to flowering?)
##### glmer: diagnostics
```{r}
# GRADIENT / CITY_DIST
flowering_gr_city_m1 <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + City_dist,
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=0)

res <- simulateResiduals(flowering_gr_city_m1)
plot(res) # looks great!




# GRADIENT / URB SCORE
flowering_gr_urb_m1 <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=0)

res <- simulateResiduals(flowering_gr_urb_m1)
plot(res) # looks great!





# URBAN SUBTRANSECTS / CITY_DIST
flowering_urbsubs_city_m1 <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = reproductive %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ=0)

res <- simulateResiduals(flowering_urbsubs_city_m1)
plot(res) # looks great!

# main effects:
flowering_urbsubs_city_m1_ME <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = reproductive %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ=0)




# URBAN SUBTRANSECTS / URB SCORE
flowering_urbsubs_usc_m1 <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = reproductive %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ=0)

res <- simulateResiduals(flowering_urbsubs_usc_m1)
plot(res) # looks great!

# main effects:
flowering_urbsubs_usc_m1_ME <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = reproductive %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ=0)
```

##### Entire gradient: *Nothing sig for either
###### City_dist
```{r}
car::Anova(flowering_gr_city_m1)
# nothing significant



# ANy variation within families or populations?

##### TACTIC 1: try bootstrapping #####
# NOT PERFECT b/c can't nest family within pop but trying a few ways to get at the correct answer.
# https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html#test-of-random-parameter
# library(pbkrtest) # Parametric Bootstrap, Kenward-Roger and Satterthwaite Based
Methods for Test in Mixed Models
# library(pbnm)
# 
# # JUST POPULATION
# gmm <-  glmer(Flowered2020 ~ City_dist + (1|Population), # can't leave in Family... doesn't work
#               family = binomial(link = "logit"),
#               data = reproductive,
#              nAGQ = 0)
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1 <-  glmer(Flowered2020 ~ City_dist + (1|Population/Family), 
#               family = binomial(link = "logit"),
#               data = reproductive,
#              nAGQ = 0)
# 
# # POP:FAMILY
# gmm2 <-  glmer(Flowered2020 ~ City_dist + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#               family = binomial(link = "logit"),
#               data = reproductive,
#              nAGQ = 0)
# 
# # UNIQUE FAMILIES
# reproductive$Family_unique <- paste(reproductive$Population, reproductive$Family)
# gmm3 <-  glmer(Flowered2020 ~ City_dist + (1|Family_unique),
#               family = binomial(link = "logit"),
#               data = reproductive,
#              nAGQ = 0)
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4 <-  glmer(Flowered2020 ~ City_dist + (1|Population:Family) + (1|Population),
#               family = binomial(link = "logit"),
#               data = reproductive,
#              nAGQ = 0)
# 
# 
# # REDUCED MODEL
# gmmDG1 <- glm(Flowered2020 ~ City_dist,
#               family = binomial(link = "logit"),
#               data = reproductive)
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1 <- pbnm(gmm,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg1) # p = 0.031...  var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4 <- pbnm(gmm4,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop <- summary(pbgmmDg4) %T>%
#   print() # p = 0.028... var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2 <- pbnm(gmm2,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam <- summary(pbgmmDg2) %T>%
#   print() # p = 0.191... little var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3 <- pbnm(gmm3,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg3) # p = 0.258... little var among families, period
# 
# 
# 
# sum.1 <- summary(gmm4)
# 
# variances1 <- print(VarCorr(gmm4),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# # export percent variance explained
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Floweringsuccess_glmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# 
# # export ranova
# sink(here::here("./Figures_Tables/ranova_PVE/2020_Floweringsuccess_glmer_ranova.csv"))
# print("POPULATION", sep="\n\n")
# print(ranova_pop, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam, sep="\n\n")
#   cat("\n")
# if (ranova_pop[1] <= 0.05){
#   print ('There is variance among populations')}
# if (ranova_pop[1] > 0.05){
#   print ("There is not much variance among populations")}
# if (ranova_fam[1] <= 0.05){
#   print ("There is variance among families")}
# if (ranova_fam[1] > 0.05){
#   print ("There is not much variance among families")}
# sink()


```

###### Urb_score
```{r}
car::Anova(flowering_gr_urb_m1)
# not sig


```

##### Urban subtransects: *Nothing sig for either
###### City_dist
```{r}
car::Anova(flowering_urbsubs_city_m1) # nothing sig
car::Anova(flowering_urbsubs_city_m1_ME) # nothing sig

AIC(flowering_urbsubs_city_m1, flowering_urbsubs_city_m1_ME) # <2 away




# ANy variation within families or populations?

##### TACTIC 1: try bootstrapping #####
# NOT PERFECT b/c can't nest family within pop but trying a few ways to get at the correct answer.
# https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html#test-of-random-parameter


### MODEL 1: CITY_DIST ###
##########################
# 
# # JUST POPULATION
# gmm <-  glmer(Flowered2020 ~ City_dist + (1|Population), # can't leave in Family... doesn't work
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#   nAGQ = 0)
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1 <-  glmer(Flowered2020 ~ City_dist + (1|Population/Family), 
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # POP:FAMILY
# gmm2 <-  glmer(Flowered2020 ~ City_dist + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # UNIQUE FAMILIES
# gmm3 <-  glmer(Flowered2020 ~ City_dist + (1|Family_unique),
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4 <-  glmer(Flowered2020 ~ City_dist + (1|Population:Family) + (1|Population),
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# 
# # REDUCED MODEL 1
# gmmDG1 <- glm(Flowered2020 ~ City_dist,
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"))
# 
# 
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1 <- pbnm(gmm,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg1) # p = 0.032...  var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4 <- pbnm(gmm4,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop <- summary(pbgmmDg4) %T>%
#   print() # p = 0.049... var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2 <- pbnm(gmm2,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam <- summary(pbgmmDg2) %T>%
#   print() # p = 0.23... little var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3 <- pbnm(gmm3,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg3) # p = 0.23... little var among families, period
# 
# 
# 
# ### MODEL 2: TRANSECT_ID ###
# ##########################
# 
# # JUST POPULATION
# gmm.2 <-  glmer(Flowered2020 ~ Transect_ID + (1|Population), # can't leave in Family... doesn't work
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#   nAGQ = 0)
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1.2 <-  glmer(Flowered2020 ~ Transect_ID + (1|Population/Family), 
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # POP:FAMILY
# gmm2.2 <-  glmer(Flowered2020 ~ Transect_ID + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # UNIQUE FAMILIES
# gmm3.2 <-  glmer(Flowered2020 ~ Transect_ID + (1|Family_unique),
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4.2 <-  glmer(Flowered2020 ~ Transect_ID + (1|Population:Family) + (1|Population),
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # REDUCED MODEL 2
# gmmDG1.2 <- glm(Flowered2020 ~ Transect_ID,
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"))
# 
# 
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1.2 <- pbnm(gmm.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg1.2) # p = 0.027...  var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4.2 <- pbnm(gmm4.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop.2 <- summary(pbgmmDg4.2) %T>%
#   print() # p = 0.049... var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2.2 <- pbnm(gmm2.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam.2 <- summary(pbgmmDg2.2) %T>%
#   print() # p = 0.216... little var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3.2 <- pbnm(gmm3.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg3.2) # p = 0.216... little var among families, period
# 
# 
# 
# 
# sum.1 <- summary(gmm4)
# 
# variances1 <- print(VarCorr(gmm4),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# # export percent variance explained
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Floweringsuccess_urban_glmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# 
# # export ranova
# sink(here::here("./Figures_Tables/ranova_PVE/2020_Floweringsuccess_urban_glmer_ranova.csv"))
# print("POPULATION", sep="\n\n")
# print(ranova_pop, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam, sep="\n\n")
#   cat("\n")
# if (ranova_pop[1] <= 0.05){
#   print ('There is variance among populations')}
# if (ranova_pop[1] > 0.05){
#   print ("There is not much variance among populations")}
# if (ranova_fam[1] <= 0.05){
#   print ("There is variance among families")}
# if (ranova_fam[1] > 0.05){
#   print ("There is not much variance among families")}
#   
# cat("\n")
# cat("\n")
# 
# print("POPULATION", sep="\n\n")
# print(ranova_pop.2, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam.2, sep="\n\n")
#   cat("\n")
# if (ranova_pop.2[1] <= 0.05){
#   print ('Variance among populations differs by urban subtransect')}
# if (ranova_pop.2[1] > 0.05){
#   print ("Variance among populations does not differ by urban subtransect")}
# if (ranova_fam.2[1] <= 0.05){
#   print ("Variance among families differs by urban subtransect")}
# if (ranova_fam.2[1] > 0.05){
#   print ("Variance among families does not differ by urban subtransect")}
# sink()
```

###### Urb_score
```{r}
car::Anova(flowering_urbsubs_usc_m1) # nothing sig
car::Anova(flowering_urbsubs_usc_m1_ME) # nothing sig

AIC(flowering_urbsubs_usc_m1, flowering_urbsubs_usc_m1_ME) # <2 away
```


##### Export ANOVAs
```{r}
# 
# anova_table_flx(flowering_gr_city_m1)
# anova_table_flx(flowering_gr_urb_m1)
# anova_table_flx(flowering_urbsubs_city_m1)
# anova_table_flx(flowering_urbsubs_city_m1_ME)
# anova_table_flx(flowering_urbsubs_usc_m1)
# anova_table_flx(flowering_urbsubs_usc_m1_ME)
# 
# AIC_compare.city_dist(flowering_urbsubs_city_m1, flowering_urbsubs_city_m1_ME)
# AIC_compare.urb_score(flowering_urbsubs_usc_m1, flowering_urbsubs_usc_m1_ME)

```

