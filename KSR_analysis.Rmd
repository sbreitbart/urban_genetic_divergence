---
title: "KSR_2020"
author: "Sophie Breitbart"
output:
  html_document:
    number_sections: true
    df_print: paged
    toc: yes
    toc_depth: 6
    toc_float:
      collapsed: yes
  pdf_document:
    toc: yes
    toc_depth: '2'
editor_options: 
  chunk_output_type: console
NOTES:
  -Still to do--
    -try to do an RDA (or PCA?) with all the traits
    -make a ReadMe file for each level
    -calculate heritability coefficients
WHEN TOTALLY DONE, type this:
renv::activate()
renv::snapshot()
---
# Set up notebook
## Load packages
```{r}
library(dplyr) # A Grammar of Data Manipulation
# library(reshape)
# library(reshape2)
library(DHARMa) # Residual Diagnostics for Hierarchical (Multi-Level / Mixed) Regression Models
library(flextable) # Functions for Tabular Reporting
library(pbkrtest) # Parametric Bootstrap, Kenward-Roger and Satterthwaite Based Methods for Test in Mixed Models
# library(pbnm)
library(glmmTMB) # Generalized Linear Mixed Models using Template Model Builder
# library(redres)
library(tidyr) # Tidy Messy Data
library(broom.mixed) # Tidying Methods for Mixed Models
library(tidyverse) # Easily Install and Load the 'Tidyverse'
library(readxl) # Read Excel Files
library(broom) # Convert Statistical Objects into Tidy Tibbles
library(knitr) # A General-Purpose Package for Dynamic Report Generation in R
library(ggplot2) # Create Elegant Data Visualisations Using the Grammar of Graphics # Create Elegant Data Visualisations Using the Grammar of Graphics
# library(ggExtra)
# library("ggpubr")
library(devtools) # Tools to Make Developing R Packages Easier
# library(rpart)
library("tibble", lib.loc="~/R/win-library/3.5") # not installed on this machine
# library(ISLR)
library(MASS) # Support Functions and Datasets for Venables and Ripley's MASS
library(car) # Companion to Applied Regression
library(data.table) # Extension of `data.frame`
library(plyr) # Tools for Splitting, Applying and Combining Data
# library(MuMIn) # Multi-Model Inference # Multi-Model Inference # Multi-Model Inference
library(ggplot2) # Create Elegant Data Visualisations Using the Grammar of Graphics # Create Elegant Data Visualisations Using the Grammar of Graphics
library(gridExtra) # Miscellaneous Functions for "Grid" Graphics
library(Hmisc) # Harrell Miscellaneous
library(lme4) # Linear Mixed-Effects Models using 'Eigen' and S4
library(nlme) # Linear and Nonlinear Mixed Effects Models
library(lmerTest) # Tests in Linear Mixed Effects Models
library(vegan) # Community Ecology Package
# library(lindia)
# library(e1071)
library(ggpubr) # 'ggplot2' Based Publication Ready Plots
library(forcats) # Tools for Working with Categorical Variables (Factors)
library(multcomp) # Simultaneous Inference in General Parametric Models
library(lsmeans) # Least-Squares Means
# library(ggbiplot)
require(MASS) # Support Functions and Datasets for Venables and Ripley's MASS
require(scales) # Scale Functions for Visualization
# require(ggiraph)
# require(ggiraphExtra)
library(geosphere) # Spherical Trigonometry
library(vctrs) # Vector Helpers
library(here) # A Simpler Way to Find Your Files
library(stringi) # Character String Processing Facilities
```

## Add functions
```{r}
diagnostic<-function(x){
  plot(x)
  hist(x)
  qqnorm(x)
  qqline(x,lty=2, col="Red")

  skew<-function(x){
    m3<-sum((x-mean(x))^3)/length(x)
    s3<-sqrt(var(x))^3
    m3/s3}

  kurtosis<-function(x){
    m4<-sum((x-mean(x))^4)/length(x)
    s4<-var(x)^2
    m4/s4-3}

  print(paste("Kurtosis=", kurtosis(x), sep=""))
  print(paste("Skew=", skew(x), sep=""))
}


##### Export ANOVAs ##### 
# OLD-----
# flowering_gr_city_m1.tidy      <- tidy(car::Anova(flowering_gr_city_m1      ))
# flowering_gr_urb_m1.tidy       <- tidy(car::Anova(flowering_gr_urb_m1       ))
# flowering_urbsubs_city_m1.tidy <- tidy(car::Anova(flowering_urbsubs_city_m1 ))
# flowering_urbsubs_usc_m1.tidy  <- tidy(car::Anova(flowering_urbsubs_usc_m1   ))
#  

# anovas_merged.1 <- bind_rows(flowering_gr_city_m1.tidy    ,
#                               flowering_gr_urb_m1.tidy,
#                               flowering_urbsubs_city_m1.tidy,
#                               flowering_urbsubs_usc_m1.tidy ) %>%
#   mutate_if(.,
#             is.character,
#             str_replace_all,
#             pattern = c("City_dist", "Urb_score"),
#             replacement = c("Distance to City Center", "Urbanization Score")) %>%
#   mutate_if(.,
#             is.character,
#             str_replace_all,
#             pattern = c("Transect_ID", ":"),
#             replacement = c("Subtransect", " : ")) %>%
#   mutate_at(c(2,4), round, 3) %>%
#   rename_at(1, ~ "Effect") %>%
#   rename_at(2, ~ "Chi Square" ) %>%
#   rename_at(4, ~ "P" ) %>%
#   add_column(Model = 0) %>%
#   relocate(Model, before = Effect)

# anovas_table <- function(mod1, mod2, mod3, mod4) {
#   mod1.anova.tidy <- tidy(car::Anova(mod1))
#   mod2.anova.tidy <- tidy(car::Anova(mod2))
#   mod3.anova.tidy <- tidy(car::Anova(mod3))
#   mod4.anova.tidy <- tidy(car::Anova(mod4))
#   
#   anovas_merged <-  bind_rows( mod1.anova.tidy,
#                              mod2.anova.tidy,
#                              mod3.anova.tidy,
#                              mod4.anova.tidy) %>%
#   mutate_if(.,
#             is.character,
#             str_replace_all,
#             pattern = c("City_dist", "Urb_score"),
#             replacement = c("Distance to City Center", "Urbanization Score")) %>%
#   mutate_at(c(2,4), round, 3) %>%
#   rename_at(1, ~ "Effect") %>%
#   rename_at(2, ~ "Chi Square" ) %>%
#   rename_at(4, ~ "P" ) %>%
#   add_column(Model = "") %>%
#   relocate(Model, before = Effect) %>%
#     dplyr::select(., -4)
#   
# 
#   
#   anovas_merged[[1]][[1]] <- 1
#   anovas_merged[[1]][[2]] <- 2
#   anovas_merged[[1]][[3]] <- 3
#   anovas_merged[[1]][[6]] <- 4
# 
#   
#   return(as.data.frame(anovas_merged))
# }
# 
# fl1 <- anovas_table(flowering_gr_city_m1 ,
#                     flowering_gr_urb_m1      ,
#                     flowering_urbsubs_city_m1,
#                     flowering_urbsubs_usc_m1 ) %>%
#   mutate(P = ifelse(P < 0.001, "< 0.001", round(P, 3))) %>%
#   mutate_if(.,
#             is.character,
#             str_replace_all,
#             pattern = c("Transect_ID"),
#             replacement = c("Subtransect"))


# NEXT: PUT INTO  NICE TABLE

# library(flextable) # Functions for Tabular Reporting
# library(officer)
# ft <- flextable(fl1) %>%
#   bold(., ~ P  == "< 0.001" | P <= 0.05, ~ P, bold = TRUE) %>%
#   set_caption(., caption = "Does Urbanization Affect Year 2 Flowering?") %>%
#   add_footer_lines(., "Models 1 and 2 include all populations. Models 3 and 4 include only urban populations.") %>%
#   italic(., italic = TRUE, part = "footer") %>%
#   align(., i = 1, part = "header", align = "center") %>%
#   width(., 2, width = 2.75) %>%
#   border(., c(2,3,6), border.top = fp_border(color="black", width = 0.5))  %>%
#   save_as_image(., "flextable_test.1.png")

### this fits a regular model... not the anova...
# flowering_gr_city_m1 %>% 
#   tidy() %>%
#   dplyr::filter(., effect == "fixed") %>%
#   dplyr::select(-c(1:2)) %>%
#   dplyr::filter(term != "(Intercept)") %>%
#   dplyr::mutate_if(.,
#             is.character,
#             str_replace_all,
#             pattern = c("City_dist"),
#             replacement = c("Distance to City Center")) %>%
#   rename_at(1, ~ "Effect") %>%
#   rename_at(2, ~ "Estimate") %>%
#   rename_at(3, ~ "Standard Error") %>%
#   rename_at(4, ~ "Chi Square" ) %>%
#   rename_at(5, ~ "P" ) %>%
#       flextable()  %>%
#   colformat_num(j = c(2:5), digits = 3) %>%
# bold(., ~ P  == "< 0.001" | P <= 0.05, ~ P, bold = TRUE) %>%
#   set_caption(., caption = "Does Urbanization Affect Year 2 Flowering?") %>%
#   align(., i = 1, part = "header", align = "center") %>%
#   align_text_col(., align = "left") %>%
#   align_nottext_col(., align = "center") %>%
#   autofit(., add_w = 0.1, add_h = 0.1)

# GOOD CODE-----
anova_table_flx <- function(mod1) {

  flx_1 <-  car::Anova(mod1) %>% 
  tidy() %>%
  dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("City_dist"),
            replacement = c("Distance to City Center")) %>%
    dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("Urb_score"),
            replacement = c("Urbanization Score")) %>%
    dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("Transect_ID"),
            replacement = c("Subtransect")) %>%
  rename_at(1, ~ "Effect") %>%
  rename_at(2, ~ "Chi Square" ) %>%
  rename_at(4, ~ "P" ) %>%
  # dplyr::select(-3) %>%
    flextable()  %>%
    colformat_num(j = c(2,4), digits = 3) %>%
    flextable::bold(., ~ P  == "< 0.001" | P <= 0.05, ~ P, bold = TRUE) %>%
    flextable::italic(., ~ P > 0.05 & P <= 0.1, ~ P, italic = TRUE) %>%
  # set_caption(., caption = "Does Urbanization Affect Year 2 Flowering?") %>%
  # align(., i = 1, part = "header", align = "center") %>%
  # add_footer_lines(., paste("Model formula: ", paste0(toString(formula(mod1)[3])))) %>%
  # italic(., italic = TRUE, part = "footer") %>%
  align_text_col(., align = "left") %>%
  align_nottext_col(., align = "center") %>%
  autofit(., add_w = 0.1, add_h = 0.1) 

  
      # make filename a string (from symbol)
  # filename1 <- toString(formula(mod1)[[2]])

  # can't figure out how to remove space from filename so it's staying for now...
  path_out = here::here("./Figures_Tables/ANOVA_tables_images/ ")
  
  save_as_image(flx_1,
                gsub(" ", "",
                     paste(path_out,
                      # filename1,
                      print(substitute(mod1)),
                      "_ANOVA.png")))

}

# use _transf function if response var has been transformed
# use _binomial or _quantitative when I had to fit 2 extra models per var: binomial and then, with positive values, quantitative
AIC_compare.city_dist <- function(full_model, ME_model) {
  
  data.frame(Model = c("Full model",
                       "Main effects only"),
                     AIC = c(AIC(full_model),
                             AIC(ME_model))) %>%
    write.csv(gsub(" ", "",
                   paste(here::here("./Figures_Tables/ANOVA_tables_images/ "),
                       "AIC_comparison_",
                       formula(full_model)[[2]],
                       "_city",
                       # deparse(substitute(full_model)),
                       ".csv")))
  
}
AIC_compare.city_dist_transf <- function(full_model, ME_model) {
  
  data.frame(Model = c("Full model",
                       "Main effects only"),
                     AIC = c(AIC(full_model),
                             AIC(ME_model))) %>%
    write.csv(gsub(" ", "",
                   paste(here::here("./Figures_Tables/ANOVA_tables_images/ "),
                       "AIC_comparison_",
                       toString(formula(full_model)[[2]][2]),
                       "_city",
                       # deparse(substitute(full_model)),
                       ".csv")))
  
}
AIC_compare.city_dist_transf_binomial <- function(full_model, ME_model) {
  
  data.frame(Model = c("Full model",
                       "Main effects only"),
                     AIC = c(AIC(full_model),
                             AIC(ME_model))) %>%
    write.csv(gsub(" ", "",
                   paste(here::here("./Figures_Tables/ANOVA_tables_images/ "),
                       "AIC_comparison_",
                       toString(formula(full_model)[[2]][2]),
                       "_city_binomial",
                       # deparse(substitute(full_model)),
                       ".csv")))
  
}
AIC_compare.city_dist_transf_quantitative <- function(full_model, ME_model) {
  
  data.frame(Model = c("Full model",
                       "Main effects only"),
                     AIC = c(AIC(full_model),
                             AIC(ME_model))) %>%
    write.csv(gsub(" ", "",
                   paste(here::here("./Figures_Tables/ANOVA_tables_images/ "),
                       "AIC_comparison_",
                       toString(formula(full_model)[[2]][2]),
                       "_city_quantitative",
                       # deparse(substitute(full_model)),
                       ".csv")))
  
}


AIC_compare.urb_score <- function(full_model, ME_model) {
  
  data.frame(Model = c("Full model",
                       "Main effects only"),
                     AIC = c(AIC(full_model),
                             AIC(ME_model))) %>%
    write.csv(gsub(" ", "",
                   paste(here::here("./Figures_Tables/ANOVA_tables_images/ "),
                       "AIC_comparison_",
                       toString(formula(full_model)[[2]]),
                       "_urbscore",
                       # deparse(substitute(full_model)),
                       ".csv")))
  
}
AIC_compare.urb_score_transf <- function(full_model, ME_model) {
  
  data.frame(Model = c("Full model",
                       "Main effects only"),
                     AIC = c(AIC(full_model),
                             AIC(ME_model))) %>%
    write.csv(gsub(" ", "",
                   paste(here::here("./Figures_Tables/ANOVA_tables_images/ "),
                       "AIC_comparison_",
                       toString(formula(full_model)[[2]][2]),
                       "_urbscore",
                       # deparse(substitute(full_model)),
                       ".csv")))
  
}
AIC_compare.urb_score_transf_binomial <- function(full_model, ME_model) {
  
  data.frame(Model = c("Full model",
                       "Main effects only"),
                     AIC = c(AIC(full_model),
                             AIC(ME_model))) %>%
    write.csv(gsub(" ", "",
                   paste(here::here("./Figures_Tables/ANOVA_tables_images/ "),
                       "AIC_comparison_",
                       toString(formula(full_model)[[2]][2]),
                       "_urbscore_binomial",
                       # deparse(substitute(full_model)),
                       ".csv")))
  
}
AIC_compare.urb_score_transf_quantitative <- function(full_model, ME_model) {
  
  data.frame(Model = c("Full model",
                       "Main effects only"),
                     AIC = c(AIC(full_model),
                             AIC(ME_model))) %>%
    write.csv(gsub(" ", "",
                   paste(here::here("./Figures_Tables/ANOVA_tables_images/ "),
                       "AIC_comparison_",
                       toString(formula(full_model)[[2]][2]),
                       "_urbscore_quantitative",
                       # deparse(substitute(full_model)),
                       ".csv")))
  
}



# get name of models so I can later export all model names with their formulas-----
qq <- function(...) sapply(substitute({ ... })[-1], deparse)

```

## Import data
```{r}
# 2019 data-----
# data_clean_2019 <- read.csv(here::here("./CommonGardenExperiment_2019Data/clean_data/clean_data_2019KSR.csv"), na.strings=c("NO PLANT", "none"), blank.lines.skip=TRUE, header=TRUE, sep=",") %>%
#   dplyr::select(., -c(1:2))

# 2020 data-----
heights_both_2020 <- read.csv(here::here("./CommonGardenExperiment_2020Data/clean_data/2020_heights_clean.csv")) %>%
  dplyr::select(., -c(1:2))

herbivory_both_2020 <- read.csv(here::here("./CommonGardenExperiment_2020Data/clean_data/2020_herbivory_clean.csv")) %>%
  dplyr::select(., -c(1:2))

survival_2020 <- read.csv(here::here("./CommonGardenExperiment_2020Data/clean_data/2020_survival_clean.csv")) %>%
  dplyr::select(., -c(1:2))

weevil_both <- read.csv(here::here("./CommonGardenExperiment_2020Data/clean_data/2020_weevil_damage_clean.csv")) %>%
  dplyr::select(., -c(1:2))

reproductive <- read.csv(here::here("./CommonGardenExperiment_2020Data/clean_data/2020_reproductive_clean.csv")) %>%
  dplyr::select(., -c(1:2))

flowering_2020 <- read.csv(here::here("./CommonGardenExperiment_2020Data/clean_data/2020_floweringplants_clean.csv")) %>%
  dplyr::select(., -c(1:2))

sla_ldmc <- read.csv(here::here("./CommonGardenExperiment_2020Data/clean_data/2020_sla_ldmc_clean.csv")) %>%
  dplyr::select(., -c(1:2))

cards <-  read.csv(here::here("./CommonGardenExperiment_2020Data/clean_data/Cardenolides_forR.csv"))

  
# 2021 data

reproductive2 <- read.csv(here::here("./CommonGardenExperiment_2021Data/clean_data/2021_reproductive_clean.csv")) %>%
  dplyr::select(., -1)

flowering_2021 <- read.csv(here::here("./CommonGardenExperiment_2021Data/clean_data/2021_floweringplants_clean.csv")) %>%
  dplyr::select(-1)
```

## Make combined 2020/2021 dfs
```{r}
# # heights (includes heights and num. ramets)-----
# ## first make copy of data_clean_2019 with colnames that match heights_both_2020's
# heights_2019 <- data_clean_2019 %>%
#   dplyr::select(., c(1:6, 11:13, 18:19, 25:41)) %>%
#   dplyr::filter(., Dead_2019 == 0) %>%
#   dplyr::rename(., Dead = Dead_2019,
#                 Ramets_midJune = Num_Ramets_DC2, # doing this & following rows to compare btwn years
#                 Ramets_Sept = Num_Ramets_DC3, 
#                 Total_Height_midJune = Total_Height_DC2,
#                 Total_Height_Sept = Total_height_DC3) 
# heights_2019$Year = 2019
# heights_2019$rel_growth_rate <- as.character(heights_2019$rel_growth_rate)
# heights_2019$rel_growth_rate <- as.numeric(heights_2019$rel_growth_rate)
# 
# 
# # copy of 2020 data w/colnames that match 2019's
# heights_2020 <- heights_both_2020 %>%
#   dplyr::select(., -c(16)) %>%
#   dplyr::rename(., Ramets_midJune = Ramets_June, # doing this & following rows to compare btwn years
#                 Total_Height_midJune = Total_Height_June) 
# heights_2020$Year = 2020
# 
# # combine yearly dfs
# heights_19_20 <- rbind.fill(heights_2019, heights_2020)
# heights_19_20$Year <- as.factor(heights_19_20$Year)
# heights_19_20$Family <- as.factor(heights_19_20$Family)
# heights_19_20$Population <- as.factor(heights_19_20$Population)
# heights_19_20$rel_growth_rate <- as.numeric(heights_19_20$rel_growth_rate)
# 
# # rm(heights_2019, heights_2020)
# 
# heights_19_20$Population <- as.factor(heights_19_20$Population)
# heights_19_20$Family <- as.factor(heights_19_20$Family)
# 
# 
# 
# 
# # herbivory-----
# ## first make copy of data_clean_2019 with colnames that match heights_both_2020's
# herb_2019 <- data_clean_2019 %>%
#   dplyr::select(., c(1:6, 18:19, 21, 32, 35:41)) %>%
#   dplyr::filter(., Dead_2019 == 0) %>%
#   dplyr::rename(., Dead = Dead_2019,
#                 Herbivory_mean_Sept = Herbivory_mean_DC3 # doing this to compare btwn years
#                 ) 
# herb_2019$Year = 2019
# herb_2019$Herbivory_mean_Sept <- as.character(herb_2019$Herbivory_mean_Sept)
# herb_2019$Herbivory_mean_Sept <- as.numeric(herb_2019$Herbivory_mean_Sept)
# 
# # copy of 2020 data w/colnames that match 2019's
# herb_2020 <- herbivory_both_2020 %>%
#   dplyr::select(., -c(18)) %>%
#   dplyr::rename(., Herbivory_mean_Sept = Herbivory.Sept_mean # doing thisto compare btwn years
#                 ) 
# herb_2020$Year = 2020
# 
# # combine yearly dfs
# herbivory_19_20 <- rbind.fill(herb_2019, herb_2020)
# 
# # rm(herb_2019, herb_2020)
# 
# herbivory_19_20$Population <- as.factor(herbivory_19_20$Population)
# herbivory_19_20$Family <- as.factor(herbivory_19_20$Family)
# 
# 
# 
# 
# 
# # survival-----
# 
# ## first make copy of data_clean_2019 with colnames that match heights_both_2020's
# surv_2019 <- data_clean_2019 %>%
#   dplyr::select(., c(1:6, 14:16, 25, 32, 35:41)) %>%
#   dplyr::rename(., Dead = Dead_2019                ) 
# surv_2019$Year = 2019
# 
# # copy of 2020 data w/colnames that match 2019's
# surv_2020 <- survival_2020 %>%
#   dplyr::select(., -c(12)) %>%
#   dplyr::rename(., Dead = dead_2020 # doing thisto compare btwn years
#                 ) 
# surv_2020$Year = 2020
# 
# # combine yearly dfs
# survival_19_20 <- rbind.fill(surv_2019, surv_2020)
# 
# # rm(surv_2019, surv_2020)
# 
# survival_19_20$Population <- as.factor(survival_19_20$Population)
# survival_19_20$Family <- as.factor(survival_19_20$Family)
# survival_19_20$Block <- as.factor(survival_19_20$Block)
# survival_19_20$Year <- as.factor(survival_19_20$Year)
# 

```

# Statistics: 2021 only
## reproductive
### Plants that flowered
#### Flowering success
##### Sig difference between urb vs rural? (Odds ratio)
```{r}
# # How many plants flowered per subtransect? using 2019 alive plants
# tib1 <- reproductive %>%
#   filter(Alive_DC1 != '0')%>%
#   group_by(Flowered2020, Urb_Rur) %>%
#   tally()
# tib1
# 
# 
# Flowered_ttest <- matrix(c(21, 3, 556, 282), nrow = 2,
#                          dimnames = list(
#                            c("Urban", "Rural"),
#                            c("Flowered", "Didn't Flower")))
# 
# fisher.test(Flowered_ttest, alternative = "two.sided")
# # odds ratio = 3.5464
# # p = 0.02859
# # medium effect size


# How many plants flowered per urban/rural classification?
tib2 <- reproductive2 %>%
  group_by(Flowered2021, Urb_Rur) %>%
  tally()
tib2


Flowered_ttest2 <- matrix(c(
  as.integer(tib2[3,3]),
  as.integer(tib2[4,3]),
  as.integer(tib2[1,3]),
  as.integer(tib2[2,3])),
  nrow = 2,
  dimnames = list(
    c("Rural", "Urban"),
    c("Flowered", "Didn't Flower")))

fisher.test(Flowered_ttest2, alternative = "two.sided")
# odds ratio = 0.9594911
# p = 0.9095
# small effect size

chisq.test(Flowered_ttest2)
# X-squared = 0.0043791, df = 1, p-value = 0.9472





# How many populations had at least one plant flower per subtransect? using 2020 alive plants

tib3 <- reproductive2 %>%
  group_by(Population, Flowered2021, Urb_Rur) %>%
  dplyr::summarise(Pops = n_distinct(Population),
                   Urb_Rur = first(Urb_Rur)) %>%
  group_by(Population, Urb_Rur) %>%
  dplyr::summarise(Flowered = sum(as.integer(Flowered2021)),
                   Urb_Rur = first(Urb_Rur)) %>%
  group_by(Urb_Rur, Flowered) %>%
  dplyr::summarise(Pops = n_distinct(Population))
  
tib3
# Flowered = 1: Flowered
# Flowered = 0: Didn't flower



Flowered_ttest3 <- matrix(c(
  as.integer(tib3[2,3]),
  as.integer(tib3[4,3]),
  as.integer(tib3[1,3]),
  as.integer(tib3[3,3])),
  nrow = 2,
  dimnames = list(
    c("Rural", "Urban"),
    c("Flowered", "Didn't Flower")))

fisher.test(Flowered_ttest3, alternative = "two.sided")
# odds ratio = 2.136676 
# p = 0.34
# Small effect size


chisq.test(Flowered_ttest3)
# X-squared = 0.5472, df = 1, p-value = 0.4595
```



##### Sig difference between urb:north vs urb:south? (Odds ratio)
```{r}
# How many plants flowered per subtransect? using 2020 alive plants

tib4 <- reproductive %>%
  filter(., Transect_ID != 'Rural') %>%
  group_by(Flowered2020, Transect_ID) %>%
  tally()
tib4


Flowered_ttest4 <- matrix(c(
  as.integer(tib4[3,3]),
  as.integer(tib4[4,3]),
  as.integer(tib4[1,3]),
  as.integer(tib4[2,3])),
  nrow = 2,
  dimnames = list(
    c("North", "South"),
    c("Flowered", "Didn't Flower"))) %T>%
  print()

fisher.test(Flowered_ttest4, alternative = "two.sided")
# odds ratio = 0.782
# p = 0.660 (CAN'T REJECT THE NULL)
# negligible effect size

chisq.test(Flowered_ttest4)
# X-squared = 0.081128, df = 1, p-value = 0.7758






# How many populations had at least one plant flower per subtransect? using 2020 alive plants

tib5 <- reproductive %>%
  filter(., Transect_ID != "Rural") %>%
  group_by(Population, Flowered2020, Transect_ID) %>%
  dplyr::summarise(Pops = n_distinct(Population),
                   Transect_ID = first(Transect_ID)) %>%
  group_by(Population, Transect_ID) %>%
  dplyr::summarise(Flowered = sum(as.integer(Flowered2020)),
                   Transect_ID = first(Transect_ID)) %>%
  group_by(Transect_ID, Flowered) %>%
  dplyr::summarise(Pops = n_distinct(Population))
  
tib5
# Flowered = 0: Didn't flower
# Flowered = 1: Did flower



Flowered_ttest5 <- matrix(c(
  as.integer(tib5[1,3]),
  as.integer(tib5[3,3]),
  as.integer(tib5[2,3]),
  as.integer(tib5[4,3])),
  nrow = 2,
  dimnames = list(
    c("North", "South"),
    c("Didn't Flower", "Flowered"))) %T>%
  print()

fisher.test(Flowered_ttest5, alternative = "two.sided")
# odds ratio = 0.851
# p = 1 (NOT SIGNIFICANT; CAN'T REJECT NULL)
# small effect size

chisq.test(Flowered_ttest5)
# X-squared = 0.41878, df = 1, p-value = 0.5175
```


##### Block effect?
```{r}
glmer(Flowered2020 ~ Block + (1|Population/Family),
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=1,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))

car::Anova(glmer(Flowered2020 ~ Block + (1|Population/Family),
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=1,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# Block is significant, so yes, the number of plants that flowered DID significantly vary by block.

summary(glmer(Flowered2020 ~ Block + (1|Population/Family),
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=1,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
```

#### Flower count: HOLD OFF until 2021- too few plants and will probably overfit all models
##### Mean flower count/inflorescence
###### Sig difference along gradient?
####### glmer: diagnostics (No)
```{r}
flowercount_2021_lmer_gradient <- glmmTMB(mean_flower_count ~
                                          (1|Block) +
                                          (1|Population/Family) +
                                          City_dist, 
                                        data = flowering_2021,
                                        family = nbinom1())
res <- simulateResiduals(flowercount_2021_lmer_gradient)
plot(res)
testDispersion(flowercount_2021_lmer_gradient)
hist(flowering_2020$mean_flower_count, breaks = 10)


```

####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----

# ANOVA
car::Anova(flowercount_2021_lmer_gradient)
# distance is not sig

# library(MuMIn)
# r.squaredGLMM(flowercount_2020_lmer_gradient)


# ### CROSSED RANDOM EFFECTS-----
# lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F)
# # singular
# 
# car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F))
# # distance is sig
# 
# 
# # ANy variation among families or populations?
# ranova(lmer(mean_flower_count ~ (1|Population/Family), data = flowering_2020, REML = T))
# # no... is singular
```

####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
flowercount_2020_lmer_gradient_urbscore <- lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
# is singular

# ANOVA
car::Anova(flowercount_2020_lmer_gradient_urbscore)
# sig

library(MuMIn) # Multi-Model Inference # Multi-Model Inference # Multi-Model Inference
r.squaredGLMM(flowercount_2020_lmer_gradient_urbscore)


### CROSSED RANDOM EFFECTS-----
lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F))
#  sig

```

##### Sig difference btwn urban subtransects?
###### lmer: *NO: Nothing sig for city_dist or urb_score
###### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
flowercount_2020_lmer_subtr <- lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(flowercount_2020_lmer_subtr)
# nothing sig
AIC(flowercount_2020_lmer_subtr)

car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# nothing sig

r.squaredGLMM(flowercount_2020_lmer_subtr)
# is this worth doing, since I have two regression lines?

AIC(lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig


car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig



# ANy variation among families or populations?
ranova(lmer(mean_flower_count ~ (1|Population/Family), data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = T))
# no... is singular
car::Anova(lmer(mean_flower_count ~ (1|Population/Family) + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# no... is singular

```
###### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
flowercount_2020_lmer_subtr_urbscore <- lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(flowercount_2020_lmer_subtr_urbscore)
# nothing sig
AIC(flowercount_2020_lmer_subtr_urbscore)

car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# nothing sig

r.squaredGLMM(flowercount_2020_lmer_subtr_urbscore)
# is this worth doing, since I have two regression lines?

AIC(lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig


car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig

```

##### Total flower count
###### Sig difference along gradient?
####### glmer: *sig for city_dist, insig for urb_score
######## City_dist
```{r}
### nested RANDOM EFFECTS-----
flowercountsum_2020_glmer_gradient <- glmmTMB(total_flower_count ~
                                                # (1|Block) +
                                                (1|Population/Family) +
                                                City_dist,
                                              data = flowering_2020,
                                              family = nbinom1())


# ANOVA
car::Anova(flowercountsum_2020_glmer_gradient)
# distance is sig

r.squaredGLMM(flowercountsum_2020_glmer_gradient)



# sjPlot: show points
sjPlot::plot_model(flowercountsum_2020_glmer_gradient,
                   type = "pred",
                   terms = c("City_dist"),
                   show.data = T,
                   geom_size = 1) +
  labs(x = "Dist CC") 




# ANy variation among families or populations?
# ranova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, family = 'poisson'))
```

######## Urb_score
```{r}
### nested RANDOM EFFECTS-----
flowercountsum_2020_glmer_gradient_urbscore <- glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, family = 'poisson')
# is singular...


# ANOVA
car::Anova(flowercountsum_2020_glmer_gradient_urbscore)
# not sig

r.squaredGLMM(flowercountsum_2020_glmer_gradient_urbscore)


### CROSSED RANDOM EFFECTS-----
glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, family = 'poisson')
# NOT singular!


# ANOVA
car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, family = 'poisson')
)
# not sig

```

###### Sig difference btwn urban subtransects?
####### glmer: *NO for both city_dist & urb_score
######## City_dist
```{r}
### NESTED RANDOM EFFECTS-----
flowercountsum_2020_glmer_subtr <- glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
                                     data = flowering_2020 %>% filter(Transect_ID != "Rural"))
# singular

# ANOVA
car::Anova(flowercountsum_2020_glmer_subtr)
AIC(flowercountsum_2020_glmer_subtr)
# nothing sig


car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural")))
# nothing sig

car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural")))
# nothing sig



### CROSSED RANDOM EFFECTS-----
glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
# singular

# ANOVA
car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
)
AIC(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
)
# nothing sig


car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
)
# nothing sig
AIC(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
)

```

######## Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
flowercountsum_2020_glmer_subtr_urbscore <- glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
                                     data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
# singular

# ANOVA
car::Anova(flowercountsum_2020_glmer_subtr_urbscore)
AIC(flowercountsum_2020_glmer_subtr_urbscore)
# nothing sig


car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson))
# nothing sig

car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson))
# nothing sig



### CROSSED RANDOM EFFECTS-----
glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
# NOT singular

# ANOVA
car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
)
AIC(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
)
# nothing sig


car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
)
# nothing sig
AIC(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
)

```


#### Flower size: HOLD OFF until 2021- too few plants and will probably overfit all models
##### Mean flower size/inflorescence
###### lmer
####### gradient: *NOt sig for either city_dist or urb_score
######## City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
# is singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)
# distance not sig

library(MuMIn) # Multi-Model Inference # Multi-Model Inference # Multi-Model Inference
r.squaredGLMM(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F))
# distance not sig


# ANy variation among families or populations?
ranova(lmer(Overall_mean ~ (1|Population/Family), data = flowering_2020, REML = T))
# no
```


######## Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020,
     REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)
# not sig

library(MuMIn) # Multi-Model Inference # Multi-Model Inference # Multi-Model Inference
r.squaredGLMM(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F))
# urb_score not sig

```

####### urban subtransects: *Main effects sig for both; interaxn sig for city_dist (marg sig for urb_score)
######## City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Overall_mean ~ (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# main effects and interaxn sig

car::Anova(lmer(Overall_mean ~  (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular,  everything  sig

AIC(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# both main effects sig

r.squaredGLMM(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# very high r-sq...is this worth doing, since I have two regression lines?

AIC(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# NOT singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# everything sig


car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects sig



# ANy variation among families or populations?
ranova(lmer(Overall_mean ~ (1|Population/Family), data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = T))
# no
car::Anova(lmer(Overall_mean ~ (1|Population/Family) + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# YES... variance DOES differ by subtransect... is singular

```
######## Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Overall_mean ~ (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# main effects sig

car::Anova(lmer(Overall_mean ~  (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular, main effects sig

AIC(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# both main effects sig

r.squaredGLMM(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# very high r-sq...is this worth doing, since I have two regression lines?

AIC(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects sig


car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects sig

```

#### Pods: HOLD OFF until 2021- too few plants and will probably overfit all models
##### lmer
###### gradient: *NOt sig for either city_dist or urb_score
####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
# is singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)
# distance not sig

r.squaredGLMM(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F))
# distance not sig


# ANy variation among families or populations?
ranova(lmer(Pods ~ (1|Population/Family), data = flowering_2020, REML = T))
# no
```


####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020,
     REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)
# not sig

r.squaredGLMM(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F))
# urb_score not sig

```

###### urban subtransects: *Main effects marg sig for city_dist; nothing sig for urb_score)
####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Pods ~ (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# main effects marg sig

car::Anova(lmer(Pods ~  (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular, main effects marg  sig

AIC(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# both main effects marg sig

r.squaredGLMM(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# very high r-sq...is this worth doing, since I have two regression lines?

AIC(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
#  singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects marg sig


car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects marg sig



# ANy variation among families or populations?
ranova(lmer(Pods ~ (1|Population/Family), data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = T))
# no
car::Anova(lmer(Pods ~ (1|Population/Family) + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# no ...variance doesn't differ by subtransect

```
####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Pods ~ (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# nothing sig

car::Anova(lmer(Pods ~  (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular,nothing sig

AIC(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# both main effects NOT sig

r.squaredGLMM(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

AIC(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig

car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig

```

#### Peduncles (Inflorescences): HOLD OFF until 2021- too few plants and will probably overfit all models
##### lmer
###### gradient: *NOt sig for either city_dist or urb_score
####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
# is singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)
# distance not sig

r.squaredGLMM(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F))
# distance not sig


# ANy variation among families or populations?
ranova(lmer(Peduncles ~ (1|Population/Family), data = flowering_2020, REML = T))
# no
```


####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020,
     REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)
# not sig

r.squaredGLMM(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F))
# urb_score not sig

```

###### urban subtransects: *nothing sig for city_dist (transect marg sig when interaction included but becomes non-sig when only main effects present); transect marg sig for urb_score)
####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Peduncles ~ (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# transect marg sig

car::Anova(lmer(Peduncles ~  (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular, transect marg  sig

AIC(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# nothing sig

r.squaredGLMM(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

AIC(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
#  singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# transect marg sig


car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig



# ANy variation among families or populations?
ranova(lmer(Peduncles ~ (1|Population/Family), data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = T))
# no
car::Anova(lmer(Peduncles ~ (1|Population/Family) + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# no ...variance doesn't differ by subtransect

```
####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Peduncles ~ (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# transect is marg sig

car::Anova(lmer(Peduncles ~  (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular, transect marg sig

AIC(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# transect marg sig

r.squaredGLMM(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

AIC(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# transect marg sig

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# transect marg sig

```


### All plants
#### Regressions (is urbanization related to flowering?)
##### glmer: diagnostics
```{r}
# GRADIENT / CITY_DIST
flowering_gr_city_m1 <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + City_dist,
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=0)

res <- simulateResiduals(flowering_gr_city_m1)
plot(res) # looks great!




# GRADIENT / URB SCORE
flowering_gr_urb_m1 <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=0)

res <- simulateResiduals(flowering_gr_urb_m1)
plot(res) # looks great!





# URBAN SUBTRANSECTS / CITY_DIST
flowering_urbsubs_city_m1 <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = reproductive %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ=0)

res <- simulateResiduals(flowering_urbsubs_city_m1)
plot(res) # looks great!

# main effects:
flowering_urbsubs_city_m1_ME <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = reproductive %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ=0)




# URBAN SUBTRANSECTS / URB SCORE
flowering_urbsubs_usc_m1 <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = reproductive %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ=0)

res <- simulateResiduals(flowering_urbsubs_usc_m1)
plot(res) # looks great!

# main effects:
flowering_urbsubs_usc_m1_ME <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = reproductive %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ=0)
```

##### Entire gradient: *Nothing sig for either
###### City_dist
```{r}
car::Anova(flowering_gr_city_m1)
# nothing significant



# ANy variation within families or populations?

##### TACTIC 1: try bootstrapping #####
# NOT PERFECT b/c can't nest family within pop but trying a few ways to get at the correct answer.
# https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html#test-of-random-parameter
# library(pbkrtest) # Parametric Bootstrap, Kenward-Roger and Satterthwaite Based
Methods for Test in Mixed Models
# library(pbnm)
# 
# # JUST POPULATION
# gmm <-  glmer(Flowered2020 ~ City_dist + (1|Population), # can't leave in Family... doesn't work
#               family = binomial(link = "logit"),
#               data = reproductive,
#              nAGQ = 0)
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1 <-  glmer(Flowered2020 ~ City_dist + (1|Population/Family), 
#               family = binomial(link = "logit"),
#               data = reproductive,
#              nAGQ = 0)
# 
# # POP:FAMILY
# gmm2 <-  glmer(Flowered2020 ~ City_dist + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#               family = binomial(link = "logit"),
#               data = reproductive,
#              nAGQ = 0)
# 
# # UNIQUE FAMILIES
# reproductive$Family_unique <- paste(reproductive$Population, reproductive$Family)
# gmm3 <-  glmer(Flowered2020 ~ City_dist + (1|Family_unique),
#               family = binomial(link = "logit"),
#               data = reproductive,
#              nAGQ = 0)
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4 <-  glmer(Flowered2020 ~ City_dist + (1|Population:Family) + (1|Population),
#               family = binomial(link = "logit"),
#               data = reproductive,
#              nAGQ = 0)
# 
# 
# # REDUCED MODEL
# gmmDG1 <- glm(Flowered2020 ~ City_dist,
#               family = binomial(link = "logit"),
#               data = reproductive)
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1 <- pbnm(gmm,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg1) # p = 0.031...  var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4 <- pbnm(gmm4,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop <- summary(pbgmmDg4) %T>%
#   print() # p = 0.028... var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2 <- pbnm(gmm2,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam <- summary(pbgmmDg2) %T>%
#   print() # p = 0.191... little var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3 <- pbnm(gmm3,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg3) # p = 0.258... little var among families, period
# 
# 
# 
# sum.1 <- summary(gmm4)
# 
# variances1 <- print(VarCorr(gmm4),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# # export percent variance explained
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Floweringsuccess_glmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# 
# # export ranova
# sink(here::here("./Figures_Tables/ranova_PVE/2020_Floweringsuccess_glmer_ranova.csv"))
# print("POPULATION", sep="\n\n")
# print(ranova_pop, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam, sep="\n\n")
#   cat("\n")
# if (ranova_pop[1] <= 0.05){
#   print ('There is variance among populations')}
# if (ranova_pop[1] > 0.05){
#   print ("There is not much variance among populations")}
# if (ranova_fam[1] <= 0.05){
#   print ("There is variance among families")}
# if (ranova_fam[1] > 0.05){
#   print ("There is not much variance among families")}
# sink()


```

###### Urb_score
```{r}
car::Anova(flowering_gr_urb_m1)
# not sig


```

##### Urban subtransects: *Nothing sig for either
###### City_dist
```{r}
car::Anova(flowering_urbsubs_city_m1) # nothing sig
car::Anova(flowering_urbsubs_city_m1_ME) # nothing sig

AIC(flowering_urbsubs_city_m1, flowering_urbsubs_city_m1_ME) # <2 away




# ANy variation within families or populations?

##### TACTIC 1: try bootstrapping #####
# NOT PERFECT b/c can't nest family within pop but trying a few ways to get at the correct answer.
# https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html#test-of-random-parameter


### MODEL 1: CITY_DIST ###
##########################
# 
# # JUST POPULATION
# gmm <-  glmer(Flowered2020 ~ City_dist + (1|Population), # can't leave in Family... doesn't work
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#   nAGQ = 0)
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1 <-  glmer(Flowered2020 ~ City_dist + (1|Population/Family), 
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # POP:FAMILY
# gmm2 <-  glmer(Flowered2020 ~ City_dist + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # UNIQUE FAMILIES
# gmm3 <-  glmer(Flowered2020 ~ City_dist + (1|Family_unique),
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4 <-  glmer(Flowered2020 ~ City_dist + (1|Population:Family) + (1|Population),
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# 
# # REDUCED MODEL 1
# gmmDG1 <- glm(Flowered2020 ~ City_dist,
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"))
# 
# 
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1 <- pbnm(gmm,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg1) # p = 0.032...  var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4 <- pbnm(gmm4,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop <- summary(pbgmmDg4) %T>%
#   print() # p = 0.049... var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2 <- pbnm(gmm2,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam <- summary(pbgmmDg2) %T>%
#   print() # p = 0.23... little var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3 <- pbnm(gmm3,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg3) # p = 0.23... little var among families, period
# 
# 
# 
# ### MODEL 2: TRANSECT_ID ###
# ##########################
# 
# # JUST POPULATION
# gmm.2 <-  glmer(Flowered2020 ~ Transect_ID + (1|Population), # can't leave in Family... doesn't work
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#   nAGQ = 0)
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1.2 <-  glmer(Flowered2020 ~ Transect_ID + (1|Population/Family), 
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # POP:FAMILY
# gmm2.2 <-  glmer(Flowered2020 ~ Transect_ID + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # UNIQUE FAMILIES
# gmm3.2 <-  glmer(Flowered2020 ~ Transect_ID + (1|Family_unique),
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4.2 <-  glmer(Flowered2020 ~ Transect_ID + (1|Population:Family) + (1|Population),
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # REDUCED MODEL 2
# gmmDG1.2 <- glm(Flowered2020 ~ Transect_ID,
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"))
# 
# 
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1.2 <- pbnm(gmm.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg1.2) # p = 0.027...  var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4.2 <- pbnm(gmm4.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop.2 <- summary(pbgmmDg4.2) %T>%
#   print() # p = 0.049... var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2.2 <- pbnm(gmm2.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam.2 <- summary(pbgmmDg2.2) %T>%
#   print() # p = 0.216... little var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3.2 <- pbnm(gmm3.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg3.2) # p = 0.216... little var among families, period
# 
# 
# 
# 
# sum.1 <- summary(gmm4)
# 
# variances1 <- print(VarCorr(gmm4),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# # export percent variance explained
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Floweringsuccess_urban_glmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# 
# # export ranova
# sink(here::here("./Figures_Tables/ranova_PVE/2020_Floweringsuccess_urban_glmer_ranova.csv"))
# print("POPULATION", sep="\n\n")
# print(ranova_pop, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam, sep="\n\n")
#   cat("\n")
# if (ranova_pop[1] <= 0.05){
#   print ('There is variance among populations')}
# if (ranova_pop[1] > 0.05){
#   print ("There is not much variance among populations")}
# if (ranova_fam[1] <= 0.05){
#   print ("There is variance among families")}
# if (ranova_fam[1] > 0.05){
#   print ("There is not much variance among families")}
#   
# cat("\n")
# cat("\n")
# 
# print("POPULATION", sep="\n\n")
# print(ranova_pop.2, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam.2, sep="\n\n")
#   cat("\n")
# if (ranova_pop.2[1] <= 0.05){
#   print ('Variance among populations differs by urban subtransect')}
# if (ranova_pop.2[1] > 0.05){
#   print ("Variance among populations does not differ by urban subtransect")}
# if (ranova_fam.2[1] <= 0.05){
#   print ("Variance among families differs by urban subtransect")}
# if (ranova_fam.2[1] > 0.05){
#   print ("Variance among families does not differ by urban subtransect")}
# sink()
```

###### Urb_score
```{r}
car::Anova(flowering_urbsubs_usc_m1) # nothing sig
car::Anova(flowering_urbsubs_usc_m1_ME) # nothing sig

AIC(flowering_urbsubs_usc_m1, flowering_urbsubs_usc_m1_ME) # <2 away
```


##### Export ANOVAs
```{r}
# 
# anova_table_flx(flowering_gr_city_m1)
# anova_table_flx(flowering_gr_urb_m1)
# anova_table_flx(flowering_urbsubs_city_m1)
# anova_table_flx(flowering_urbsubs_city_m1_ME)
# anova_table_flx(flowering_urbsubs_usc_m1)
# anova_table_flx(flowering_urbsubs_usc_m1_ME)
# 
# AIC_compare.city_dist(flowering_urbsubs_city_m1, flowering_urbsubs_city_m1_ME)
# AIC_compare.urb_score(flowering_urbsubs_usc_m1, flowering_urbsubs_usc_m1_ME)

```


# Statistics: 2020-2021
## Heights
### Mid June height
#### lmer: diagnostics
```{r}
# Gradient / city_dist----------
height_gr_dist_m1 <- lmer(Total_Height_midJune ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height_gr_dist_m1, type='diag')
# looks like there's some heteroskedasticity and it's right-skewed... try sqrt transformation


height_gr_dist_m2 <- lmer(sqrt(Total_Height_midJune) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height_gr_dist_m2, type='diag')
# much better!



# Gradient / urb_score----------
height_gr_usc_m1 <- lmer(Total_Height_midJune ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score ,
  data = heights_19_20, REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height_gr_usc_m1, type='diag')
# looks like there's some heteroskedasticity and it's right-skewed... try sqrt transformation

height_gr_usc_m2 <- lmer(sqrt(Total_Height_midJune) ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score ,
  data = heights_19_20, REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height_gr_usc_m2, type='diag')
# much better!



# Urb sites / city_dist----------
height_urb_dist_m1 <- lmer(Total_Height_midJune  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height_urb_dist_m1, type='diag')
# looks like there's some heteroskedasticity and it's right-skewed... try sqrt transformation

height_urb_dist_m2 <- lmer(sqrt(Total_Height_midJune)  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height_urb_dist_m2, type='diag')
# much better!

# main effects:
height_urb_dist_m2_ME <- lmer(sqrt(Total_Height_midJune)  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist + Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))





# Urb sites / urb_score----------
height_urb_usc_m1 <- lmer(Total_Height_midJune  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height_urb_usc_m1, type='diag')
# looks like there's some heteroskedasticity and it's right-skewed... try sqrt transformation

height_urb_usc_m2 <- lmer(sqrt(Total_Height_midJune)  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height_urb_usc_m2, type='diag')
# much better!


# main effects:
height_urb_usc_m2_ME <- lmer(sqrt(Total_Height_midJune)  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score + Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
```

#### Entire gradient: *dist & urb score not sig
##### City_dist
```{r}
car::Anova(height_gr_dist_m2)
# dist not significant

r.squaredGLMM(height_gr_dist_m2)
```

##### Urb_score
```{r}
car::Anova(height_gr_usc_m2)
# dist not significant

r.squaredGLMM(height_gr_usc_m2)
```

#### Urban subtransects: *transect sig for both
##### City_dist
```{r}
car::Anova(height_urb_dist_m2)
# dist not significant but transect ID is!

r.squaredGLMM(height_urb_dist_m2)


# just main effects
car::Anova(height_urb_dist_m2_ME)
# transect sig

r.squaredGLMM(height_urb_dist_m2_ME)

AIC((height_urb_dist_m2),
    (height_urb_dist_m2_ME)) # better but <2 AIC from full model
```

##### Urb_score
```{r}
car::Anova(height_urb_usc_m2)
# urb score not significant but transect ID is!

r.squaredGLMM(height_urb_usc_m2)


# just main effects
car::Anova(height_urb_usc_m2_ME)
# transect sig

r.squaredGLMM(height_urb_usc_m2_ME)

AIC((height_urb_usc_m2),
    (height_urb_usc_m2_ME)) # better but <2 AIC from full model
```


### Sept height- nothing sig. Look at yearly data
#### lmer: diagnostics
```{r}
# Gradient / city_dist----------
height2_gr_dist_m1 <- lmer(Total_Height_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height2_gr_dist_m1, type='diag')
# looks like there's some heteroskedasticity and it's right-skewed... try sqrt transformation


height2_gr_dist_m2 <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height2_gr_dist_m2, type='diag')
# much better though still not good enough... two distinct clusters... try cube root

height2_gr_dist_m3 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height2_gr_dist_m3, type='diag')
# didn't help much... maybe this data isn't normal? is it bimodal?

hist(heights_19_20$Total_Height_Sept, breaks = 40)


# what do diagnostic plots look like for just 2020 data? (sqrt)
sjPlot::plot_model(lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2020,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))), type='diag')
# looks pretty good... and 2019 data?

sjPlot::plot_model(lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_2019,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))), type='diag')
# better but still bimodal... take out zeros then do binomial- were plants alive (have heights > 0?), then look at quantitative measurements



# TAKING OUT PLANTS W/ZERO HEIGHT & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

# recode plants as having height or not
heights_19_20$Total_Height_Sept_binary <- heights_19_20$Total_Height_Sept
heights_19_20$Total_Height_Sept_binary[heights_19_20$Total_Height_Sept_binary > 0] <- 1

height2_gr_dist_m4 <- glmer((Total_Height_Sept_binary) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  family = "binomial"(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(height2_gr_dist_m4)
plot(res)
# looks great!
summary(height2_gr_dist_m4)

car::Anova(height2_gr_dist_m4) # not sig



height2_gr_dist_m5 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1),
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_gr_dist_m5, type='diag')
# looks ok... still heavy tails and two distinct clumps... does this go away when I separate the years?

# 2019
height2_gr_dist_m5.2019 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1 & Year == 2019),
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_gr_dist_m5.2019, type='diag')
# looks pretty good- one clump instead of two...

# 2020
height2_gr_dist_m5.2020 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1 & Year == 2020),
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_gr_dist_m5.2020, type='diag')
# again, looks pretty good- one clump instead of two...

car::Anova(height2_gr_dist_m5) # not sig
car::Anova(height2_gr_dist_m5.2019) # not sig
car::Anova(height2_gr_dist_m5.2020) # not sig


# look at correlation of height btwn years
heights_19_20_joined <- join(heights_2019[, c(1:6, 18)], heights_2020[,c(1:6, 12)], by = c("Row", "Column", "Population", "Block", "Replicate"))
heights_19_20_joined <- heights_19_20_joined[, -8]
colnames(heights_19_20_joined)[7] <- "Total_Height_Sept_2019"
colnames(heights_19_20_joined)[8] <- "Total_Height_Sept_2020"

ggplot(heights_19_20_joined, aes(x = Total_Height_Sept_2019, y = Total_Height_Sept_2020)) +
  geom_point() +
  geom_smooth(method = lm) +
  ggtitle("R-squared: ", summary(corr_heights_m1)$r.squared)

corr_heights_m1 <- lm(Total_Height_Sept_2019 ~ Total_Height_Sept_2020, heights_19_20_joined)
summary(corr_heights_m1)






# Gradient / urb_score----------
height2_gr_usc_m1 <- lmer(Total_Height_Sept ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score ,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_gr_usc_m1, type='diag')
# looks like there's some heteroskedasticity and it's right-skewed... try sqrt transformation

height2_gr_usc_m2 <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score ,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_gr_usc_m2, type='diag')
# same issues as above...


# TAKING OUT PLANTS W/ZERO HEIGHT & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

height2_gr_usc_m3 <- glmer((Total_Height_Sept_binary) ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
  data = heights_19_20,
  family = "binomial"(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(height2_gr_usc_m3)
plot(res)
# looks great!
summary(height2_gr_usc_m3)

car::Anova(height2_gr_usc_m3) # not sig



height2_gr_usc_m4 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_gr_usc_m4, type='diag')
# looks ok... still heavy tails and two distinct clumps... does this go away when I separate the years?

# 2019
height2_gr_usc_m4.2019 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1 & Year == 2019),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_gr_usc_m4.2019, type='diag')
# looks pretty good- one clump instead of two...

# 2020
height2_gr_usc_m4.2020 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1 & Year == 2020),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_gr_usc_m4.2020, type='diag')
# again, looks pretty good- one clump instead of two...

car::Anova(height2_gr_usc_m4) # not sig
car::Anova(height2_gr_usc_m4.2019) # not sig
car::Anova(height2_gr_usc_m4.2020) # not sig









# Urb sites / city_dist----------
height2_urb_dist_m1 <- lmer(Total_Height_Sept  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height2_urb_dist_m1, type='diag')
# looks like there's some heteroskedasticity and it's right-skewed... try sqrt transformation

height2_urb_dist_m2 <- lmer(sqrt(Total_Height_Sept)  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height2_urb_dist_m2, type='diag')
# same issues as above



# TAKING OUT PLANTS W/ZERO HEIGHT & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

height2_urb_dist_m3 <- glmer((Total_Height_Sept_binary) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
  data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(height2_urb_dist_m3)
plot(res)
# looks great!
summary(height2_urb_dist_m3)

car::Anova(height2_urb_dist_m3) # not sig



height2_urb_dist_m4 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_urb_dist_m4, type='diag')
# looks ok... still heavy tails and two distinct clumps... does this go away when I separate the years?

# 2019
height2_urb_dist_m4.2019 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1 & Year == 2019),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_urb_dist_m4.2019, type='diag')
# looks pretty good- one clump instead of two...

# 2020
height2_urb_dist_m4.2020 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1 & Year == 2020),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_urb_dist_m4.2020, type='diag')
# again, looks pretty good- one clump instead of two...

car::Anova(height2_urb_dist_m4) # city_dist MARGINALLY sig
car::Anova(height2_urb_dist_m4.2019) # not sig
car::Anova(height2_urb_dist_m4.2020) # not sig





# Urb sites / urb_score----------
height2_urb_usc_m1 <- lmer(Total_Height_Sept  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height2_urb_usc_m1, type='diag')
# looks like there's some heteroskedasticity and it's right-skewed... try sqrt transformation

height2_urb_usc_m2 <- lmer(sqrt(Total_Height_Sept)  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(height2_urb_usc_m2, type='diag')
# same issues as above


# TAKING OUT PLANTS W/ZERO HEIGHT & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

height2_urb_usc_m3 <- glmer((Total_Height_Sept_binary) ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
  data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(height2_urb_usc_m3)
plot(res)
# looks great!
summary(height2_urb_usc_m3)

car::Anova(height2_urb_usc_m3) # not sig



height2_urb_usc_m4 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_urb_usc_m4, type='diag')
# looks ok... still heavy tails and two distinct clumps... does this go away when I separate the years?

# 2019
height2_urb_usc_m4.2019 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1 & Year == 2019),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_urb_usc_m4.2019, type='diag')
# looks pretty good- one clump instead of two...

# 2020
height2_urb_usc_m4.2020 <- lmer((Total_Height_Sept)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = heights_19_20 %>% filter(Total_Height_Sept_binary == 1 & Year == 2020),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(height2_urb_usc_m4.2020, type='diag')
# again, looks pretty good- one clump instead of two...

car::Anova(height2_urb_usc_m4) # not sig
car::Anova(height2_urb_usc_m4.2019) # not sig
car::Anova(height2_urb_usc_m4.2020) # not sig


```
## Relative Growth Rate
### Mid-June through Sept
#### lmer: diagnostics
```{r}
# Gradient / city_dist----------
rgr_gr_dist_m1 <- lmer(rel_growth_rate ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_gr_dist_m1, type='diag')
# two clear clusters and tails


rgr_gr_dist_m2 <- lmer(sqrt(rel_growth_rate) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_gr_dist_m2, type='diag')
# much better!




# Gradient / urb_score----------
rgr_gr_usc_m1 <- lmer(rel_growth_rate ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score ,
  data = heights_19_20, REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(rgr_gr_usc_m1, type='diag')
# two clear clusters and tails


rgr_gr_usc_m2 <- lmer(sqrt(rel_growth_rate) ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score ,
  data = heights_19_20, REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(rgr_gr_usc_m2, type='diag')
# much better!



# Urb sites / city_dist----------
rgr_urb_dist_m1 <- lmer(rel_growth_rate  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_urb_dist_m1, type='diag')
# two clear clusters and tails

rgr_urb_dist_m2 <- lmer(sqrt(rel_growth_rate)  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_urb_dist_m2, type='diag')
# much better! still have some tails but this is the best model.


rgr_urb_dist_m3 <- lmer((rel_growth_rate)^(1/3)  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_urb_dist_m3, type='diag')
# too much

rgr_urb_dist_m4 <- lmer(log(rel_growth_rate + 1)  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_urb_dist_m4, type='diag')
# too much

hist(heights_19_20$rel_growth_rate)


# main effects:
rgr_urb_dist_m2_ME <- lmer(sqrt(rel_growth_rate)  ~ (1|Block) + (1|Year) +(1|Population/Family) + City_dist + Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))





# Urb sites / urb_score----------
rgr_urb_usc_m1 <- lmer(rel_growth_rate  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_urb_usc_m1, type='diag')
# two clumps and left skew

rgr_urb_usc_m2 <- lmer(sqrt(rel_growth_rate)  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_urb_usc_m2, type='diag')
# much better! still tails though


rgr_urb_usc_m3 <- lmer((rel_growth_rate)^(1/3)  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score * Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

sjPlot::plot_model(rgr_urb_usc_m3, type='diag')
# too much

# main effects:
rgr_urb_usc_m2_ME <- lmer(sqrt(rel_growth_rate)  ~ (1|Block) + (1|Year) +(1|Population/Family) + Urb_score + Transect_ID,
     data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"), REML = F,
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
```

#### Entire gradient: *Nothing sig
##### City_dist
```{r}
car::Anova(rgr_gr_dist_m2)
# dist not significant

r.squaredGLMM(rgr_gr_dist_m2)

```

##### Urb_score
```{r}
car::Anova(rgr_gr_usc_m2)
# dist not significant

r.squaredGLMM(rgr_gr_usc_m2)

```

#### Urban subtransects: *nothing sig
##### City_dist
```{r}
car::Anova(rgr_urb_dist_m2)
# nothing sig

r.squaredGLMM(rgr_urb_dist_m2)


# just main effects
car::Anova(rgr_urb_dist_m2_ME)
#  nothing sig

r.squaredGLMM(rgr_urb_dist_m2_ME)

AIC((rgr_urb_dist_m2),
    (rgr_urb_dist_m2_ME)) # better but <2 AIC from full model
```

##### Urb_score
```{r}
car::Anova(rgr_urb_usc_m2)
# nothing sig

r.squaredGLMM(rgr_urb_usc_m2)


# just main effects
car::Anova(rgr_urb_usc_m2_ME)
#  nothing sig

r.squaredGLMM(rgr_urb_usc_m2_ME)

AIC((rgr_urb_usc_m2),
    (rgr_urb_usc_m2_ME)) # better model
```


## No. Ramets- nothing sig
### Mid June ramets
#### glmer: diagnostics
```{r}
# Gradient / city_dist----------
ramets_gr_dist_m1 <- glmer(Ramets_midJune ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(ramets_gr_dist_m1)
plot(res)
testOutliers(ramets_gr_dist_m1)
# looks good.




# Gradient / urb_score----------
ramets_gr_usc_m1 <- glmer(Ramets_midJune ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
  data = heights_19_20,
  family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(ramets_gr_usc_m1)
plot(res)
testOutliers(ramets_gr_usc_m1)
# looks good.



# Urb sites / city_dist----------
ramets_urb_dist_m1 <- glmer(Ramets_midJune ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
    data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(ramets_urb_dist_m1)
plot(res)
# looks good.


# main effects:
ramets_urb_dist_m2_ME <- glmer(Ramets_midJune ~ (1|Block) + (1|Year) + (1|Population/Family) +  City_dist + Transect_ID,
    data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))




# Urb sites / urb_score----------
ramets_urb_usc_m1 <- glmer(Ramets_midJune ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
    data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(ramets_urb_usc_m1)
plot(res)
testOutliers(ramets_urb_usc_m1)
# looks good.


# main effects:
ramets_urb_usc_m2_ME <- glmer(Ramets_midJune ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score + Transect_ID,
    data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
```

#### Entire gradient: *NOT sig for city_dist or urb_score
##### City_dist
```{r}
car::Anova(ramets_gr_dist_m1)
# dist not significant

r.squaredGLMM(ramets_gr_dist_m1)
```

##### Urb_score
```{r}
car::Anova(ramets_gr_usc_m1)
# dist not significant

r.squaredGLMM(ramets_gr_usc_m1)

```

#### Urban subtransects: nothing sig
##### City_dist
```{r}
car::Anova(ramets_urb_dist_m1)
# nothing sig

r.squaredGLMM(ramets_urb_dist_m1)


# just main effects
car::Anova(ramets_urb_dist_m2_ME)
# nothing sig

r.squaredGLMM(ramets_urb_dist_m2_ME)

AIC((ramets_urb_dist_m1),
    (ramets_urb_dist_m2_ME)) # better but <2 AIC from full model
```

##### Urb_score
```{r}
car::Anova(ramets_urb_usc_m1)
# nothing sig

r.squaredGLMM(ramets_urb_usc_m1)


# just main effects
car::Anova(ramets_urb_usc_m2_ME)
# nothing sig

r.squaredGLMM(ramets_urb_usc_m2_ME)

AIC((ramets_urb_usc_m1),
    (ramets_urb_usc_m2_ME)) # better but <2 AIC from full model
```


### Sept ramets
#### glmer: diagnostics
```{r}
# Gradient / city_dist----------
ramets2_gr_dist_m1 <- glmer(Ramets_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = heights_19_20,
  family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(ramets2_gr_dist_m1)
plot(res)
# looks good.




# Gradient / urb_score----------
ramets2_gr_usc_m1 <- glmer(Ramets_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
  data = heights_19_20,
  family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(ramets2_gr_usc_m1)
plot(res)
# looks good though try negative binomial to see if that'll satisfy KS test

ramets2_gr_usc_m2 <- glmmTMB(Ramets_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
  data = heights_19_20,
  family = nbinom1(),
  REML = F)
res <- simulateResiduals(ramets2_gr_usc_m2)
plot(res)
# model convergence problem... using poisson (though it doesn't make a difference... see anovas below)
car::Anova(ramets2_gr_usc_m1)
car::Anova(ramets2_gr_usc_m2)


# Urb sites / city_dist----------
ramets2_urb_dist_m1 <- glmer(Ramets_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
    data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(ramets2_urb_dist_m1)
plot(res)
# looks good.


# main effects:
ramets2_urb_dist_m2_ME <- glmer(Ramets_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) +  City_dist + Transect_ID,
    data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))




# Urb sites / urb_score----------
ramets2_urb_usc_m1 <- glmer(Ramets_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
    data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(ramets2_urb_usc_m1)
plot(res)
# looks good.


# main effects:
ramets2_urb_usc_m2_ME <- glmer(Ramets_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score + Transect_ID,
    data = heights_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = poisson,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
```

#### Entire gradient: *NOT sig for city_dist or urb_score
##### City_dist
```{r}
car::Anova(ramets2_gr_dist_m1)
# dist not significant

r.squaredGLMM(ramets2_gr_dist_m1)
```

##### Urb_score
```{r}
car::Anova(ramets2_gr_usc_m1)
# dist not significant

r.squaredGLMM(ramets2_gr_usc_m1)

```

#### Urban subtransects: nothing sig
##### City_dist
```{r}
car::Anova(ramets2_urb_dist_m1)
# nothing sig

r.squaredGLMM(ramets2_urb_dist_m1)


# just main effects
car::Anova(ramets2_urb_dist_m2_ME)
# nothing sig

r.squaredGLMM(ramets2_urb_dist_m2_ME)

AIC((ramets2_urb_dist_m1),
    (ramets2_urb_dist_m2_ME)) # better but <2 AIC from full model
```

##### Urb_score
```{r}
car::Anova(ramets2_urb_usc_m1)
# nothing sig

r.squaredGLMM(ramets2_urb_usc_m1)


# just main effects
car::Anova(ramets2_urb_usc_m2_ME)
# nothing sig

r.squaredGLMM(ramets2_urb_usc_m2_ME)

AIC((ramets2_urb_usc_m1),
    (ramets2_urb_usc_m2_ME)) # better but <2 AIC from full model
```

## Herbivory-
### Sept
#### glmer: diagnostics
```{r}
# Gradient / city_dist----------
herbivory_gr_dist_m1 <- glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = herbivory_19_20,
  family = "binomial"(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herbivory_gr_dist_m1)
plot(res)
testDispersion(herbivory_gr_dist_m1)
# qqplot looks very off... try  ????
hist(herbivory_19_20$Herbivory_mean_Sept, breaks = 30)
summary(herbivory_gr_dist_m1)


herbivory_gr_dist_m2 <- glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Family) + City_dist,
  data = herbivory_19_20,
  family = "binomial"(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
res <- simulateResiduals(herbivory_gr_dist_m2)
plot(res)

# try removing pop and making families unique
herbivory_19_20[,"FamPop"] <- paste0(herbivory_19_20$Family, "-", herbivory_19_20$Population)

herbivory_gr_dist_m3 <- glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + City_dist,
  data = herbivory_19_20,
  family = "binomial"(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

summary(herbivory_gr_dist_m3)
# trying to find where all the variance is being eaten up/accounted for and still not finding it... try beta distribution


herbivory_gr_dist_m4 <- glmmTMB(Herbivory_mean_Sept  ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = herbivory_19_20,
  family = beta_family(link="logit"))
# Error in eval(family$initialize) : y values must be 0 < y < 1
# recode: 0s as 0.00001 & 1 as 0.999999

herbivory_19_20_recode <- herbivory_19_20
herbivory_19_20_recode$Herbivory_mean_Sept[herbivory_19_20_recode$Herbivory_mean_Sept == 1] <- 0.999999
herbivory_19_20_recode$Herbivory_mean_Sept[herbivory_19_20_recode$Herbivory_mean_Sept == 0] <- 0.000001



herbivory_gr_dist_m5 <- glmmTMB(Herbivory_mean_Sept  ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
  data = herbivory_19_20_recode,
  family = beta_family(link="logit"))
res <- simulateResiduals(herbivory_gr_dist_m5)
plot(res)
# IT WORKS

hist(herbivory_19_20$Herbivory_mean_Sept, breaks = 30)
summary(herbivory_gr_dist_m5)


herbivory_gr_dist_m6 <- glmmTMB(Herbivory_mean_Sept  ~ (1|Block) + Year + (1|Population/Family) + City_dist,
  data = herbivory_19_20_recode,
  family = beta_family(link="logit"))
res <- simulateResiduals(herbivory_gr_dist_m6)
plot(res)

herbivory_gr_dist_m7 <- glmmTMB(Herbivory_mean_Sept  ~ (1|Block) + Year + (1|FamPop) + City_dist,
  data = herbivory_19_20_recode,
  family = beta_family(link="logit"))
res <- simulateResiduals(herbivory_gr_dist_m7)
plot(res)

herbivory_gr_dist_m8 <- glmmTMB(Herbivory_mean_Sept  ~  Year + (1|FamPop) + City_dist,
  data = herbivory_19_20_recode,
  family = beta_family(link="logit"))
res <- simulateResiduals(herbivory_gr_dist_m8)
plot(res)

car::Anova(herbivory_gr_dist_m7) # doesn't run
car::Anova(herbivory_gr_dist_m8)



# Gradient / urb_score----------
herbivory_gr_usc_m1 <- glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
  data = herbivory_19_20,
  family = binomial,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herbivory_gr_usc_m1)
plot(res)
# try beta

herbivory_gr_usc_m2 <- glmmTMB(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
  data = herbivory_19_20_recode,
  family = beta_family(link="logit"))

res <- simulateResiduals(herbivory_gr_usc_m2)
plot(res)


# Urb sites / city_dist----------
herbivory_urb_dist_m1 <- glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
    data = herbivory_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = binomial,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herbivory_urb_dist_m1)
plot(res)
# try beta

herbivory_urb_dist_m2 <- glmmTMB(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
  data = herbivory_19_20_recode %>% dplyr::filter(., Transect_ID != "Rural"),
  family = beta_family(link="logit"))

res <- simulateResiduals(herbivory_urb_dist_m2)
plot(res)


# main effects:
herbivory_urb_dist_m2_ME <- herbivory_urb_dist_m2 <- glmmTMB(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist + Transect_ID,
  data = herbivory_19_20_recode %>% dplyr::filter(., Transect_ID != "Rural"),
  family = beta_family(link="logit"))




# Urb sites / urb_score----------
herbivory_urb_usc_m1 <- glmer(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
    data = herbivory_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = binomial,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herbivory_urb_usc_m1)
plot(res)
# try beta

herbivory_urb_usc_m2 <- glmmTMB(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
  data = herbivory_19_20_recode %>% dplyr::filter(., Transect_ID != "Rural"),
  family = beta_family(link="logit"))

res <- simulateResiduals(herbivory_urb_usc_m2)
plot(res)


# # main effects:
herbivory_urb_usc_m2_ME <- glmmTMB(Herbivory_mean_Sept ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score + Transect_ID,
  data = herbivory_19_20_recode %>% dplyr::filter(., Transect_ID != "Rural"),
  family = beta_family(link="logit"))
```

#### Entire gradient: *NOT sig for city_dist or urb_score
##### City_dist
```{r}
car::Anova(herbivory_gr_dist_m5)
# doesn't converge with all terms... 

r.squaredGLMM(herbivory_gr_dist_m5)
```

##### Urb_score
```{r}
car::Anova(ramets_gr_usc_m1)
# dist not significant

r.squaredGLMM(ramets_gr_usc_m1)

```

#### Urban subtransects: nothing sig
##### City_dist
```{r}
car::Anova(ramets_urb_dist_m1)
# nothing sig

r.squaredGLMM(ramets_urb_dist_m1)


# just main effects
car::Anova(ramets_urb_dist_m2_ME)
# nothing sig

r.squaredGLMM(ramets_urb_dist_m2_ME)

AIC((ramets_urb_dist_m1),
    (ramets_urb_dist_m2_ME)) # better but <2 AIC from full model
```

##### Urb_score
```{r}
car::Anova(ramets_urb_usc_m1)
# nothing sig

r.squaredGLMM(ramets_urb_usc_m1)


# just main effects
car::Anova(ramets_urb_usc_m2_ME)
# nothing sig

r.squaredGLMM(ramets_urb_usc_m2_ME)

AIC((ramets_urb_usc_m1),
    (ramets_urb_usc_m2_ME)) # better but <2 AIC from full model
```


## Survival
### glmer: diagnostics
```{r}
# Gradient / city_dist----------
survival_gr_dist_m1 <- glmer(Dead ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
                               nAGQ=0,
  data = survival_19_20,
  family = binomial(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(survival_gr_dist_m1)
plot(res)
# looks great!



# Gradient / urb_score----------
survival_gr_usc_m1 <- glmer(Dead ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
  data = survival_19_20,
  family = binomial(link = "logit"), 
  nAGQ=0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(survival_gr_usc_m1)
plot(res)
# looks great!


# Urb sites / city_dist----------
survival_urb_dist_m1 <- glmer(Dead ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
 data = survival_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
   nAGQ=0,
 family = binomial(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(survival_gr_dist_m1)
plot(res)
# looks good!


# main effects:
survival_urb_dist_m1_ME <- glmer(Dead ~ (1|Block) + (1|Year) + (1|Population/Family) +  City_dist + Transect_ID,
    data = survival_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
       nAGQ=0,
    family = binomial(link = "logit"),
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))




# Urb sites / urb_score----------
survival_urb_usc_m1 <- glmer(Dead ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
    data = survival_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = binomial(link = "logit"),
       nAGQ=0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(survival_urb_usc_m1)
plot(res)
# looks good though it doesn't pass the KS test... I think it's fine though


# main effects:
survival_urb_usc_m1_ME <- glmer(Dead ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score + Transect_ID,
    data = survival_19_20 %>% dplyr::filter(., Transect_ID != "Rural"),
    family = binomial,
       nAGQ=0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
```

### Entire gradient: *Nothing sig for either
#### City_dist
```{r}
car::Anova(survival_gr_dist_m1)
# dist not significant

r.squaredGLMM(survival_gr_dist_m1)

```

#### Urb_score
```{r}
car::Anova(survival_gr_usc_m1)
# dist not significant

r.squaredGLMM(survival_gr_usc_m1)

```


### Urban subtransects: *Interaxn sig for city_dist but nothing sig for urb_score
#### City_dist
```{r}
car::Anova(survival_urb_dist_m1)
# interaction sig!

r.squaredGLMM(survival_urb_dist_m1)


# just main effects
car::Anova(survival_urb_dist_m2_ME)
#  nothing sig

r.squaredGLMM(survival_urb_dist_m2_ME)

AIC((survival_urb_dist_m1),
    (survival_urb_dist_m1_ME)) # full model better
```


#### Urb_score
```{r}
car::Anova(survival_urb_usc_m1)
# nothing sig

r.squaredGLMM(survival_urb_usc_m1)


# just main effects
car::Anova(survival_urb_usc_m1_ME)
#  nothing sig

r.squaredGLMM(survival_urb_usc_m1_ME)

AIC((survival_urb_usc_m1),
    (survival_urb_usc_m1_ME)) # better but <2 AIC from full model
```


