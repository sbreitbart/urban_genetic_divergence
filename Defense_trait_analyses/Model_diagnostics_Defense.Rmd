# Load libraries & functions
```{r}
source("libraries.R")
source("functions.R")
```

# Import data
```{r}
# SLA & LDMC-----
sla_ldmc <- read.csv(here::here("./CommonGardenExperiment_2020Data/clean_data/2020_sla_ldmc_clean.csv")) %>%
  dplyr::select(., -c(1:2)) %>%
  dplyr::mutate_at(vars(c("Population", "Family", "Replicate", "Block")), as.character) %>%
    dplyr::mutate_at(vars(c("Population", "Family", "Replicate", "Block")), as.factor)

str(sla_ldmc)
sla_ldmc %<>%
  dplyr::mutate(Fam_uniq = paste0(Population, "_", Family))


# LATEX-----
latex <- read.csv(here::here("./CommonGardenExperiment_2020Data/clean_data/2020_latex_clean.csv")) %>%
  dplyr::select(-1) %>%
  dplyr::mutate_at(vars(c(1:7, 9:12, 15, 18, 21)), as.character) %>%
    dplyr::mutate_at(vars(c(1:7, 9:12, 15, 18, 21)), as.factor) %>%
  dplyr::filter(Latex_weight_mg >= 0) %T>% # remove some negative values
  str()

latex %<>%
  dplyr::mutate(Fam_uniq = as.factor(paste0(Population, "_", Family)))

str(latex)


# HERBIVORY-----
herbivory <- read.csv(here::here("./Joined_annual_data/herbivory.csv")) %>%
  dplyr::select(-1) %>%
  dplyr::filter(Year != 2019) %>%
  dplyr::mutate_at(vars(c("Population", "Family", "Replicate", "Block", "Year", "Transect_ID", "Urb_Rur")), as.character) %>%
    dplyr::mutate_at(vars(c("Population", "Family", "Replicate", "Block", "Year", "Transect_ID", "Urb_Rur")), as.factor) %T>%
  str()

herbivory %<>%
  dplyr::mutate(Fam_uniq = as.factor(paste0(Population, "_", Family)))



# WEEVIL DAMAGE-----
weevil <- read.csv(here::here("./Joined_annual_data/weevil.csv")) %>%
  dplyr::select(-1) %>%
  dplyr::mutate_at(vars(c("Population", "Family", "Replicate", "Block", "Year", "Transect_ID", "Urb_Rur")), as.character) %>%
    dplyr::mutate_at(vars(c("Population", "Family", "Replicate", "Block", "Year", "Transect_ID", "Urb_Rur")), as.factor) %T>%
  str()

weevil %<>%
  dplyr::mutate(Fam_uniq = as.factor(paste0(Population, "_", Family)))
```

# Diagnostics: Traits only measured in 2021
## LDMC
### Gradient
#### City_dist
```{r}
# # Basic data exploration
# plot(LDMC ~ City_dist, data = sla_ldmc) # outlier > 1.5? It's biologically possible though
# plot(LDMC ~ City_dist, data = sla_ldmc %>%
#           dplyr::filter(LDMC < 1))
# 
# boxplot(LDMC ~ Block, data = sla_ldmc)
# boxplot(LDMC ~ Block, data = sla_ldmc %>%
#           dplyr::filter(LDMC < 1))


ldmc_gr_city_m1 <- glmmTMB(sqrt(LDMC) ~
                             Block +
                             (1|Population/Family) +
                             City_dist,
                        data = sla_ldmc %>%
                             dplyr::filter(LDMC < 1), # next highest LMDC is 0.7, so removing the one more than double that
                        REML = F)

# DHARMa::simulateResiduals(ldmc_gr_city_m1) %>%
#   plot
# 
# performance::check_model(ldmc_gr_city_m1)
```

#### Urb_score
```{r}
ldmc_gr_usc_m1 <- glmmTMB(sqrt(LDMC) ~
                             Block +
                             (1|Population/Family) +
                             Urb_score,
                        data = sla_ldmc %>%
                             dplyr::filter(LDMC < 1), # next highest LMDC is 0.7, so removing the one more than double that
                        REML = F)

DHARMa::simulateResiduals(ldmc_gr_usc_m1) %>%
  plot

performance::check_model(ldmc_gr_usc_m1)
```

### Urban Subtransects
#### City_dist
```{r}
# doesn't converge unless I remove block
ldmc_urbsubs_city_m1 <- glmmTMB(log(LDMC) ~
                             # Block +
                             (1|Population/Family) +
                             City_dist * Transect_ID,
                        data = sla_ldmc %>%
                             dplyr::filter(LDMC < 1 &
                                             Transect_ID != "Rural"), # next highest LMDC is 0.7, so removing the one more than double that
                        REML = F)

# DHARMa::simulateResiduals(ldmc_urbsubs_city_m1) %>%
#   plot
# 
# performance::check_model(ldmc_urbsubs_city_m1)
# 
# car::Anova(ldmc_urbsubs_city_m1,
#            type = "III") # interaxn not sig so will use type II SS
# 
# car::Anova(ldmc_urbsubs_city_m1,
#            type = "II") # interaxn not sig



# MAIN EFFECTS MODEL
ldmc_urbsubs_city_m2 <- glmmTMB(log(LDMC) ~
                             # Block +
                             (1|Population/Family) +
                             City_dist + Transect_ID,
                        data = sla_ldmc %>%
                             dplyr::filter(LDMC < 1 &
                                             Transect_ID != "Rural"), # next highest LMDC is 0.7, so removing the one more than double that
                        REML = F)
# DHARMa::simulateResiduals(ldmc_urbsubs_city_m2) %>%
#   plot
# 
# performance::check_model(ldmc_urbsubs_city_m2)
# car::Anova(ldmc_urbsubs_city_m2)
# 
# # COMPARE AIC
# AIC(ldmc_urbsubs_city_m1, ldmc_urbsubs_city_m2) # m2 lower but not by more than 2 AIC
```

#### Urb_score
```{r}
ldmc_urbsubs_usc_m1 <- glmmTMB(log(LDMC) ~
                             Block +
                             (1|Population/Family) +
                             Urb_score * Transect_ID,
                        data = sla_ldmc %>%
                             dplyr::filter(LDMC < 1 &
                                             Transect_ID != "Rural"), # next highest LMDC is 0.7, so removing the one more than double that
                        REML = F)

DHARMa::simulateResiduals(ldmc_urbsubs_usc_m1) %>%
  plot

performance::check_model(ldmc_urbsubs_usc_m1)

car::Anova(ldmc_urbsubs_usc_m1,
           type = "III") # interaxn not sig so will use type II SS

car::Anova(ldmc_urbsubs_usc_m1,
           type = "II") # interaxn not sig



# MAIN EFFECTS MODEL
ldmc_urbsubs_usc_m2 <- glmmTMB(log(LDMC) ~
                             Block +
                             (1|Population/Family) +
                             Urb_score + Transect_ID,
                        data = sla_ldmc %>%
                             dplyr::filter(LDMC < 1 &
                                             Transect_ID != "Rural"), # next highest LMDC is 0.7, so removing the one more than double that
                        REML = F)
DHARMa::simulateResiduals(ldmc_urbsubs_usc_m2) %>%
  plot

performance::check_model(ldmc_urbsubs_usc_m2)
car::Anova(ldmc_urbsubs_usc_m2)

# COMPARE AIC
AIC(ldmc_urbsubs_usc_m1, ldmc_urbsubs_usc_m2) # m2 lower but not by more than 2 AIC
```

## SLA
### Gradient
#### City_dist
```{r}
# sla_gr_city_m1 <- glmmTMB(SLA ~ (1|Block) + (1|Population/Family) + City_dist,
#                         data = sla_ldmc,
#                         REML = F)
# 
# performance::check_model(sla_gr_city_m1) 
# 
# # use fam_uniq, see if anything changes
# performance::check_model(update(sla_gr_city_m1, . ~ (1|Block) + (1|Population:Fam_uniq) + City_dist)) 
# 
# 
# 
# # Try IDing outlier residuals, removing from df, and rerunning model
# LargeResiduals <- resid(sla_gr_city_m1) > 50
# # 101, 170, 220, 304, 410, 444, 787
# 
# lg_resids <- sla_ldmc %>%
#   dplyr::slice(101, 170, 220, 304, 410, 444, 787)
# 
# sla_without_lgresids <- anti_join(sla_ldmc, lg_resids)
# 
# 
# sla_gr_city_m1_no_lg_resids <- glmmTMB(SLA ~ (1|Block) + (1|Population/Family) + City_dist,
#                         data = sla_without_lgresids,
#                         REML = F)
# 
# performance::check_model(sla_gr_city_m1_no_lg_resids) 
# 
# 
# car::Anova(sla_gr_city_m1) # same result as third model
# car::Anova(sla_gr_city_m1_no_lg_resids) # still qualitatively same result as other two models (p >> 0.1)
# car::Anova(update(sla_gr_city_m1, . ~ (1|Block) + (1|Population:Fam_uniq) + City_dist)) # same result as first model
# 

sla_gr_city_m1 <- glmmTMB(SLA ~ (1|Block) + (1|Population:Fam_uniq) + City_dist,
                        data = sla_ldmc,
                        REML = F)

```

#### Urb_score
```{r}
# sla_gr_usc_m1 <- glmmTMB(SLA ~ (1|Block) + (1|Population/Family) + Urb_score,
#                         data = sla_ldmc,
#                         REML = F)
# 
# performance::check_model(sla_gr_usc_m1) # try sqrt transformation
# 
# performance::check_model(update(sla_gr_usc_m1, sqrt(SLA) ~ .)) # looks better
# 
# # try with fam_uniq- looks same as above
# performance::check_model(update(sla_gr_usc_m1, sqrt(SLA) ~ (1|Block) + (1|Population:Fam_uniq) + Urb_score))
# 
# car::Anova(sla_gr_usc_m1) # lowest p-val but still >>0.1 so qualitatively same as other models
# car::Anova(update(sla_gr_usc_m1, sqrt(SLA) ~ .)) # same as third model
# car::Anova(update(sla_gr_usc_m1, sqrt(SLA) ~ (1|Block) + (1|Population:Fam_uniq) + Urb_score)) # same as second model

sla_gr_usc_m1 <- glmmTMB(sqrt(SLA) ~ (1|Block) + (1|Population:Fam_uniq) + Urb_score,
                        data = sla_ldmc,
                        REML = F)
```

### Urban Subtransects
#### City_dist
```{r}
# sla_urbsubs_city_m1 <- glmmTMB(SLA ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#                         data = sla_ldmc %>%
#                           dplyr::filter(Transect_ID != "Rural"),
#                         REML = F)
# 
# performance::check_model(sla_urbsubs_city_m1) # seems ok but try sqrt
# 
# performance::check_model(update(sla_urbsubs_city_m1, sqrt(SLA) ~ .)) # looks a bit better
# 
# # No interaxns sig for either so use type II SS
# car::Anova(sla_urbsubs_city_m1, type = "III")
# car::Anova(update(sla_urbsubs_city_m1, sqrt(SLA) ~ .), type = "III")
# car::Anova(update(sla_urbsubs_city_m1, sqrt(SLA) ~ (1|Block) + (1|Population:Fam_uniq) + City_dist * Transect_ID), type = "III")
# 
# # Qualitatively identical again
# car::Anova(sla_urbsubs_city_m1, type = "II")
# car::Anova(update(sla_urbsubs_city_m1, sqrt(SLA) ~ .), type = "II")
# car::Anova(update(sla_urbsubs_city_m1, sqrt(SLA) ~ (1|Block) + (1|Population:Fam_uniq) + City_dist * Transect_ID), type = "II")


sla_urbsubs_city_m1 <- glmmTMB(sqrt(SLA) ~ (1|Block) + (1|Population:Fam_uniq) + City_dist * Transect_ID,
                        data = sla_ldmc %>%
                          dplyr::filter(Transect_ID != "Rural"),
                        REML = F)

# MAIN EFFECTS
sla_urbsubs_city_m2 <- glmmTMB(sqrt(SLA) ~ (1|Block) + (1|Population:Fam_uniq) + City_dist + Transect_ID,
                        data = sla_ldmc %>%
                          dplyr::filter(Transect_ID != "Rural"),
                        REML = F)

# AIC(sla_urbsubs_city_m1, sla_urbsubs_city_m2) # qualitatively identical but m2 best model
```

#### Urb_score
```{r}
# sla_urbsubs_usc_m1 <- glmmTMB(SLA ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#                         data = sla_ldmc %>%
#                           dplyr::filter(Transect_ID != "Rural"),
#                         REML = F)
# 
# performance::check_model(sla_urbsubs_usc_m1) # seems ok but try sqrt
# 
# performance::check_model(update(sla_urbsubs_usc_m1, sqrt(SLA) ~ .)) # looks a bit better
# 
# # these are identical
# car::Anova(update(sla_urbsubs_usc_m1, sqrt(SLA) ~ .), type = "III") # interaxn not sig
# car::Anova(update(sla_urbsubs_usc_m1, sqrt(SLA) ~ (1|Block) + (1|Population:Fam_uniq) + Urb_score * Transect_ID), type = "III") # interaxn not sig
# 
# 
# 
# # Qualitatively identical again
# car::Anova(update(sla_urbsubs_usc_m1, sqrt(SLA) ~ .), type = "II")
# car::Anova(update(sla_urbsubs_usc_m1, sqrt(SLA) ~ (1|Block) + (1|Population:Fam_uniq) + Urb_score * Transect_ID), type = "II")


sla_urbsubs_usc_m1 <- glmmTMB(sqrt(SLA) ~ (1|Block) + (1|Population:Fam_uniq) + Urb_score * Transect_ID,
                        data = sla_ldmc %>%
                          dplyr::filter(Transect_ID != "Rural"),
                        REML = F)

# MAIN EFFECTS
sla_urbsubs_usc_m2 <- glmmTMB(sqrt(SLA) ~ (1|Block) + (1|Population:Fam_uniq) + Urb_score + Transect_ID,
                        data = sla_ldmc %>%
                          dplyr::filter(Transect_ID != "Rural"),
                        REML = F)

# AIC(sla_urbsubs_usc_m1, sla_urbsubs_usc_m2) # qualitatively identical but m2 best model
```

## Latex
### Gradient
#### City_dist
```{r}
# sqrt looks better
ltx_gr_city_m1 <- glmmTMB(sqrt(Latex_weight_mg) ~
                            (1|Block) +
                            (1|Population/Family) +
                            City_dist,
                        data = latex,
                        REML = F)


performance::check_model(ltx_gr_city_m1)
plot(DHARMa::simulateResiduals(ltx_gr_city_m1))

car::Anova(ltx_gr_city_m1)
summary(ltx_gr_city_m1)
r.squaredGLMM(ltx_gr_city_m1) # super low R2m
AIC(ltx_gr_city_m1)


# MAKE BLOCK FIXED #
ltx_gr_city_m2 <- glmmTMB(sqrt(Latex_weight_mg) ~
                            Block +
                            (1|Population/Family) +
                            City_dist,
                        data = latex,
                        REML = F)


performance::check_model(ltx_gr_city_m2)

car::Anova(ltx_gr_city_m2)
summary(ltx_gr_city_m2)
r.squaredGLMM(ltx_gr_city_m2) # R2m is higher- block explains sig amt of variance
AIC(ltx_gr_city_m2) # AIC >2 from other model too
```

#### Urb_score
```{r}
ltx_gr_usc_m1 <- glmmTMB(Latex_weight_mg ~ (1|Block) + (1|Population/Family) + Urb_score,
                        data = latex,
                        REML = F)

# performance::check_model(ltx_gr_usc_m1) 
# 
# # use fam_uniq, see if anything changes
# performance::check_model(update(ltx_gr_usc_m1, . ~ (1|Block) + (1|Population:Fam_uniq) + Urb_score)) 
# 
# # there is a diff (qualitatively identical though). So use Pop/Fam. P < 0.01 in both cases
# car::Anova(ltx_gr_usc_m1)
# car::Anova(update(ltx_gr_usc_m1, . ~ (1|Block) + (1|Fam_uniq) + Urb_score))

```

### Urban Subtransects
#### City_dist
```{r}
# ltx_urbsubs_city_m1 <- glmmTMB(Latex_weight_mg ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#                         data = latex %>%
#                           dplyr::filter(Transect_ID != "Rural"),
#                         REML = F)
# 
# performance::check_model(ltx_urbsubs_city_m1) # try sqrt
# 
# performance::check_model(update(ltx_urbsubs_city_m1, Latex_weight_mg^(1/2) ~ .)) # looks better
# 
# 
# # use fam_uniq, see if anything changes
# performance::check_model(update(ltx_urbsubs_city_m1, Latex_weight_mg^(1/2) ~ (1|Block) + (1|Population:Fam_uniq) + City_dist* Transect_ID)) 
# 
# # there is a diff (qualitatively identical though). So use Pop/Fam
# ## interaxn not sig, so use type II SS
# car::Anova(update(ltx_urbsubs_city_m1, Latex_weight_mg^(1/2) ~ (1|Block) + (1|Population/Family) + City_dist* Transect_ID), type = "III")
# car::Anova(update(ltx_urbsubs_city_m1, Latex_weight_mg^(1/2) ~ (1|Block) + (1|Fam_uniq) + City_dist* Transect_ID), type = "III")
# 
# ## interaxn not sig, so use type II SS
# car::Anova(update(ltx_urbsubs_city_m1, Latex_weight_mg^(1/2) ~ (1|Block) + (1|Population/Family) + City_dist* Transect_ID), type = "II")
# car::Anova(update(ltx_urbsubs_city_m1, Latex_weight_mg^(1/2) ~ (1|Block) + (1|Fam_uniq) + City_dist* Transect_ID), type = "II")

# final model
ltx_urbsubs_city_m1 <- glmmTMB(sqrt(Latex_weight_mg) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
                        data = latex %>%
                          dplyr::filter(Transect_ID != "Rural"),
                        REML = F)



# MAIN EFFECTS MODEL
# ltx_urbsubs_city_m2 <- glmmTMB(Latex_weight_mg ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
#                         data = latex %>%
#                           dplyr::filter(Transect_ID != "Rural"),
#                         REML = F)
# 
# performance::check_model(ltx_urbsubs_city_m2) # try sqrt again
# 
# performance::check_model(update(ltx_urbsubs_city_m2, Latex_weight_mg^(1/2) ~ .)) # looks better
# 
# 
# # use fam_uniq, see if anything changes
# performance::check_model(update(ltx_urbsubs_city_m2, Latex_weight_mg^(1/2) ~ (1|Block) + (1|Population:Fam_uniq) + City_dist + Transect_ID)) 
# 
# # there is a diff (qualitatively identical though). So use Pop/Fam
# car::Anova(update(ltx_urbsubs_city_m2, Latex_weight_mg^(1/2) ~ .), type = "II")
# car::Anova(update(ltx_urbsubs_city_m2, Latex_weight_mg^(1/2) ~ (1|Block) + (1|Fam_uniq) + City_dist + Transect_ID), type = "II")


# final ME model
ltx_urbsubs_city_m2 <- glmmTMB(sqrt(Latex_weight_mg) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
                        data = latex %>%
                          dplyr::filter(Transect_ID != "Rural"),
                        REML = F)

# AIC(ltx_urbsubs_city_m1, ltx_urbsubs_city_m2) # m2 best but <2 AIC away
```

#### Urb_score
```{r}
# ltx_urbsubs_usc_m1 <- glmmTMB(Latex_weight_mg ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#                         data = latex %>%
#                           dplyr::filter(Transect_ID != "Rural"),
#                         REML = F)
# 
# performance::check_model(ltx_urbsubs_usc_m1) # try sqrt
# 
# performance::check_model(update(ltx_urbsubs_usc_m1, Latex_weight_mg^(1/2) ~ .)) # looks better
# 
# 
# # use fam_uniq, see if anything changes
# performance::check_model(update(ltx_urbsubs_usc_m1, Latex_weight_mg^(1/2) ~ (1|Block) + (1|Population:Fam_uniq) + Urb_score* Transect_ID)) 
# 
# # there is a diff (qualitatively identical though). So use Pop/Fam
# ## interaxn sig for both
# car::Anova(update(ltx_urbsubs_usc_m1, Latex_weight_mg^(1/2) ~ (1|Block) + (1|Population/Family) + Urb_score* Transect_ID), type = "III")
# car::Anova(update(ltx_urbsubs_usc_m1, Latex_weight_mg^(1/2) ~ (1|Block) + (1|Fam_uniq) + Urb_score* Transect_ID), type = "III")


# final model
ltx_urbsubs_usc_m1 <- glmmTMB(sqrt(Latex_weight_mg) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
                        data = latex %>%
                          dplyr::filter(Transect_ID != "Rural"),
                        REML = F)



# MAIN EFFECTS MODEL
# ltx_urbsubs_usc_m2 <- glmmTMB(Latex_weight_mg ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
#                         data = latex %>%
#                           dplyr::filter(Transect_ID != "Rural"),
#                         REML = F)
# 
# performance::check_model(ltx_urbsubs_usc_m2) # try sqrt again
# 
# performance::check_model(update(ltx_urbsubs_usc_m2, Latex_weight_mg^(1/2) ~ .)) # looks better
# 
# 
# # use fam_uniq, see if anything changes
# performance::check_model(update(ltx_urbsubs_usc_m2, Latex_weight_mg^(1/2) ~ (1|Block) + (1|Population:Fam_uniq) + Urb_score + Transect_ID)) 
# 
# # there is a diff (qualitatively identical though). So use Pop/Fam
# car::Anova(update(ltx_urbsubs_usc_m2, Latex_weight_mg^(1/2) ~ .), type = "II")
# car::Anova(update(ltx_urbsubs_usc_m2, Latex_weight_mg^(1/2) ~ (1|Block) + (1|Fam_uniq) + Urb_score + Transect_ID), type = "II")


# final ME model
ltx_urbsubs_usc_m2 <- glmmTMB(sqrt(Latex_weight_mg) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
                        data = latex %>%
                          dplyr::filter(Transect_ID != "Rural"),
                        REML = F)

# AIC(ltx_urbsubs_usc_m1, ltx_urbsubs_usc_m2) # m1 best
```


# Diagnostics: Traits measured in 2019, 2020, and 2021
## Herbivory: Before flowering- 2020 and 2021 ONLY
### Gradient
#### City_dist
##### Block and year are random
```{r}
# OLD DIAGNOSTICS-----
# herbiv_e_gr_dist_m1 <- glmmTMB(Herbivory_mean_early ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
#                               data = herbivory,
#                               REML = F) # convergence issue
# 
# performance::check_model(herbiv_e_gr_dist_m1) # very right-skewed. try sqrt transformation
# 
# performance::check_model(update(herbiv_e_gr_dist_m1, sqrt(Herbivory_mean_early) ~ .)) # better but still very right-skewed. try cube root transformation
# 
# performance::check_model(update(herbiv_e_gr_dist_m1, (Herbivory_mean_early)^(1/3) ~ .)) # better but still skewed. Is this good enough?
# 
# 
# hist(herbivory$Herbivory_mean_early, breaks = 50) # zero-inflated?
# 
# 
# performance::check_model(
#   glmmTMB(Herbivory_mean_early^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
#                               data = herbivory,
#           ziformula = ~1,
#                               REML = F)
# ) # still some heavy tails but looks better
# 
# # doesn't work
# car::Anova(
#   glmmTMB(Herbivory_mean_early^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
#                               data = herbivory,
#           ziformula = ~1,
#                               REML = F)
# ) 
# 
# performance::check_model(
#   glmmTMB(Herbivory_mean_early^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
#                               data = herbivory %>%
#             dplyr::filter(Year != "2021"),
#           ziformula = ~1,
#                               REML = F)
# ) # 2020 looks better than 2021
# 
# 
# # just curious- take out 0s
# performance::check_model(
#   glmmTMB(Herbivory_mean_early^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
#                               data = herbivory %>%
#             dplyr::filter(Year != "2021" & Herbivory_mean_early > 0),
#           ziformula = ~1,
#                               REML = F)
# ) # looks better...
# 
# 
# # create bins for herbivory: Low, medium, high
# herbivory %<>%
#   dplyr::mutate(early_quantiles = cut(Herbivory_mean_early,
#                                breaks=c(0, 0.05, 0.2, 0.4, 1),
#                               labels=c("very_low", "low","middle","high")))
# 
# performance::check_model(
#   glmmTMB(early_levels ~ (1|Year) + (1|Block) + (1|Population/Family) + City_dist,
#                               data = herbivory,
#                                REML = F)) # very bimodal residuals
# 
# 
# # TRY BETA FAMILY
# herbivory$Herbivory_mean_early_recode <- herbivory$Herbivory_mean_early
# herbivory$Herbivory_mean_early_recode[herbivory$Herbivory_mean_early_recode == 1] <- 0.999999
# herbivory$Herbivory_mean_early_recode[herbivory$Herbivory_mean_early_recode == 0] <- 0.000001

# test1 <- glmmTMB(Herbivory_mean_early_recode  ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
#                                 data = herbivory,
#                                 family = beta_family(link="logit"),
#                                REML = F)
# performance::check_model(test1) # heavy right tail




# TRY HURDLE MODEL-----
# first, create new column with 0/1 indicating any herbivory
herbivory %<>%
  mutate(Herbivory_mean_early_binary = case_when(
    Herbivory_mean_early == 0 ~ 0,
    Herbivory_mean_early > 0 ~ 1)
  )

herbiv_e_gr_dist_m1_bin <- glmmTMB(Herbivory_mean_early_binary ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                City_dist,
                              data = herbivory,
                       family = binomial,
                              REML = F)

# Check model assumptions
# plot(DHARMa::simulateResiduals(herbiv_e_gr_dist_m1_bin)) # looks great

# car::Anova(herbiv_e_gr_dist_m1_bin)
r.squaredGLMM((herbiv_e_gr_dist_m1_bin)) # R2m = 0.002


# quantitative model
herbiv_e_gr_dist_m1_quant <- glmmTMB(log(Herbivory_mean_early) ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                City_dist,
                              data = herbivory %>%
                        dplyr::filter(
                          Herbivory_mean_early_binary == 1),
                              REML = F) # log-transformed after looking at untransformed, sqrt, cube root models

# Check model assumptions
# plot(DHARMa::simulateResiduals(herbiv_e_gr_dist_m1_quant)) # looks great
# 
# performance::check_model(herbiv_e_gr_dist_m1_quant) # looks great
# 
# car::Anova(herbiv_e_gr_dist_m1_quant)
```

##### Block and year are fixed
```{r}
# herbiv_e_gr_dist_m1 <- glmmTMB(Herbivory_mean_early^(1/3) ~
#                                  Block +
#                                  Year +
#                                  (1|Population/Family) +
#                                  City_dist,
#                               data = herbivory,
#                               REML = F) # convergence issue
# 
# plot(DHARMa::simulateResiduals(herbiv_e_gr_dist_m1)) # still problematic
# 
# hist(herbivory$Herbivory_mean_early, breaks = 50) # zero-inflated?
# 
# # try binomial- still problematic
# plot(
#   DHARMa::simulateResiduals(
#     glmmTMB(Herbivory_mean_early ~
#                   Block +
#                   Year +
#                   (1|Population/Family) +
#                   City_dist,
#                 data = herbivory,
#                 family = binomial,
#                 REML = F)
#     )
#   )
# 
# performance::check_model(
#     glmmTMB(Herbivory_mean_early ~
#                   Block +
#                   Year +
#                   (1|Population/Family) +
#                   City_dist,
#                 data = herbivory,
#                 family = binomial,
#                 REML = F)
#     )
# 
# # TRY BETA FAMILY
# herbivory$Herbivory_mean_early_recode <- herbivory$Herbivory_mean_early
# herbivory$Herbivory_mean_early_recode[herbivory$Herbivory_mean_early_recode == 1] <- 0.999999
# herbivory$Herbivory_mean_early_recode[herbivory$Herbivory_mean_early_recode == 0] <- 0.000001
# 
# test1 <- glmmTMB(Herbivory_mean_early_recode  ~
#                    Block +
#                    Year +
#                    (1|Population/Family) +
#                    City_dist,
#                                 data = herbivory,
#                                 family = beta_family(link="logit"),
#                                REML = F)
# performance::check_model(test1) # heavy right tail
# plot(DHARMa::simulateResiduals(test1))


# TRY HURDLE MODEL-----
# first, create new column with 0/1 indicating any herbivory
herbivory %<>%
  mutate(Herbivory_mean_early_binary = case_when(
    Herbivory_mean_early == 0 ~ 0,
    Herbivory_mean_early > 0 ~ 1)
  )

herbiv_e_gr_dist_m1_bin <- glmmTMB(Herbivory_mean_early_binary ~
                               Block +
                               Year + 
                               (1|Population/Family) +
                                City_dist,
                              data = herbivory,
                       family = binomial,
                              REML = F)

# Check model assumptions
plot(DHARMa::simulateResiduals(herbiv_e_gr_dist_m1_bin)) # looks great

car::Anova(herbiv_e_gr_dist_m1_bin)
r.squaredGLMM((herbiv_e_gr_dist_m1_bin)) # R2m = 0.09


# quantitative model
herbiv_e_gr_dist_m1_quant <- glmmTMB(log(Herbivory_mean_early) ~
                               Block +
                               Year + 
                               (1|Population/Family) +
                                City_dist,
                              data = herbivory %>%
                        dplyr::filter(
                          Herbivory_mean_early_binary == 1),
                              REML = F) # log-transformed after looking at untransformed, sqrt, cube root models

# Check model assumptions
plot(DHARMa::simulateResiduals(herbiv_e_gr_dist_m1_quant)) # looks great
performance::check_model(herbiv_e_gr_dist_m1_quant) # looks great
car::Anova(herbiv_e_gr_dist_m1_quant)
```


#### Urb_score
```{r}
# OLD DIAGNOSTICS-----
# herbiv_e_gr_usc_m1 <- glmmTMB(Herbivory_mean_early ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
#                               data = herbivory,
#                               REML = F) 
# 
# performance::check_model(herbiv_e_gr_usc_m1) # very right-skewed. try sqrt transformation
# 
# performance::check_model(update(herbiv_e_gr_usc_m1, sqrt(Herbivory_mean_early) ~ .)) # better but still very right-skewed. try cube root transformation
# 
# performance::check_model(update(herbiv_e_gr_usc_m1, (Herbivory_mean_early)^(1/3) ~ .)) # better but still skewed. Is this good enough?
# 
# 
# performance::check_model(
#   glmmTMB(Herbivory_mean_early^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
#                               data = herbivory,
#           ziformula = ~1,
#                               REML = F)
# ) # still some heavy tails but looks better
# 
# 
# 
# # try bins
# performance::check_model(
#   glmmTMB(early_levels ~ (1|Year) + (1|Block) + (1|Population/Family) + Urb_score,
#                               data = herbivory,
#                                REML = F)) # very bimodal residuals
# 
# 
# 
# 
# # TRY BETA FAMILY
# test1 <- glmmTMB(Herbivory_mean_early_recode  ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
#                                 data = herbivory,
#                                 family = beta_family(link="logit"),
#                                REML = F)
# performance::check_model(test1) # heavy right tail


# TRY HURDLE MODEL-----
herbiv_e_gr_usc_m1_bin <- glmmTMB(Herbivory_mean_early_binary ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                Urb_score,
                              data = herbivory,
                       family = binomial,
                              REML = F)

# Check model assumptions
# plot(DHARMa::simulateResiduals(herbiv_e_gr_usc_m1_bin)) # looks great
# 
# car::Anova(herbiv_e_gr_usc_m1_bin)


# quantitative model
herbiv_e_gr_usc_m1_quant <- glmmTMB(log(Herbivory_mean_early) ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                Urb_score,
                              data = herbivory %>%
                        dplyr::filter(
                          Herbivory_mean_early_binary == 1),
                              REML = F) # log-transformed after looking at untransformed, sqrt, cube root models

# Check model assumptions
# plot(DHARMa::simulateResiduals(herbiv_e_gr_usc_m1_quant)) # looks great
# 
# performance::check_model(herbiv_e_gr_usc_m1_quant) # looks great
# 
# car::Anova(herbiv_e_gr_usc_m1_quant)

```

### Urban Subtransects
#### City_dist
```{r}
# OLD DIAGNOSTICS-----
# herbiv_e_urbsubs_dist_m1 <- glmmTMB(Herbivory_mean_early ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
#                               data = herbivory %>%
#                                 dplyr::filter(Transect_ID != "Rural"),
#                               REML = F) # convergence issue. Try taking out block
# 
# 
# performance::check_model(glmmTMB(Herbivory_mean_early ~  (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
#                               data = herbivory %>%
#                                 dplyr::filter(Transect_ID != "Rural")),
#                               REML = F) # very right-skewed. try sqrt transformation
# 
# 
# performance::check_model(glmmTMB(Herbivory_mean_early^(1/2) ~  (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
#                               data = herbivory %>%
#                                 dplyr::filter(Transect_ID != "Rural")),
#                               REML = F) # better but still very right-skewed. try cube root transformation
# 
# 
# performance::check_model(glmmTMB(Herbivory_mean_early^(1/3) ~  (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
#                               data = herbivory %>%
#                                 dplyr::filter(Transect_ID != "Rural")),
#                               REML = F) # better. Put back block, see if it runs
# 
# performance::check_model(glmmTMB(Herbivory_mean_early^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
#                               data = herbivory %>%
#                                 dplyr::filter(Transect_ID != "Rural")),
#                               REML = F) # doesn't run
# 
# 
# Compare w/beta distribution
# plot(DHARMa::simulateResiduals(glmmTMB(Herbivory_mean_early_recode  ~  (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
#                                 data = herbivory %>%
#                                 dplyr::filter(Transect_ID != "Rural"),
#                                 family = beta_family(link="logit"),
#                                REML = F))) # issues with residuals and KS test

# TRY HURDLE MODEL-----
herbiv_e_urbsubs_dist_m1_bin <- glmmTMB(Herbivory_mean_early_binary ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                City_dist * Transect_ID,
                              data = herbivory %>%
                                dplyr::filter(Transect_ID != "Rural"),
                       family = binomial,
                              REML = F)

# Check model assumptions
# plot(DHARMa::simulateResiduals(herbiv_e_urbsubs_dist_m1_bin)) # looks great
# 
# car::Anova(herbiv_e_urbsubs_dist_m1_bin)


# quantitative model
herbiv_e_urbsubs_dist_m1_quant <- glmmTMB(log(Herbivory_mean_early) ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                City_dist * Transect_ID,
                              data = herbivory %>%
                        dplyr::filter(
                          Herbivory_mean_early_binary == 1 & Transect_ID != "Rural"),
                              REML = F) # log-transformed after looking at untransformed, sqrt, cube root models

# Check model assumptions
# plot(DHARMa::simulateResiduals(herbiv_e_urbsubs_dist_m1_quant)) # looks great



# MAIN EFFECTS MODELS
## BINARY
herbiv_e_urbsubs_dist_m2_bin <- glmmTMB(Herbivory_mean_early_binary ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                City_dist + Transect_ID,
                              data = herbivory %>%
                                dplyr::filter(Transect_ID != "Rural"),
                       family = binomial,
                              REML = F)

# Check model assumptions
plot(DHARMa::simulateResiduals(herbiv_e_urbsubs_dist_m2_bin)) # looks great

AIC(herbiv_e_urbsubs_dist_m1_bin, herbiv_e_urbsubs_dist_m2_bin) # m1 better but <2 AIC apart



# QUANTITATIVE
herbiv_e_urbsubs_dist_m2_quant <- glmmTMB(log(Herbivory_mean_early) ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                City_dist + Transect_ID,
                              data = herbivory %>%
                        dplyr::filter(
                          Herbivory_mean_early_binary == 1 & Transect_ID != "Rural"),
                              REML = F) # log-transformed after looking at untransformed, sqrt, cube root models

# Check model assumptions
# plot(DHARMa::simulateResiduals(herbiv_e_urbsubs_dist_m2_quant)) # looks great
# 
# AIC(herbiv_e_urbsubs_dist_m1_quant, herbiv_e_urbsubs_dist_m2_quant) # m1 better but <2 AIC apart
```

#### Urb_score
```{r}
# TRY HURDLE MODEL-----
herbiv_e_urbsubs_usc_m1_bin <- glmmTMB(Herbivory_mean_early_binary ~
                             #  (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                Urb_score * Transect_ID,
                              data = herbivory %>%
                                dplyr::filter(Transect_ID != "Rural"),
                       family = binomial,
                              REML = F) # doesn't converge as a full model

# Check model assumptions
# plot(DHARMa::simulateResiduals(herbiv_e_urbsubs_usc_m1_bin)) # looks great


# quantitative model
herbiv_e_urbsubs_usc_m1_quant <- glmmTMB(log(Herbivory_mean_early) ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                Urb_score * Transect_ID,
                              data = herbivory %>%
                        dplyr::filter(
                          Herbivory_mean_early_binary == 1 & Transect_ID != "Rural"),
                              REML = F) # log-transformed after looking at untransformed, sqrt, cube root models

# Check model assumptions
# plot(DHARMa::simulateResiduals(herbiv_e_urbsubs_usc_m1_quant)) # looks great



# MAIN EFFECTS MODELS
## BINARY
herbiv_e_urbsubs_usc_m2_bin <- glmmTMB(Herbivory_mean_early_binary ~
                            #   (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                Urb_score + Transect_ID,
                              data = herbivory %>%
                                dplyr::filter(Transect_ID != "Rural"),
                       family = binomial,
                              REML = F)

# Check model assumptions
# plot(DHARMa::simulateResiduals(herbiv_e_urbsubs_usc_m2_bin)) # looks great
# 
# AIC(herbiv_e_urbsubs_usc_m1_bin, herbiv_e_urbsubs_usc_m2_bin) # m2 better but <2 AIC apart



# QUANTITATIVE
herbiv_e_urbsubs_usc_m2_quant <- glmmTMB(log(Herbivory_mean_early) ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                Urb_score + Transect_ID,
                              data = herbivory %>%
                        dplyr::filter(
                          Herbivory_mean_early_binary == 1 & Transect_ID != "Rural"),
                              REML = F) # log-transformed after looking at untransformed, sqrt, cube root models

# Check model assumptions
# plot(DHARMa::simulateResiduals(herbiv_e_urbsubs_usc_m2_quant)) # looks great
# 
# AIC(herbiv_e_urbsubs_usc_m1_quant, herbiv_e_urbsubs_usc_m2_quant) # m1 better but <2 AIC apart
```


## Herbivory: After flowering
### Gradient
#### City_dist
```{r}
# OLD DIAGNOSTICS-----
# herbiv_l_gr_dist_m1 <- glmmTMB(Herbivory_mean_late ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
#                               data = herbivory,
#                               REML = F) # convergence issue
# 
# performance::check_model(herbiv_l_gr_dist_m1) # very right-skewed. try cube root transformation
# 
# performance::check_model(update(herbiv_l_gr_dist_m1, Herbivory_mean_late^(1/3) ~ .)) # still not converging and I think beta is better choice
# 

# BETA FAMILY
# herbivory$Herbivory_mean_late_recode <- herbivory$Herbivory_mean_late
# herbivory$Herbivory_mean_late_recode[herbivory$Herbivory_mean_late_recode == 1] <- 0.999999
# herbivory$Herbivory_mean_late_recode[herbivory$Herbivory_mean_late_recode == 0] <- 0.000001
# 
# test1 <- glmmTMB(Herbivory_mean_late_recode  ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
#                                 data = herbivory,
#                                 family = beta_family(link="logit"),
#                                REML = F)
# performance::check_model(test1) # heavy right tail


# TRY HURDLE MODEL-----
# first, create new column with 0/1 indicating any herbivory
herbivory %<>%
  mutate(Herbivory_mean_late_binary = case_when(
    Herbivory_mean_late == 0 ~ 0,
    Herbivory_mean_late > 0 ~ 1)
  )

herbiv_l_gr_dist_m1_bin <- glmmTMB(Herbivory_mean_late_binary ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                City_dist,
                              data = herbivory,
                       family = binomial,
                              REML = F)

# Check model assumptions
# plot(DHARMa::simulateResiduals(herbiv_l_gr_dist_m1_bin)) # looks good enough
# car::Anova(herbiv_l_gr_dist_m1_bin)


# quantitative model
herbiv_l_gr_dist_m1_quant <- glmmTMB(log(Herbivory_mean_late) ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                City_dist,
                              data = herbivory %>%
                        dplyr::filter(
                          Herbivory_mean_late_binary == 1),
                              REML = F) # log-transformed after looking at untransformed, sqrt, cube root models

# Check model assumptions
# plot(DHARMa::simulateResiduals(herbiv_l_gr_dist_m1_quant)) # looks good enough
# 
# performance::check_model(herbiv_l_gr_dist_m1_quant) # looks great
# 
# car::Anova(herbiv_l_gr_dist_m1_quant)

```

#### Urbanization Score
```{r}
# OLD DIAGNOSTICS-----
# test1 <- glmmTMB(Herbivory_mean_late_recode  ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
#                                 data = herbivory,
#                                 family = beta_family(link="logit"),
#                                 REML = F)
# performance::check_model(test1) # heavy right tail
# TRY HURDLE MODEL-----
herbiv_l_gr_usc_m1_bin <- glmmTMB(Herbivory_mean_late_binary ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                Urb_score,
                              data = herbivory,
                       family = binomial,
                              REML = F)

# Check model assumptions
# plot(DHARMa::simulateResiduals(herbiv_l_gr_usc_m1_bin)) # looks good enough
# car::Anova(herbiv_l_gr_usc_m1_bin)


# quantitative model
herbiv_l_gr_usc_m1_quant <- glmmTMB(log(Herbivory_mean_late) ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                Urb_score,
                              data = herbivory %>%
                        dplyr::filter(
                          Herbivory_mean_late_binary == 1),
                              REML = F) # log-transformed after looking at untransformed, sqrt, cube root models

# Check model assumptions
# plot(DHARMa::simulateResiduals(herbiv_l_gr_usc_m1_quant)) # looks good enough
# 
# performance::check_model(herbiv_l_gr_usc_m1_quant) # looks great
# 
# car::Anova(herbiv_l_gr_usc_m1_quant)
```

### Urban Subtransects
#### City_dist
```{r}
# OLD DIAGNOSTICS-----
# BETA FAMILY
# test1 <- glmmTMB(Herbivory_mean_late_recode  ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
#                                 data = herbivory %>%
#                    dplyr::filter(Transect_ID != "Rural"),
#                                 family = beta_family(link="logit"),
#                  REML = F) # not converging. Try taking out block
# 
# 
# performance::check_model(update(test1, . ~ . -(1|Block))) # heavy right tail

# TRY HURDLE MODEL-----
herbiv_l_urbsubs_dist_m1_bin <- glmmTMB(Herbivory_mean_late_binary ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                City_dist * Transect_ID,
                              data = herbivory %>%
                                dplyr::filter(Transect_ID != "Rural"),
                       family = binomial,
                              REML = F)

# Check model assumptions
plot(DHARMa::simulateResiduals(herbiv_l_urbsubs_dist_m1_bin)) # looks good enough


# quantitative model
herbiv_l_urbsubs_dist_m1_quant <- glmmTMB(log(Herbivory_mean_late) ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                City_dist * Transect_ID,
                              data = herbivory %>%
                        dplyr::filter(
                          Herbivory_mean_late_binary == 1 & Transect_ID != "Rural"),
                              REML = F) # log-transformed after looking at untransformed, sqrt, cube root models

# Check model assumptions
plot(DHARMa::simulateResiduals(herbiv_l_urbsubs_dist_m1_quant)) # looks good enough



# MAIN EFFECTS MODELS
## BINARY
herbiv_l_urbsubs_dist_m2_bin <- glmmTMB(Herbivory_mean_late_binary ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                City_dist + Transect_ID,
                              data = herbivory %>%
                                dplyr::filter(Transect_ID != "Rural"),
                       family = binomial,
                              REML = F)

# Check model assumptions
plot(DHARMa::simulateResiduals(herbiv_l_urbsubs_dist_m2_bin)) # looks good enough

AIC(herbiv_l_urbsubs_dist_m1_bin, herbiv_l_urbsubs_dist_m2_bin) # m2 better but <2 AIC apart



# QUANTITATIVE
herbiv_l_urbsubs_dist_m2_quant <- glmmTMB(log(Herbivory_mean_late) ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                City_dist + Transect_ID,
                              data = herbivory %>%
                        dplyr::filter(
                          Herbivory_mean_late_binary == 1 & Transect_ID != "Rural"),
                              REML = F) # log-transformed after looking at untransformed, sqrt, cube root models

# Check model assumptions
plot(DHARMa::simulateResiduals(herbiv_l_urbsubs_dist_m2_quant)) # looks good enough

AIC(herbiv_l_urbsubs_dist_m1_quant, herbiv_l_urbsubs_dist_m2_quant) # m2 better but <2 AIC apart

```

#### Urbanization Score
```{r}
# OLD DIAGNOSTICS-----
# BETA FAMILY
# test1 <- glmmTMB(Herbivory_mean_late_recode  ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
#                                 data = herbivory %>%
#                    dplyr::filter(Transect_ID != "Rural"),
#                                 family = beta_family(link="logit"),
#                  REML = F)

# performance::check_model(test1) # heavy right tail

# TRY HURDLE MODEL-----
herbiv_l_urbsubs_usc_m1_bin <- glmmTMB(Herbivory_mean_late_binary ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                Urb_score * Transect_ID,
                              data = herbivory %>%
                                dplyr::filter(Transect_ID != "Rural"),
                       family = binomial,
                              REML = F)

# Check model assumptions
plot(DHARMa::simulateResiduals(herbiv_l_urbsubs_usc_m1_bin)) # looks good enough


# quantitative model
herbiv_l_urbsubs_usc_m1_quant <- glmmTMB(log(Herbivory_mean_late) ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                Urb_score * Transect_ID,
                              data = herbivory %>%
                        dplyr::filter(
                          Herbivory_mean_late_binary == 1 & Transect_ID != "Rural"),
                              REML = F) # log-transformed after looking at untransformed, sqrt, cube root models

# Check model assumptions
plot(DHARMa::simulateResiduals(herbiv_l_urbsubs_usc_m1_quant)) # looks good enough



# MAIN EFFECTS MODELS
## BINARY
herbiv_l_urbsubs_usc_m2_bin <- glmmTMB(Herbivory_mean_late_binary ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                Urb_score + Transect_ID,
                              data = herbivory %>%
                                dplyr::filter(Transect_ID != "Rural"),
                       family = binomial,
                              REML = F)

# Check model assumptions
plot(DHARMa::simulateResiduals(herbiv_l_urbsubs_usc_m2_bin)) # looks good enough

AIC(herbiv_l_urbsubs_usc_m1_bin, herbiv_l_urbsubs_usc_m2_bin) # m2 better but <2 AIC apart



# QUANTITATIVE
herbiv_l_urbsubs_usc_m2_quant <- glmmTMB(log(Herbivory_mean_late) ~
                               (1|Block) +
                               (1|Year) + 
                               (1|Population/Family) +
                                Urb_score + Transect_ID,
                              data = herbivory %>%
                        dplyr::filter(
                          Herbivory_mean_late_binary == 1 & Transect_ID != "Rural"),
                              REML = F) # log-transformed after looking at untransformed, sqrt, cube root models

# Check model assumptions
plot(DHARMa::simulateResiduals(herbiv_l_urbsubs_usc_m2_quant)) # looks good enough

AIC(herbiv_l_urbsubs_usc_m1_quant, herbiv_l_urbsubs_usc_m2_quant) # m2 better but <2 AIC apart
```

## Weevil scar length- 2020 and 2021 ONLY
### Hurdle models (Binary, then quantitative)
1. Use a binomial model to predict whether the values are 0 or >0, then
2. Use a linear model to model the observed non-zero values 
#### Gradient
##### City_dist
```{r}
# BINARY MODEL-----
# create binary column
weevil$Scar_binary <- weevil$Scar_length_cm
weevil$Scar_binary[weevil$Scar_binary > 0] <- 1


weev_gr_dist_m1_bin <- glmmTMB(Scar_binary ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
                              data = weevil,
                              family = "binomial"(link = "logit"),
                              REML = F)

performance::check_model(weev_gr_dist_m1_bin)
plot(DHARMa::simulateResiduals(weev_gr_dist_m1_bin)) # looks good



# QUANTITATIVE MODEL-----
# weev_gr_dist_m1_quant <- glmmTMB(Scar_length_cm ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
#                               data = weevil %>%
#                                 dplyr::filter(Scar_length_cm > 0),
#                               REML = F)
# 
# performance::check_model(weev_gr_dist_m1_quant)
# plot(DHARMa::simulateResiduals(weev_gr_dist_m1_quant)) # right-skew. try sqrt
# 
# performance::check_model(update(weev_gr_dist_m1_quant, sqrt(Scar_length_cm) ~ .))
# plot(DHARMa::simulateResiduals(update(weev_gr_dist_m1_quant, sqrt(Scar_length_cm) ~ .))) # better. Try cube root
# 
# 
# performance::check_model(update(weev_gr_dist_m1_quant, (Scar_length_cm)^(1/3) ~ .))
# plot(DHARMa::simulateResiduals(update(weev_gr_dist_m1_quant, (Scar_length_cm)^(1/3) ~ .))) # looks great


# final model
weev_gr_dist_m1_quant <- glmmTMB(Scar_length_cm^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist,
                              data = weevil %>%
                                dplyr::filter(Scar_length_cm > 0),
                              REML = F)

weev_gr_dist_m1_quant %>% car::Anova()
```

##### Urb_score
```{r}
# BINARY MODEL-----
weev_gr_usc_m1_bin <- glmmTMB(Scar_binary ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
                              data = weevil,
                              family = "binomial"(link = "logit"),
                              REML = F)

performance::check_model(weev_gr_usc_m1_bin)
plot(DHARMa::simulateResiduals(weev_gr_usc_m1_bin)) # looks good



# QUANTITATIVE MODEL-----
# weev_gr_usc_m1_quant <- glmmTMB(Scar_length_cm ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
#                               data = weevil %>%
#                                 dplyr::filter(Scar_length_cm > 0),
#                               REML = F)
# 
# performance::check_model(weev_gr_usc_m1_quant)
# plot(DHARMa::simulateResiduals(weev_gr_usc_m1_quant)) # right-skew. try sqrt
# 
# performance::check_model(update(weev_gr_usc_m1_quant, sqrt(Scar_length_cm) ~ .))
# plot(DHARMa::simulateResiduals(update(weev_gr_usc_m1_quant, sqrt(Scar_length_cm) ~ .))) # better. Try cube root
# 
# 
# performance::check_model(update(weev_gr_usc_m1_quant, (Scar_length_cm)^(1/3) ~ .))
# plot(DHARMa::simulateResiduals(update(weev_gr_usc_m1_quant, (Scar_length_cm)^(1/3) ~ .))) # looks great


# final model
weev_gr_usc_m1_quant <- glmmTMB(Scar_length_cm^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score,
                              data = weevil %>%
                                dplyr::filter(Scar_length_cm > 0),
                              REML = F)

weev_gr_usc_m1_quant %>% car::Anova()
```

#### Urban Subtransects
##### City_dist
```{r}
# BINARY MODEL-----
weev_urbsubs_dist_m1_bin <- glmmTMB(Scar_binary ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
                              data = weevil %>%
                                dplyr::filter(Transect_ID != "Rural"),
                              family = "binomial"(link = "logit"),
                              REML = F)

# performance::check_model(weev_urbsubs_dist_m1_bin)
# plot(DHARMa::simulateResiduals(weev_urbsubs_dist_m1_bin)) # looks good

# MAIN EFFECTS
weev_urbsubs_dist_m2_bin <- glmmTMB(Scar_binary ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist + Transect_ID,
                              data = weevil %>%
                                dplyr::filter(Transect_ID != "Rural"),
                              family = "binomial"(link = "logit"),
                              REML = F)

# performance::check_model(weev_urbsubs_dist_m2_bin)
# plot(DHARMa::simulateResiduals(weev_urbsubs_dist_m2_bin)) # looks good
# 
# AIC(weev_urbsubs_dist_m1_bin, weev_urbsubs_dist_m2_bin) # m2 better but <2AIC away




# QUANTITATIVE MODEL-----
# weev_urbsubs_dist_m1_quant <- glmmTMB(Scar_length_cm ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
#                               data = weevil %>%
#                                 dplyr::filter(Scar_length_cm > 0 & Transect_ID != "Rural"),
#                               REML = F)
# 
# performance::check_model(weev_urbsubs_dist_m1_quant)
# plot(DHARMa::simulateResiduals(weev_urbsubs_dist_m1_quant)) # right-skew. try sqrt
# 
# performance::check_model(update(weev_urbsubs_dist_m1_quant, sqrt(Scar_length_cm) ~ .))
# plot(DHARMa::simulateResiduals(update(weev_urbsubs_dist_m1_quant, sqrt(Scar_length_cm) ~ .))) # better. Try cube root
# 
# 
# performance::check_model(update(weev_urbsubs_dist_m1_quant, (Scar_length_cm)^(1/3) ~ .))
# plot(DHARMa::simulateResiduals(update(weev_urbsubs_dist_m1_quant, (Scar_length_cm)^(1/3) ~ .))) # looks great


# final model
weev_urbsubs_dist_m1_quant <- glmmTMB(Scar_length_cm^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist * Transect_ID,
                              data = weevil %>%
                                dplyr::filter(Scar_length_cm > 0 & Transect_ID != "Rural"),
                              REML = F)

# No interaxns sig, so use type II SS
car::Anova(weev_urbsubs_dist_m1_quant, type = "III")
car::Anova(weev_urbsubs_dist_m1_quant, type = "II")



# MAIN EFFECTS MODEL
weev_urbsubs_dist_m2_quant <- glmmTMB(Scar_length_cm^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + City_dist + Transect_ID,
                              data = weevil %>%
                                dplyr::filter(Scar_length_cm > 0 & Transect_ID != "Rural"),
                              REML = F)
# 
# performance::check_model(weev_urbsubs_dist_m2_quant)
# plot(DHARMa::simulateResiduals(weev_urbsubs_dist_m2_quant)) # looks great
# 
# 
# AIC(weev_urbsubs_dist_m1_quant, weev_urbsubs_dist_m2_quant) # m2 best but <2 AIC away
```

##### Urb_score
```{r}
# BINARY MODEL-----
weev_urbsubs_usc_m1_bin <- glmmTMB(Scar_binary ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
                              data = weevil %>%
                                dplyr::filter(Transect_ID != "Rural"),
                              family = "binomial"(link = "logit"),
                              REML = F)
# 
# performance::check_model(weev_urbsubs_usc_m1_bin)
# plot(DHARMa::simulateResiduals(weev_urbsubs_usc_m1_bin)) # looks good

# MAIN EFFECTS
weev_urbsubs_usc_m2_bin <- glmmTMB(Scar_binary ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score + Transect_ID,
                              data = weevil %>%
                                dplyr::filter(Transect_ID != "Rural"),
                              family = "binomial"(link = "logit"),
                              REML = F)
# 
# performance::check_model(weev_urbsubs_usc_m2_bin)
# plot(DHARMa::simulateResiduals(weev_urbsubs_usc_m2_bin)) # looks good
# 
# AIC(weev_urbsubs_usc_m1_bin, weev_urbsubs_usc_m2_bin) # m2 better but <2AIC away




# QUANTITATIVE MODEL-----
# weev_urbsubs_usc_m1_quant <- glmmTMB(Scar_length_cm ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
#                               data = weevil %>%
#                                 dplyr::filter(Scar_length_cm > 0 & Transect_ID != "Rural"),
#                               REML = F)
# 
# performance::check_model(weev_urbsubs_usc_m1_quant)
# plot(DHARMa::simulateResiduals(weev_urbsubs_usc_m1_quant)) # right-skew. try sqrt
# 
# performance::check_model(update(weev_urbsubs_usc_m1_quant, sqrt(Scar_length_cm) ~ .))
# plot(DHARMa::simulateResiduals(update(weev_urbsubs_usc_m1_quant, sqrt(Scar_length_cm) ~ .))) # better. Try cube root
# 
# 
# performance::check_model(update(weev_urbsubs_usc_m1_quant, (Scar_length_cm)^(1/3) ~ .))
# plot(DHARMa::simulateResiduals(update(weev_urbsubs_usc_m1_quant, (Scar_length_cm)^(1/3) ~ .))) # looks great


# final model
weev_urbsubs_usc_m1_quant <- glmmTMB(Scar_length_cm^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score * Transect_ID,
                              data = weevil %>%
                                dplyr::filter(Scar_length_cm > 0 & Transect_ID != "Rural"),
                              REML = F)

# No interaxns sig, so use type II SS
# car::Anova(weev_urbsubs_usc_m1_quant, type = "III")
# car::Anova(weev_urbsubs_usc_m1_quant, type = "II")



# MAIN EFFECTS MODEL
weev_urbsubs_usc_m2_quant <- glmmTMB(Scar_length_cm^(1/3) ~ (1|Block) + (1|Year) + (1|Population/Family) + Urb_score + Transect_ID,
                              data = weevil %>%
                                dplyr::filter(Scar_length_cm > 0 & Transect_ID != "Rural"),
                              REML = F)

# performance::check_model(weev_urbsubs_usc_m2_quant)
# plot(DHARMa::simulateResiduals(weev_urbsubs_usc_m2_quant)) # looks great
# 
# 
# AIC(weev_urbsubs_usc_m1_quant, weev_urbsubs_usc_m2_quant) # m2 best but <2 AIC away

```

# Models for use in analysis
## LDMC
```{r}
ldmc_mods <- list(

## City_dist / gradient
ldmc_gr_city_m1 ,

## Urbanization score / gradient
ldmc_gr_usc_m1 ,

## City_dist / urban subtransects
ldmc_urbsubs_city_m1, # Qualitatively identical model (<2 AIC away)
ldmc_urbsubs_city_m2, # Best model

## Urbanization score  / urban subtransects
ldmc_urbsubs_usc_m1, # Qualitatively identical model (<2 AIC away)
ldmc_urbsubs_usc_m2 # Best model

)


names(ldmc_mods) <- c("City_gr",
                     "Usc_gr",
                     "City_urbsubs_alt",
                     "City_urbsubs_best",
                     "Usc_urbsubs_alt",
                     "Usc_urbsubs_best")
```

## SLA
```{r}
sla_mods <- list(

## City_dist / gradient
sla_gr_city_m1 ,

## Urbanization score / gradient
sla_gr_usc_m1,

## City_dist / urban subtransects
sla_urbsubs_city_m1, # Qualitatively identical model (<2 AIC away)
sla_urbsubs_city_m2, # Best model

## Urbanization score  / urban subtransects
sla_urbsubs_usc_m1, # Qualitatively identical model (<2 AIC away)
sla_urbsubs_usc_m2 # Best model

)


names(sla_mods) <- c("City_gr",
                     "Usc_gr",
                     "City_urbsubs_alt",
                     "City_urbsubs_best",
                     "Usc_urbsubs_alt",
                     "Usc_urbsubs_best")
```

## Latex
```{r}
latex_mods <- list(

## City_dist / gradient
ltx_gr_city_m1 ,

## Urbanization score / gradient
ltx_gr_usc_m1,

## City_dist / urban subtransects
ltx_urbsubs_city_m1, # Qualitatively identical model (<2 AIC away)
ltx_urbsubs_city_m2, # Best model

## Urbanization score  / urban subtransects
ltx_urbsubs_usc_m1 # Best model
)

names(latex_mods) <- c("City_gr", "Usc_gr", "City_urbsubs_alt", "City_urbsubs_best", "Usc_urbsubs")
```

## Herbivory: Early- Hurdle models (Binomial and gaussian families)
```{r}
herb_early_mods_binomial <- list(

## City_dist / gradient
herbiv_e_gr_dist_m1_bin ,

## Urbanization score / gradient
herbiv_e_gr_usc_m1_bin,

## City_dist / urban subtransects
herbiv_e_urbsubs_dist_m1_bin, # Best model
herbiv_e_urbsubs_dist_m2_bin, # Qualitatively identical model (<2 AIC away)

## Urbanization score  / urban subtransects
herbiv_e_urbsubs_usc_m1_bin, # Qualitatively identical model (<2 AIC away)
herbiv_e_urbsubs_usc_m2_bin # Best model
)

names(herb_early_mods_binomial) <- c("City_gr",
                            "Usc_gr",
                            "City_urbsubs_best",
                            "City_urbsubs_alt",
                            "Usc_urbsubs_alt",
                            "Usc_urbsubs_best")



herb_early_mods_quant <- list(

## City_dist / gradient
herbiv_e_gr_dist_m1_quant ,

## Urbanization score / gradient
herbiv_e_gr_usc_m1_quant,

## City_dist / urban subtransects
herbiv_e_urbsubs_dist_m1_quant, # Best model
herbiv_e_urbsubs_dist_m2_quant, # Qualitatively identical model (<2 AIC away)

## Urbanization score  / urban subtransects
herbiv_e_urbsubs_usc_m1_quant, # Best model
herbiv_e_urbsubs_usc_m2_quant # Qualitatively identical model (<2 AIC away)
)

names(herb_early_mods_quant) <- c("City_gr",
                            "Usc_gr",
                            "City_urbsubs_best",
                            "City_urbsubs_alt",
                            "Usc_urbsubs_best",
                            "Usc_urbsubs_alt")
```


## Herbivory: Late- Hurdle models (Binomial and gaussian families)
```{r}
herb_late_mods_binomial <- list(

## City_dist / gradient
herbiv_l_gr_dist_m1_bin ,

## Urbanization score / gradient
herbiv_l_gr_usc_m1_bin,

## City_dist / urban subtransects
herbiv_l_urbsubs_dist_m1_bin, # Qualitatively identical model (<2 AIC away)
herbiv_l_urbsubs_dist_m2_bin, # Best model

## Urbanization score  / urban subtransects
herbiv_l_urbsubs_usc_m1_bin, # Qualitatively identical model (<2 AIC away)
herbiv_l_urbsubs_usc_m2_bin # Best model
)

names(herb_late_mods_binomial) <- c("City_gr",
                            "Usc_gr",
                            "City_urbsubs_alt",
                            "City_urbsubs_best",
                            "Usc_urbsubs_alt",
                            "Usc_urbsubs_best")



herb_late_mods_quant <- list(

## City_dist / gradient
herbiv_l_gr_dist_m1_quant ,

## Urbanization score / gradient
herbiv_l_gr_usc_m1_quant,

## City_dist / urban subtransects
herbiv_l_urbsubs_dist_m1_quant  , # Qualitatively identical model (<2 AIC away)
herbiv_l_urbsubs_dist_m2_quant  , # Best model

## Urbanization score  / urban subtransects
herbiv_l_urbsubs_usc_m1_quant, # Qualitatively identical model (<2 AIC away)
herbiv_l_urbsubs_usc_m2_quant # Best model
)

names(herb_late_mods_quant) <- c("City_gr",
                            "Usc_gr",
                            "City_urbsubs_alt",
                            "City_urbsubs_best",
                            "Usc_urbsubs_alt",
                            "Usc_urbsubs_best")
```


## Weevil Scar- Hurdle models (Binomial and gaussian families)
```{r}
weev_mods_binomial <- list(

## City_dist / gradient
weev_gr_dist_m1_bin ,

## Urbanization score / gradient
weev_gr_usc_m1_bin,

## City_dist / urban subtransects
weev_urbsubs_dist_m1_bin, # Qualitatively identical model (<2 AIC away)
weev_urbsubs_dist_m2_bin, # Best model

## Urbanization score  / urban subtransects
weev_urbsubs_usc_m1_bin , # Qualitatively identical model (<2 AIC away)
weev_urbsubs_usc_m2_bin # Best model
)

names(weev_mods_binomial) <- c("City_gr",
                      "Usc_gr",
                      "City_urbsubs_alt",
                      "City_urbsubs_best",
                      "Usc_urbsubs_alt",
                      "Usc_urbsubs_best")




weev_mods_quant <- list(

## City_dist / gradient
weev_gr_dist_m1_quant ,

## Urbanization score / gradient
weev_gr_usc_m1_quant,

## City_dist / urban subtransects
weev_urbsubs_dist_m1_quant, # Qualitatively identical model (<2 AIC away)
weev_urbsubs_dist_m2_quant, # Best model

## Urbanization score  / urban subtransects
weev_urbsubs_usc_m1_quant , # Qualitatively identical model (<2 AIC away)
weev_urbsubs_usc_m2_quant # Best model
)

names(weev_mods_quant) <- c("City_gr",
                      "Usc_gr",
                      "City_urbsubs_alt",
                      "City_urbsubs_best",
                      "Usc_urbsubs_alt",
                      "Usc_urbsubs_best")
```

