---
title: "KSR_2020_analysis"
output: html_document
---

1/2022: Import data, then run script.

# Statistics: 2020
## comparing lmer w/glmmTMB
```{r}
# # lmer
# lmer_m1 <- lmer(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020, REML = F)
# 
# car_anova_lmer <- car::Anova(lmer_m1)
# Anova.glmmTMB(lmer_m1, # doesn't run
#               type = "II")
# 
# # glmmTMB
# glmmTMB_m1 <- glmmTMB(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020,
#   REML = F,
#   family = gaussian)
# 
# car_anova_glmmtmb <- car::Anova(glmmTMB_m1)
# anova_glmmtmb <- Anova.glmmTMB(glmmTMB_m1,
#               type = "II")
# 
# 
# anova_comparison <- bind_rows(tidy(car_anova_lmer),
#           tidy(car_anova_glmmtmb),
#           tidy(anova_glmmtmb)) %>%
#   add_column(Model = c("car::Anova(lmer model)", "car::Anova(glmmTMB model)", "Anova.glmmTMB(glmmTMB model)"), .before = "term") %>%
#   write.csv("comparing_ANOVAs_lmer_glmmtmb.csv")
```

## reproductive
### Plants that flowered
#### Flowering success
##### Sig difference between urb vs rural? (Odds ratio)
```{r}
# # How many plants flowered per subtransect? using 2019 alive plants
# tib1 <- reproductive %>%
#   filter(Alive_DC1 != '0')%>%
#   group_by(Flowered2020, Urb_Rur) %>%
#   tally()
# tib1
# 
# 
# Flowered_ttest <- matrix(c(21, 3, 556, 282), nrow = 2,
#                          dimnames = list(
#                            c("Urban", "Rural"),
#                            c("Flowered", "Didn't Flower")))
# 
# fisher.test(Flowered_ttest, alternative = "two.sided")
# # odds ratio = 3.5464
# # p = 0.02859
# # medium effect size


# How many plants flowered per subtransect? using 2020 alive plants

tib2 <- reproductive %>%
  filter(Alive_DC1 == 1) %>%
  group_by(Flowered2020, Urb_Rur) %>%
  tally()
tib2


Flowered_ttest2 <- matrix(c(
  as.integer(tib2[2,3]),
  as.integer(tib2[4,3]),
  as.integer(tib2[4,3]),
  as.integer(tib2[3,3])),
  nrow = 2,
  dimnames = list(
    c("Rural", "Urban"),
    c("Flowered", "Didn't Flower")))

fisher.test(Flowered_ttest2, alternative = "two.sided")
# odds ratio = 3.761
# p = 0.0655
# Medium effect size

chisq.test(Flowered_ttest2)
# X-squared = 3.823, df = 1, p-value = 0.05055





# How many populations had at least one plant flower per subtransect? using 2020 alive plants

tib3 <- reproductive %>%
  group_by(Population, Flowered2020, Urb_Rur) %>%
  dplyr::summarise(Pops = n_distinct(Population),
                   Urb_Rur = first(Urb_Rur)) %>%
  group_by(Population, Urb_Rur) %>%
  dplyr::summarise(Flowered = sum(as.integer(Flowered2020)),
                   Urb_Rur = first(Urb_Rur)) %>%
  group_by(Urb_Rur, Flowered) %>%
  dplyr::summarise(Pops = n_distinct(Population))
  
tib3
# Flowered = 1: Flowered
# Flowered = 0: Didn't flower



Flowered_ttest3 <- matrix(c(
  as.integer(tib3[2,3]),
  as.integer(tib3[4,3]),
  as.integer(tib3[4,3]),
  as.integer(tib3[3,3])),
  nrow = 2,
  dimnames = list(
    c("Rural", "Urban"),
    c("Flowered", "Didn't Flower")))

fisher.test(Flowered_ttest3, alternative = "two.sided")
# odds ratio = 0.5064
# p = 0.5034
# Medium effect size


chisq.test(Flowered_ttest3)
# X-squared = 0.3782, df = 1, p-value = 0.5386
```



##### Sig difference between urb:north vs urb:south? (Odds ratio)
```{r}
# How many plants flowered per subtransect? using 2020 alive plants

tib4 <- reproductive %>%
  filter(., Transect_ID != 'Rural') %>%
  group_by(Flowered2020, Transect_ID) %>%
  tally()
tib4


Flowered_ttest4 <- matrix(c(
  as.integer(tib4[3,3]),
  as.integer(tib4[4,3]),
  as.integer(tib4[1,3]),
  as.integer(tib4[2,3])),
  nrow = 2,
  dimnames = list(
    c("North", "South"),
    c("Flowered", "Didn't Flower"))) %T>%
  print()

fisher.test(Flowered_ttest4, alternative = "two.sided")
# odds ratio = 0.782
# p = 0.660 (CAN'T REJECT THE NULL)
# negligible effect size

chisq.test(Flowered_ttest4)
# X-squared = 0.081128, df = 1, p-value = 0.7758






# How many populations had at least one plant flower per subtransect? using 2020 alive plants

tib5 <- reproductive %>%
  filter(., Transect_ID != "Rural") %>%
  group_by(Population, Flowered2020, Transect_ID) %>%
  dplyr::summarise(Pops = n_distinct(Population),
                   Transect_ID = first(Transect_ID)) %>%
  group_by(Population, Transect_ID) %>%
  dplyr::summarise(Flowered = sum(as.integer(Flowered2020)),
                   Transect_ID = first(Transect_ID)) %>%
  group_by(Transect_ID, Flowered) %>%
  dplyr::summarise(Pops = n_distinct(Population))
  
tib5
# Flowered = 0: Didn't flower
# Flowered = 1: Did flower



Flowered_ttest5 <- matrix(c(
  as.integer(tib5[1,3]),
  as.integer(tib5[3,3]),
  as.integer(tib5[2,3]),
  as.integer(tib5[4,3])),
  nrow = 2,
  dimnames = list(
    c("North", "South"),
    c("Didn't Flower", "Flowered"))) %T>%
  print()

fisher.test(Flowered_ttest5, alternative = "two.sided")
# odds ratio = 0.851
# p = 1 (NOT SIGNIFICANT; CAN'T REJECT NULL)
# small effect size

chisq.test(Flowered_ttest5)
# X-squared = 0.41878, df = 1, p-value = 0.5175
```


##### Block effect?
```{r}
glmer(Flowered2020 ~ Block + (1|Population/Family),
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=1,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))

car::Anova(glmer(Flowered2020 ~ Block + (1|Population/Family),
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=1,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
# Block is significant, so yes, the number of plants that flowered DID significantly vary by block.

summary(glmer(Flowered2020 ~ Block + (1|Population/Family),
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=1,
  glmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000))))
```

#### Flower count: HOLD OFF until 2021- too few plants and will probably overfit all models
##### Mean flower count/inflorescence
###### Sig difference along gradient?
####### glmer: diagnostics (No)
```{r}
flowercount_2020_lmer_gradient <- glmmTMB(mean_flower_count ~
                                          (1|Block) +
                                          (1|Population/Family) +
                                          City_dist, 
                                        data = flowering_2020,
                                        family = nbinom1())
res <- simulateResiduals(flowercount_2020_lmer_gradient)
plot(res)
testDispersion(flowercount_2020_lmer_gradient)
hist(flowering_2020$mean_flower_count, breaks = 20)


```

####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----

# ANOVA
car::Anova(flowercount_2020_lmer_gradient)
# distance is not sig

# library(MuMIn) # Multi-Model Inference # Multi-Model Inference # Multi-Model Inference
# r.squaredGLMM(flowercount_2020_lmer_gradient)


# ### CROSSED RANDOM EFFECTS-----
# lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F)
# # singular
# 
# car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F))
# # distance is sig
# 
# 
# # ANy variation among families or populations?
# ranova(lmer(mean_flower_count ~ (1|Population/Family), data = flowering_2020, REML = T))
# # no... is singular
```

####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
flowercount_2020_lmer_gradient_urbscore <- lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
# is singular

# ANOVA
car::Anova(flowercount_2020_lmer_gradient_urbscore)
# sig

library(MuMIn) # Multi-Model Inference # Multi-Model Inference # Multi-Model Inference
r.squaredGLMM(flowercount_2020_lmer_gradient_urbscore)


### CROSSED RANDOM EFFECTS-----
lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F))
#  sig

```

##### Sig difference btwn urban subtransects?
###### lmer: *NO: Nothing sig for city_dist or urb_score
###### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
flowercount_2020_lmer_subtr <- lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(flowercount_2020_lmer_subtr)
# nothing sig
AIC(flowercount_2020_lmer_subtr)

car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# nothing sig

r.squaredGLMM(flowercount_2020_lmer_subtr)
# is this worth doing, since I have two regression lines?

AIC(lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig


car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig



# ANy variation among families or populations?
ranova(lmer(mean_flower_count ~ (1|Population/Family), data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = T))
# no... is singular
car::Anova(lmer(mean_flower_count ~ (1|Population/Family) + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# no... is singular

```
###### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
flowercount_2020_lmer_subtr_urbscore <- lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(flowercount_2020_lmer_subtr_urbscore)
# nothing sig
AIC(flowercount_2020_lmer_subtr_urbscore)

car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# nothing sig

r.squaredGLMM(flowercount_2020_lmer_subtr_urbscore)
# is this worth doing, since I have two regression lines?

AIC(lmer(mean_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig


car::Anova(lmer(mean_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig

```

##### Total flower count
###### Sig difference along gradient?
####### glmer: *sig for city_dist, insig for urb_score
######## City_dist
```{r}
### nested RANDOM EFFECTS-----
flowercountsum_2020_glmer_gradient <- glmmTMB(total_flower_count ~
                                                # (1|Block) +
                                                (1|Population/Family) +
                                                City_dist,
                                              data = flowering_2020,
                                              family = nbinom1())


# ANOVA
car::Anova(flowercountsum_2020_glmer_gradient)
# distance is sig

r.squaredGLMM(flowercountsum_2020_glmer_gradient)



# sjPlot: show points
sjPlot::plot_model(flowercountsum_2020_glmer_gradient,
                   type = "pred",
                   terms = c("City_dist"),
                   show.data = T,
                   geom_size = 1) +
  labs(x = "Dist CC") 




# ANy variation among families or populations?
# ranova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, family = 'poisson'))
```

######## Urb_score
```{r}
### nested RANDOM EFFECTS-----
flowercountsum_2020_glmer_gradient_urbscore <- glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, family = 'poisson')
# is singular...


# ANOVA
car::Anova(flowercountsum_2020_glmer_gradient_urbscore)
# not sig

r.squaredGLMM(flowercountsum_2020_glmer_gradient_urbscore)


### CROSSED RANDOM EFFECTS-----
glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, family = 'poisson')
# NOT singular!


# ANOVA
car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, family = 'poisson')
)
# not sig

```

###### Sig difference btwn urban subtransects?
####### glmer: *NO for both city_dist & urb_score
######## City_dist
```{r}
### NESTED RANDOM EFFECTS-----
flowercountsum_2020_glmer_subtr <- glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
                                     data = flowering_2020 %>% filter(Transect_ID != "Rural"))
# singular

# ANOVA
car::Anova(flowercountsum_2020_glmer_subtr)
AIC(flowercountsum_2020_glmer_subtr)
# nothing sig


car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural")))
# nothing sig

car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural")))
# nothing sig



### CROSSED RANDOM EFFECTS-----
glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
# singular

# ANOVA
car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
)
AIC(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
)
# nothing sig


car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
)
# nothing sig
AIC(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"))
)

```

######## Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
flowercountsum_2020_glmer_subtr_urbscore <- glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
                                     data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
# singular

# ANOVA
car::Anova(flowercountsum_2020_glmer_subtr_urbscore)
AIC(flowercountsum_2020_glmer_subtr_urbscore)
# nothing sig


car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson))
# nothing sig

car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson))
# nothing sig



### CROSSED RANDOM EFFECTS-----
glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
# NOT singular

# ANOVA
car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
)
AIC(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
)
# nothing sig


car::Anova(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
)
# nothing sig
AIC(glmer(total_flower_count ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID,data = flowering_2020 %>% filter(Transect_ID != "Rural"),
                                     family = poisson)
)

```


#### Flower size: HOLD OFF until 2021- too few plants and will probably overfit all models
##### Mean flower size/inflorescence
###### lmer
####### gradient: *NOt sig for either city_dist or urb_score
######## City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
# is singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)
# distance not sig

library(MuMIn) # Multi-Model Inference # Multi-Model Inference # Multi-Model Inference
r.squaredGLMM(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F))
# distance not sig


# ANy variation among families or populations?
ranova(lmer(Overall_mean ~ (1|Population/Family), data = flowering_2020, REML = T))
# no
```


######## Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020,
     REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)
# not sig

library(MuMIn) # Multi-Model Inference # Multi-Model Inference # Multi-Model Inference
r.squaredGLMM(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F))
# urb_score not sig

```

####### urban subtransects: *Main effects sig for both; interaxn sig for city_dist (marg sig for urb_score)
######## City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Overall_mean ~ (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# main effects and interaxn sig

car::Anova(lmer(Overall_mean ~  (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular,  everything  sig

AIC(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# both main effects sig

r.squaredGLMM(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# very high r-sq...is this worth doing, since I have two regression lines?

AIC(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# NOT singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# everything sig


car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects sig



# ANy variation among families or populations?
ranova(lmer(Overall_mean ~ (1|Population/Family), data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = T))
# no
car::Anova(lmer(Overall_mean ~ (1|Population/Family) + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# YES... variance DOES differ by subtransect... is singular

```
######## Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Overall_mean ~ (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# main effects sig

car::Anova(lmer(Overall_mean ~  (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular, main effects sig

AIC(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# both main effects sig

r.squaredGLMM(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# very high r-sq...is this worth doing, since I have two regression lines?

AIC(lmer(Overall_mean ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects sig


car::Anova(lmer(Overall_mean ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects sig

```

#### Pods: HOLD OFF until 2021- too few plants and will probably overfit all models
##### lmer
###### gradient: *NOt sig for either city_dist or urb_score
####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
# is singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)
# distance not sig

r.squaredGLMM(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F))
# distance not sig


# ANy variation among families or populations?
ranova(lmer(Pods ~ (1|Population/Family), data = flowering_2020, REML = T))
# no
```


####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020,
     REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)
# not sig

r.squaredGLMM(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F))
# urb_score not sig

```

###### urban subtransects: *Main effects marg sig for city_dist; nothing sig for urb_score)
####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Pods ~ (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# main effects marg sig

car::Anova(lmer(Pods ~  (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular, main effects marg  sig

AIC(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# both main effects marg sig

r.squaredGLMM(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# very high r-sq...is this worth doing, since I have two regression lines?

AIC(lmer(Pods ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
#  singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects marg sig


car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# main effects marg sig



# ANy variation among families or populations?
ranova(lmer(Pods ~ (1|Population/Family), data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = T))
# no
car::Anova(lmer(Pods ~ (1|Population/Family) + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# no ...variance doesn't differ by subtransect

```
####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Pods ~ (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# nothing sig

car::Anova(lmer(Pods ~  (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular,nothing sig

AIC(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# both main effects NOT sig

r.squaredGLMM(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

AIC(lmer(Pods ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig

car::Anova(lmer(Pods ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig

```

#### Peduncles (Inflorescences): HOLD OFF until 2021- too few plants and will probably overfit all models
##### lmer
###### gradient: *NOt sig for either city_dist or urb_score
####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
# is singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)
# distance not sig

r.squaredGLMM(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist, data = flowering_2020, REML = F))
# distance not sig


# ANy variation among families or populations?
ranova(lmer(Peduncles ~ (1|Population/Family), data = flowering_2020, REML = T))
# no
```


####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020,
     REML = F, lmerControl(optimizer="bobyqa", optCtrl = list(maxfun = 100000)))
# singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)
# not sig

r.squaredGLMM(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score, data = flowering_2020, REML = F)
)


### CROSSED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F)
# singular

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score, data = flowering_2020, REML = F))
# urb_score not sig

```

###### urban subtransects: *nothing sig for city_dist (transect marg sig when interaction included but becomes non-sig when only main effects present); transect marg sig for urb_score)
####### City_dist
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Peduncles ~ (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# transect marg sig

car::Anova(lmer(Peduncles ~  (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular, transect marg  sig

AIC(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# nothing sig

r.squaredGLMM(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

AIC(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
#  singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# transect marg sig


car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + City_dist + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# nothing sig



# ANy variation among families or populations?
ranova(lmer(Peduncles ~ (1|Population/Family), data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = T))
# no
car::Anova(lmer(Peduncles ~ (1|Population/Family) + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# no ...variance doesn't differ by subtransect

```
####### Urb_score
```{r}
### NESTED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# remove block?
lmer(Peduncles ~ (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# transect is marg sig

car::Anova(lmer(Peduncles ~  (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# still singular, transect marg sig

AIC(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))
# transect marg sig

r.squaredGLMM(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)

AIC(lmer(Peduncles ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F))


### CROSSED RANDOM EFFECTS-----
lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
# is singular

# ANOVA
car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score * Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# transect marg sig

car::Anova(lmer(Peduncles ~ (1|Block) + (1|Population:Family) + Urb_score + Transect_ID, data = flowering_2020 %>% filter(Transect_ID != "Rural"), REML = F)
)
# transect marg sig

```


### All plants
#### Regressions (is urbanization related to flowering?)
##### glmer: diagnostics
```{r}
# GRADIENT / CITY_DIST
flowering_gr_city_m1 <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + City_dist,
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=0)

res <- simulateResiduals(flowering_gr_city_m1)
plot(res) # looks great!




# GRADIENT / URB SCORE
flowering_gr_urb_m1 <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = reproductive,
  family = binomial(link = "logit"),
  nAGQ=0)

res <- simulateResiduals(flowering_gr_urb_m1)
plot(res) # looks great!





# URBAN SUBTRANSECTS / CITY_DIST
flowering_urbsubs_city_m1 <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = reproductive %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ=0)

res <- simulateResiduals(flowering_urbsubs_city_m1)
plot(res) # looks great!

# main effects:
flowering_urbsubs_city_m1_ME <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = reproductive %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ=0)




# URBAN SUBTRANSECTS / URB SCORE
flowering_urbsubs_usc_m1 <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = reproductive %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ=0)

res <- simulateResiduals(flowering_urbsubs_usc_m1)
plot(res) # looks great!

# main effects:
flowering_urbsubs_usc_m1_ME <- glmer(Flowered2020 ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = reproductive %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ=0)
```

##### Entire gradient: *Nothing sig for either
###### City_dist
```{r}
car::Anova(flowering_gr_city_m1)
# nothing significant



# ANy variation within families or populations?

##### TACTIC 1: try bootstrapping #####
# NOT PERFECT b/c can't nest family within pop but trying a few ways to get at the correct answer.
# https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html#test-of-random-parameter
# library(pbkrtest) # Parametric Bootstrap, Kenward-Roger and Satterthwaite Based
Methods for Test in Mixed Models
# library(pbnm)
# 
# # JUST POPULATION
# gmm <-  glmer(Flowered2020 ~ City_dist + (1|Population), # can't leave in Family... doesn't work
#               family = binomial(link = "logit"),
#               data = reproductive,
#              nAGQ = 0)
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1 <-  glmer(Flowered2020 ~ City_dist + (1|Population/Family), 
#               family = binomial(link = "logit"),
#               data = reproductive,
#              nAGQ = 0)
# 
# # POP:FAMILY
# gmm2 <-  glmer(Flowered2020 ~ City_dist + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#               family = binomial(link = "logit"),
#               data = reproductive,
#              nAGQ = 0)
# 
# # UNIQUE FAMILIES
# reproductive$Family_unique <- paste(reproductive$Population, reproductive$Family)
# gmm3 <-  glmer(Flowered2020 ~ City_dist + (1|Family_unique),
#               family = binomial(link = "logit"),
#               data = reproductive,
#              nAGQ = 0)
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4 <-  glmer(Flowered2020 ~ City_dist + (1|Population:Family) + (1|Population),
#               family = binomial(link = "logit"),
#               data = reproductive,
#              nAGQ = 0)
# 
# 
# # REDUCED MODEL
# gmmDG1 <- glm(Flowered2020 ~ City_dist,
#               family = binomial(link = "logit"),
#               data = reproductive)
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1 <- pbnm(gmm,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg1) # p = 0.031...  var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4 <- pbnm(gmm4,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop <- summary(pbgmmDg4) %T>%
#   print() # p = 0.028... var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2 <- pbnm(gmm2,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam <- summary(pbgmmDg2) %T>%
#   print() # p = 0.191... little var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3 <- pbnm(gmm3,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg3) # p = 0.258... little var among families, period
# 
# 
# 
# sum.1 <- summary(gmm4)
# 
# variances1 <- print(VarCorr(gmm4),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# # export percent variance explained
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Floweringsuccess_glmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# 
# # export ranova
# sink(here::here("./Figures_Tables/ranova_PVE/2020_Floweringsuccess_glmer_ranova.csv"))
# print("POPULATION", sep="\n\n")
# print(ranova_pop, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam, sep="\n\n")
#   cat("\n")
# if (ranova_pop[1] <= 0.05){
#   print ('There is variance among populations')}
# if (ranova_pop[1] > 0.05){
#   print ("There is not much variance among populations")}
# if (ranova_fam[1] <= 0.05){
#   print ("There is variance among families")}
# if (ranova_fam[1] > 0.05){
#   print ("There is not much variance among families")}
# sink()


```

###### Urb_score
```{r}
car::Anova(flowering_gr_urb_m1)
# not sig


```

##### Urban subtransects: *Nothing sig for either
###### City_dist
```{r}
car::Anova(flowering_urbsubs_city_m1) # nothing sig
car::Anova(flowering_urbsubs_city_m1_ME) # nothing sig

AIC(flowering_urbsubs_city_m1, flowering_urbsubs_city_m1_ME) # <2 away




# ANy variation within families or populations?

##### TACTIC 1: try bootstrapping #####
# NOT PERFECT b/c can't nest family within pop but trying a few ways to get at the correct answer.
# https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html#test-of-random-parameter


### MODEL 1: CITY_DIST ###
##########################
# 
# # JUST POPULATION
# gmm <-  glmer(Flowered2020 ~ City_dist + (1|Population), # can't leave in Family... doesn't work
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#   nAGQ = 0)
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1 <-  glmer(Flowered2020 ~ City_dist + (1|Population/Family), 
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # POP:FAMILY
# gmm2 <-  glmer(Flowered2020 ~ City_dist + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # UNIQUE FAMILIES
# gmm3 <-  glmer(Flowered2020 ~ City_dist + (1|Family_unique),
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4 <-  glmer(Flowered2020 ~ City_dist + (1|Population:Family) + (1|Population),
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# 
# # REDUCED MODEL 1
# gmmDG1 <- glm(Flowered2020 ~ City_dist,
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"))
# 
# 
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1 <- pbnm(gmm,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg1) # p = 0.032...  var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4 <- pbnm(gmm4,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop <- summary(pbgmmDg4) %T>%
#   print() # p = 0.049... var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2 <- pbnm(gmm2,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam <- summary(pbgmmDg2) %T>%
#   print() # p = 0.23... little var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3 <- pbnm(gmm3,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg3) # p = 0.23... little var among families, period
# 
# 
# 
# ### MODEL 2: TRANSECT_ID ###
# ##########################
# 
# # JUST POPULATION
# gmm.2 <-  glmer(Flowered2020 ~ Transect_ID + (1|Population), # can't leave in Family... doesn't work
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#   nAGQ = 0)
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1.2 <-  glmer(Flowered2020 ~ Transect_ID + (1|Population/Family), 
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # POP:FAMILY
# gmm2.2 <-  glmer(Flowered2020 ~ Transect_ID + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # UNIQUE FAMILIES
# gmm3.2 <-  glmer(Flowered2020 ~ Transect_ID + (1|Family_unique),
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4.2 <-  glmer(Flowered2020 ~ Transect_ID + (1|Population:Family) + (1|Population),
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"),
#              nAGQ = 0)
# 
# # REDUCED MODEL 2
# gmmDG1.2 <- glm(Flowered2020 ~ Transect_ID,
#               family = binomial(link = "logit"),
#   data = reproductive %>% filter(Urb_Rur == "Urban"))
# 
# 
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1.2 <- pbnm(gmm.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg1.2) # p = 0.027...  var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4.2 <- pbnm(gmm4.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop.2 <- summary(pbgmmDg4.2) %T>%
#   print() # p = 0.049... var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2.2 <- pbnm(gmm2.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam.2 <- summary(pbgmmDg2.2) %T>%
#   print() # p = 0.216... little var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3.2 <- pbnm(gmm3.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg3.2) # p = 0.216... little var among families, period
# 
# 
# 
# 
# sum.1 <- summary(gmm4)
# 
# variances1 <- print(VarCorr(gmm4),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# # export percent variance explained
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Floweringsuccess_urban_glmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# 
# # export ranova
# sink(here::here("./Figures_Tables/ranova_PVE/2020_Floweringsuccess_urban_glmer_ranova.csv"))
# print("POPULATION", sep="\n\n")
# print(ranova_pop, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam, sep="\n\n")
#   cat("\n")
# if (ranova_pop[1] <= 0.05){
#   print ('There is variance among populations')}
# if (ranova_pop[1] > 0.05){
#   print ("There is not much variance among populations")}
# if (ranova_fam[1] <= 0.05){
#   print ("There is variance among families")}
# if (ranova_fam[1] > 0.05){
#   print ("There is not much variance among families")}
#   
# cat("\n")
# cat("\n")
# 
# print("POPULATION", sep="\n\n")
# print(ranova_pop.2, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam.2, sep="\n\n")
#   cat("\n")
# if (ranova_pop.2[1] <= 0.05){
#   print ('Variance among populations differs by urban subtransect')}
# if (ranova_pop.2[1] > 0.05){
#   print ("Variance among populations does not differ by urban subtransect")}
# if (ranova_fam.2[1] <= 0.05){
#   print ("Variance among families differs by urban subtransect")}
# if (ranova_fam.2[1] > 0.05){
#   print ("Variance among families does not differ by urban subtransect")}
# sink()
```

###### Urb_score
```{r}
car::Anova(flowering_urbsubs_usc_m1) # nothing sig
car::Anova(flowering_urbsubs_usc_m1_ME) # nothing sig

AIC(flowering_urbsubs_usc_m1, flowering_urbsubs_usc_m1_ME) # <2 away
```


##### Export ANOVAs
```{r}
# 
# anova_table_flx(flowering_gr_city_m1)
# anova_table_flx(flowering_gr_urb_m1)
# anova_table_flx(flowering_urbsubs_city_m1)
# anova_table_flx(flowering_urbsubs_city_m1_ME)
# anova_table_flx(flowering_urbsubs_usc_m1)
# anova_table_flx(flowering_urbsubs_usc_m1_ME)
# 
# AIC_compare.city_dist(flowering_urbsubs_city_m1, flowering_urbsubs_city_m1_ME)
# AIC_compare.urb_score(flowering_urbsubs_usc_m1, flowering_urbsubs_usc_m1_ME)

```

## Heights
### June height
#### lmer: diagnostics
```{r}
# GRADIENT / CITY_DIST-----

# Height_Jun20_gr_city_m1 <- lmer(Total_Height_June ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(Height_Jun20_gr_city_m1, type = "diag") # is singular & right-skewed
# 
# Height_Jun20_gr_city_m2 <- lmer(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(Height_Jun20_gr_city_m2, type = "diag") # looks good though singular... take out block
# 
# Height_Jun20_gr_city_m3 <- lmer(sqrt(Total_Height_June) ~  (1|Population/Family) + City_dist,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(Height_Jun20_gr_city_m3, type = "diag") # looks good
# 
# AIC(Height_Jun20_gr_city_m2, Height_Jun20_gr_city_m3) #model with block has significantly lower AIC, so I should leave in block
# 
# Height_Jun20_gr_city_m4 <- lmer(sqrt(Total_Height_June) ~ (1|Block) + (1|Population) +  City_dist,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(Height_Jun20_gr_city_m4, type = "diag") # looks good 
# 
# AIC(Height_Jun20_gr_city_m2, Height_Jun20_gr_city_m4) #model with Pop/Fam has >4  lower AIC, so I should leave in Pop/Fam
# 
# car::Anova(Height_Jun20_gr_city_m2) # very similar results to anova below!
# car::Anova(Height_Jun20_gr_city_m4)

# try glmmTMB
Height_Jun20_gr_city_m5 <- glmmTMB(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_both_2020,
  family = gaussian) # it works! use this




# GRADIENT / URB SCORE-----

# Height_Jun20_gr_usc_m1 <- lmer(Total_Height_June ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(Height_Jun20_gr_usc_m1, type = "diag") # right-skewed

Height_Jun20_gr_usc_m2 <- lmer(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_both_2020, REML = F)
sjPlot::plot_model(Height_Jun20_gr_usc_m2, type = "diag") # looks good



# URB SUBTRANSECTS / CITY_DIST-----

# Height_Jun20_urbsubs_city_m1 <- lmer(Total_Height_June ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(Height_Jun20_urbsubs_city_m1, type = "diag") # right-skewed

Height_Jun20_urbsubs_city_m2 <- lmer(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  REML = F)
sjPlot::plot_model(Height_Jun20_urbsubs_city_m2, type = "diag") # looks good

# main effects
Height_Jun20_urbsubs_city_m2_ME <- lmer(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  REML = F)




# URB SUBTRANSECTS / URB SCORE-----

# Height_Jun20_urbsubs_usc_m1 <- lmer(Total_Height_June ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(Height_Jun20_urbsubs_usc_m1, type = "diag") # right-skewed & singular

Height_Jun20_urbsubs_usc_m2 <- lmer(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  REML = F,
      control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(Height_Jun20_urbsubs_usc_m2, type = "diag") # looks good

# main effects
Height_Jun20_urbsubs_usc_m2_ME <- lmer(sqrt(Total_Height_June) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  REML = F,
    control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

summary(Height_Jun20_urbsubs_usc_m2_ME)
```

#### Entire gradient: *Marg sig for City_dist, not for urb_score
##### City_dist
```{r}
car::Anova(Height_Jun20_gr_city_m5) # marg sig



# 
# # ANy variation within families or populations?
# m.1 <- lmer(sqrt(Total_Height_June) ~ (1|Population/Family), data = heights_both_2020, REML = T)
# 
# ranova(m.1)
# # YES for among families
# 
# 
# sum.1 <- summary(m.1)
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_JuneHeight_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_JuneHeight_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)


```

##### Urb_score
```{r}
car::Anova(Height_Jun20_gr_usc_m2) # not sig
```

#### Urban subtransects: *Not sig for either
##### City_dist
```{r}
car::Anova(Height_Jun20_urbsubs_city_m2) # nothing sig
car::Anova(Height_Jun20_urbsubs_city_m2_ME) # nothing sig



# 
# # ANy variation among families or populations?
# m.1 <- lmer(sqrt(Total_Height_June) ~ (1|Population/Family),
#             data = heights_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#             REML = T)
# ranova(m.1)
# # YES? (marg sig) for among families
# 
# m.2 <- lmer(sqrt(Total_Height_June) ~ (1|Population/Family) + Transect_ID,
#             data = heights_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#             REML = F)
# car::Anova(m.2)
# # not among transects though
# 
# 
# m.3 <- lmer(sqrt(Total_Height_June) ~ (1|Population/Family) + Transect_ID,
#             data = heights_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#             REML = T)
# car::Anova(m.3)
# # not sig in this or m.2
# 
# 
# sum.1 <- summary(m.1)
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_JuneHeight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_JuneHeight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# write.table(car::Anova(m.2), here::here("./Figures_Tables/ranova_PVE/2020_JuneHeight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# 

```

##### Urb_score
```{r}
car::Anova(Height_Jun20_urbsubs_usc_m2) # not sig
car::Anova(Height_Jun20_urbsubs_usc_m2_ME) # not sig

```

#### Export ANOVA
```{r}
# anova_table_flx(Height_Jun20_gr_city_m5)
# anova_table_flx(Height_Jun20_gr_usc_m2)
# anova_table_flx(Height_Jun20_urbsubs_city_m2)
# anova_table_flx(Height_Jun20_urbsubs_city_m2_ME)
# anova_table_flx(Height_Jun20_urbsubs_usc_m2)
# anova_table_flx(Height_Jun20_urbsubs_usc_m2_ME)
# 
# AIC_compare.city_dist_transf(Height_Jun20_urbsubs_city_m2,
#                       Height_Jun20_urbsubs_city_m2_ME)
#     
# AIC_compare.urb_score_transf(Height_Jun20_urbsubs_usc_m2,
#                       Height_Jun20_urbsubs_usc_m2_ME) 

```

### Sept height
#### lmer: diagnostics
```{r}
# GRADIENT / CITY_DIST-----

# Height_Sept20_gr_city_m1 <- lmer(Total_Height_Sept ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020, REML = F,
#       control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(Height_Sept20_gr_city_m1, type = "diag") # right-skewed

Height_Sept20_gr_city_m2 <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_both_2020, REML = F)
sjPlot::plot_model(Height_Sept20_gr_city_m2, type = "diag") # looks good





# GRADIENT / URB SCORE-----

# Height_Sept20_gr_usc_m1 <- lmer(Total_Height_Sept ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(Height_Sept20_gr_usc_m1, type = "diag") # right-skewed
# 
# 
# Height_Sept20_gr_usc_m2 <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020, REML = F,
#         control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(Height_Sept20_gr_usc_m2, type = "diag") # looks good though singular... take out block 
# 
# Height_Sept20_gr_usc_m3 <- lmer(sqrt(Total_Height_Sept) ~ (1|Population/Family) + Urb_score,
#   data = heights_both_2020, REML = F,
#         control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(Height_Sept20_gr_usc_m3, type = "diag") # looks ok
# 
# AIC(Height_Sept20_gr_usc_m2, Height_Sept20_gr_usc_m3) # model with block has significantly lower AIC... leave it in
# 
# Height_Sept20_gr_usc_m4 <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population) + Urb_score,
#   data = heights_both_2020, REML = F,
#         control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(Height_Sept20_gr_usc_m4, type = "diag") # looks ok
# 
# 
# car::Anova(Height_Sept20_gr_usc_m2) # very similar results to model below
# car::Anova(Height_Sept20_gr_usc_m4)
# 
# 
# AIC(Height_Sept20_gr_usc_m2, Height_Sept20_gr_usc_m4) # nearly identical AIC... use m4

# try glmmTMB
Height_Sept20_gr_usc_m5 <- glmmTMB(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_both_2020,
  family = gaussian) # works! use this



# URB SUBTRANSECTS / CITY_DIST-----

# Height_Sept20_urbsubs_city_m1 <- lmer(Total_Height_Sept ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(Height_Sept20_urbsubs_city_m1, type = "diag") # right-skewed & singular
# 
# Height_Sept20_urbsubs_city_m2 <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#         control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(Height_Sept20_urbsubs_city_m2, type = "diag") # looks good but still singular... take out block
# 
# Height_Sept20_urbsubs_city_m3 <- lmer(sqrt(Total_Height_Sept) ~  (1|Population/Family) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#         control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(Height_Sept20_urbsubs_city_m3, type = "diag") # still singular... take out fam
# 
# Height_Sept20_urbsubs_city_m4 <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#         control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(Height_Sept20_urbsubs_city_m4, type = "diag") # looks ok 

# AIC(Height_Sept20_urbsubs_city_m2, Height_Sept20_urbsubs_city_m4) # nearly identical AIC
# 
# car::Anova(Height_Sept20_urbsubs_city_m4) # extremely similar results!
# car::Anova(Height_Sept20_urbsubs_city_m2)

# try glmmTMB
Height_Sept20_urbsubs_city_m5 <- glmmTMB(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = gaussian) # works! use this


# main effects
Height_Sept20_urbsubs_city_m5_ME <- glmmTMB(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = gaussian) # works! use this




# URB SUBTRANSECTS / URB SCORE-----

# Height_Sept20_urbsubs_usc_m1 <- lmer(Total_Height_Sept ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(Height_Sept20_urbsubs_usc_m1, type = "diag") # right-skewed


Height_Sept20_urbsubs_usc_m2 <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  REML = F)
sjPlot::plot_model(Height_Sept20_urbsubs_usc_m2, type = "diag") # looks good


# main effects
Height_Sept20_urbsubs_usc_m2_ME <- lmer(sqrt(Total_Height_Sept) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  REML = F,
    control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

summary(Height_Sept20_urbsubs_usc_m2_ME)
```
#### Entire gradient: *sig for city_dist, not for urb_score
###### City_dist
```{r}
car::Anova(Height_Sept20_gr_city_m2) # sig

# 
# # ANy variation within families or populations?
# m.1 <- lmer(Total_Height_Sept ~ (1|Population/Family), data = heights_both_2020, REML = T)
# 
# ranova(m.1)
# # YES for among families
# 
# 
# sum.1 <- summary(m.1)
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_SeptHeight_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_SeptHeight_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)

```

###### Urb_score
```{r}
car::Anova(Height_Sept20_gr_usc_m5) # not sig
```

#### Urban subtransects: *Not sig for either
###### City_dist
```{r}
car::Anova(Height_Sept20_urbsubs_city_m5) # not sig
car::Anova(Height_Sept20_urbsubs_city_m5_ME)# not sig

# 
# # ANy variation among families or populations?
# m.1 <- lmer(sqrt(Total_Height_Sept) ~ (1|Population/Family),
#             data = heights_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#             REML = T)
# ranova(m.1)
# # no
# 
# m.2 <- lmer(sqrt(Total_Height_Sept) ~ (1|Population/Family) + Transect_ID,
#             data = heights_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#             REML = F)
# car::Anova(m.2)
# # not among transects either
# 
# 
# m.3 <- lmer(sqrt(Total_Height_Sept) ~ (1|Population/Family) + Transect_ID,
#             data = heights_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#             REML = T)
# car::Anova(m.3)
# # not sig in this or m.2
# 
# 
# sum.1 <- summary(m.1)
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_SeptHeight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_SeptHeight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# write.table(car::Anova(m.2), here::here("./Figures_Tables/ranova_PVE/2020_SeptHeight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```


###### Urb_score
```{r}
car::Anova(Height_Sept20_urbsubs_usc_m2) # not sig
car::Anova(Height_Sept20_urbsubs_usc_m2_ME)# not sig
```

#### Export ANOVA
```{r}
# anova_table_flx(Height_Sept20_gr_city_m2)
# anova_table_flx(Height_Sept20_gr_usc_m5)
# anova_table_flx(Height_Sept20_urbsubs_city_m5)
# anova_table_flx(Height_Sept20_urbsubs_city_m5_ME)
# anova_table_flx(Height_Sept20_urbsubs_usc_m2)
# anova_table_flx(Height_Sept20_urbsubs_usc_m2_ME)
# 
# AIC_compare.city_dist_transf(Height_Sept20_urbsubs_city_m5,
#                       Height_Sept20_urbsubs_city_m5_ME)
#     
# AIC_compare.urb_score_transf(Height_Sept20_urbsubs_usc_m2,
#                       Height_Sept20_urbsubs_usc_m2_ME) 

```
## Weevil scars: standardized by June height
### lmer: diagnostics
```{r}
# GRADIENT / CITY_DIST-----

# weev_stn_gr_city_m1 <- lmer(scar_div_Juneheight ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both, REML = F)
# sjPlot::plot_model(weev_stn_gr_city_m1, type = "diag") # is singular & right-skewed
# 
# weev_stn_gr_city_m2 <- lmer(log(scar_div_Juneheight + 1) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both, REML = F)
# sjPlot::plot_model(weev_stn_gr_city_m2, type = "diag") # sqrt, cube root, log still look bad... try binomial, then removing zeroes and going from there


# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

# recode plants as having height or not
weevil_both$scar_div_Juneheight_binary <- weevil_both$scar_div_Juneheight
weevil_both$scar_div_Juneheight_binary[weevil_both$scar_div_Juneheight_binary > 0] <- 1

weev_stn_gr_city_m3 <- glmer((scar_div_Juneheight_binary) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = weevil_both,
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(weev_stn_gr_city_m3)
plot(res)
# looks great! 
summary(weev_stn_gr_city_m3)

car::Anova(weev_stn_gr_city_m3) # not sig- so, whether the plant was attacked by weevils not associated with urbanization


# weev_stn_gr_city_m4 <- lmer(scar_div_Juneheight ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_city_m4, type='diag') #very right-skewed... try sqrt
# 
# weev_stn_gr_city_m5 <- lmer(sqrt(scar_div_Juneheight) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_city_m5, type='diag') # still r-skew... try cube rt
# 
# weev_stn_gr_city_m6 <- lmer((scar_div_Juneheight)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_city_m6, type='diag') # still r-skew... try log
# 
# weev_stn_gr_city_m7 <- lmer(log(scar_div_Juneheight) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_city_m7, type='diag') # much better but qqplot suspicious... good enough, I guess... still singular though. Take out block
# 
# weev_stn_gr_city_m8 <- lmer(log(scar_div_Juneheight) ~ (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out /Fam
# 
# weev_stn_gr_city_m9 <- lmer(log(scar_div_Juneheight) ~ (1|Block) + (1|Population) + City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out block
# 
# weev_stn_gr_city_m10 <- lmer(log(scar_div_Juneheight) ~ (1|Population) +  City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 


# try glmmTMB
# test1 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population) + City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   family = gaussian) # it works!
# 
# test1 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   family = gaussian) # it works! 

weev_stn_gr_city_m11 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family) + (1|Block) + City_dist,
  data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
  family = gaussian) # it works! use this


# GRADIENT / URB SCORE-----

# weev_stn_gr_usc_m1 <- lmer(scar_div_Juneheight ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both, REML = F)
# sjPlot::plot_model(weev_stn_gr_usc_m1, type = "diag") # is singular & right-skewed
# 
# weev_stn_gr_usc_m2 <- lmer((scar_div_Juneheight)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both, REML = F)
# sjPlot::plot_model(weev_stn_gr_usc_m2, type = "diag") # sqrt, cube root, log still look bad... try binomial, then removing zeroes and going from there


# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS
weev_stn_gr_usc_m3 <- glmer((scar_div_Juneheight_binary) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = weevil_both,
family = "binomial"(link = "logit"),
  nAGQ = 0,
control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(weev_stn_gr_usc_m3)
plot(res)
# looks great! 
summary(weev_stn_gr_usc_m3)

car::Anova(weev_stn_gr_usc_m3) # not sig- so, whether the plant was attacked by weevils not associated with urbanization


# weev_stn_gr_usc_m4 <- lmer(scar_div_Juneheight ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_usc_m4, type='diag') #very right-skewed... try sqrt
# 
# weev_stn_gr_usc_m5 <- lmer(sqrt(scar_div_Juneheight) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_usc_m5, type='diag') # still r-skew... try cube rt
# 
# weev_stn_gr_usc_m6 <- lmer((scar_div_Juneheight)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_usc_m6, type='diag') # still r-skew... try log
# 
# weev_stn_gr_usc_m7 <- lmer(log(scar_div_Juneheight) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_usc_m7, type='diag') # much better but qqplot suspicious...still singular though. Take out block
# 
# weev_stn_gr_usc_m8 <- lmer(log(scar_div_Juneheight) ~ (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out Fam
# 
# weev_stn_gr_usc_m10 <- lmer(log(scar_div_Juneheight) ~ (1|Block) + (1|Population) + Urb_score,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out block too
# 
# weev_stn_gr_usc_m11 <- lmer(log(scar_div_Juneheight) ~ (1|Population) + Urb_score,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 


# try glmmTMB
weev_stn_gr_usc_m12 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family) + (1|Block) + Urb_score,
  data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
  family = gaussian) # it works! use this







# URB SUBTRANSECTS / CITY_DIST-----

# weev_stn_urbsubs_city_m1 <- lmer(scar_div_Juneheight ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(weev_stn_urbsubs_city_m1, type = "diag") # right-skewed
# 
# weev_stn_urbsubs_city_m2 <- lmer(sqrt(scar_div_Juneheight) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_urbsubs_city_m2, type = "diag") # still very right-skewed...
# 
# weev_stn_urbsubs_city_m3 <- lmer((scar_div_Juneheight)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_urbsubs_city_m3, type = "diag") # still very right-skewed... should take out zeroes and look at binomial, then quantatitative

# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS
weev_stn_urbsubs_city_m4 <- glmer((scar_div_Juneheight_binary) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = weevil_both %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(weev_stn_urbsubs_city_m4)
plot(res)
# looks great! 

car::Anova(weev_stn_urbsubs_city_m4) # not sig- so, whether the plant was attacked by weevils not associated with urbanization nor urban subtr

# main effects
weev_stn_urbsubs_city_m4_ME <- glmer((scar_div_Juneheight_binary) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = weevil_both %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

# weev_stn_urbsubs_city_m4 <- lmer(scar_div_Juneheight ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_urbsubs_city_m4, type='diag') #very right-skewed... try sqrt
# 
# weev_stn_urbsubs_city_m5 <- lmer(sqrt(scar_div_Juneheight) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_urbsubs_city_m5, type='diag') #still right-skewed... though better... try cube root
# 
# weev_stn_urbsubs_city_m6 <- lmer((scar_div_Juneheight)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_urbsubs_city_m6, type='diag') # looks pretty good... try log
# 
# 
# weev_stn_urbsubs_city_m7 <- lmer(log(scar_div_Juneheight + 0.1) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_urbsubs_city_m7, type='diag') # looks the same as cube root but maybe a little better? still singular though. Take out block
# 
# weev_stn_urbsubs_city_m8 <- lmer(log(scar_div_Juneheight) ~ (1|Population/Family) +  City_dist * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out Fam
# 
# weev_stn_urbsubs_city_m9 <- lmer(log(scar_div_Juneheight) ~ (1|Block) + (1|Population) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) #  singular... take out block
# 
# weev_stn_urbsubs_city_m10 <- lmer(log(scar_div_Juneheight) ~  (1|Population) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"), 
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) #  singular... 


# try glmmTMB
weev_stn_urbsubs_city_m11 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family) + (1|Block) + City_dist * Transect_ID,
  data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"), 
  family = gaussian) # it works! use this



# main effects
# test2 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family) + (1|Block) + City_dist + Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"), 
#   family = gaussian) # singular,,, taje out block
# 
# weev_stn_urbsubs_city_m11_ME.1 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family)  + City_dist + Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"), 
#   family = gaussian) # works now. Take out block and put back in Family to see if it changes

weev_stn_urbsubs_city_m11_ME.2 <- glmmTMB(log(scar_div_Juneheight) ~ + (1|Block) + (1|Population)  + City_dist + Transect_ID,
  data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"), 
  family = gaussian) # works too

car::Anova(weev_stn_urbsubs_city_m11)
car::Anova(weev_stn_urbsubs_city_m11_ME.1)
car::Anova(weev_stn_urbsubs_city_m11_ME.2) # these results much more similar to full model than model above (.1) so will use this.


# URB SUBTRANSECTS / URB SCORE-----

# weev_stn_urbsubs_usc_m1 <- lmer(scar_div_Juneheight ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(weev_stn_urbsubs_usc_m1, type = "diag") # right-skewed
# 
# weev_stn_urbsubs_usc_m2 <- lmer(sqrt(scar_div_Juneheight) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_urbsubs_usc_m2, type = "diag") # still very right-skewed...
# 
# weev_stn_urbsubs_usc_m3 <- lmer((scar_div_Juneheight)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_urbsubs_usc_m3, type = "diag") # still very right-skewed... should take out zeroes and look at binomial, then quantatitative

# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS
weev_stn_urbsubs_usc_m4 <- glmer((scar_div_Juneheight_binary) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = weevil_both %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
    nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(weev_stn_urbsubs_usc_m4)
plot(res)
# looks great! 

car::Anova(weev_stn_urbsubs_usc_m4) # not sig- so, whether the plant was attacked by weevils not associated with urbanization nor urban subtr

# main effects
weev_stn_urbsubs_usc_m4_ME <- glmer((scar_div_Juneheight_binary) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = weevil_both %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
    nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))


# weev_stn_gr_usc_m4 <- lmer(scar_div_Juneheight ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_usc_m4, type='diag') #very right-skewed... try sqrt
# 
# weev_stn_gr_usc_m5 <- lmer(sqrt(scar_div_Juneheight) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_usc_m5, type='diag') #still right-skewed... though better... try cube root
# 
# weev_stn_gr_usc_m6 <- lmer((scar_div_Juneheight)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_usc_m6, type='diag') # looks pretty good... try log
# 
# 
# weev_stn_gr_usc_m7 <- lmer(log(scar_div_Juneheight + 0.1) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_stn_gr_usc_m7, type='diag') # looks the same as cube root but maybe a little better? still singular though...Take out block
# 
# weev_stn_gr_usc_m8 <- lmer(log(scar_div_Juneheight) ~ (1|Population/Family) +  Urb_score * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out Fam
# 
# weev_stn_gr_usc_m9 <- lmer(log(scar_div_Juneheight) ~ (1|Block) + (1|Population) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) #  singular... take out block
# 
# weev_stn_gr_usc_m10 <- lmer(log(scar_div_Juneheight) ~ (1|Population) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) #  singular... 



# try glmmTMB
weev_stn_usc_usc_m10 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family) + (1|Block) + Urb_score * Transect_ID,
  data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"), 
  family = gaussian) # it works! use this



# main effects
# test2 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family) + (1|Block) + Urb_score + Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   family = gaussian) # singular,,, taje out block
# 
# weev_stn_usc_usc_m10_ME.1 <- glmmTMB(log(scar_div_Juneheight) ~ (1|Population/Family)  + Urb_score + Transect_ID,
#   data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#   family = gaussian) # works now. Take out block and put back in Family to see if it changes

weev_stn_usc_usc_m10_ME.2 <- glmmTMB(log(scar_div_Juneheight) ~ + (1|Block) + (1|Population)  + Urb_score + Transect_ID,
  data = weevil_both %>% filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"), 
  family = gaussian) # works too

car::Anova(weev_stn_usc_usc_m10)
car::Anova(weev_stn_usc_usc_m10_ME.1)
car::Anova(weev_stn_usc_usc_m10_ME.2) # these results much more similar to full model than model above (.1) so will use this.


```

### Entire gradient: *Not sig for either
#### City_dist
```{r}
car::Anova(weev_stn_gr_city_m3) # binomial: not sig
car::Anova(weev_stn_gr_city_m11) # quantitative: not sig


# 
# # ANy variation within families or populations?
# m.1 <- lmer(log(scar_div_Juneheight) ~ (1|Population/Family),
#             data = weevil_both %>% filter(scar_div_Juneheight_binary == 1),
#             REML = T)
# 
# ranova(m.1)
# # No for both
# 
# 
# sum.1 <- summary(m.1)
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_Weevildivheight_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Weevildivheight_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

#### Urb_score
```{r}
car::Anova(weev_stn_gr_usc_m3) # binomial: not sig
car::Anova(weev_stn_gr_usc_m12) # quantitative: not sig

```


### Urban subtransects: *Marg sig transect for city_dist
#### City_dist
```{r}
car::Anova(weev_stn_urbsubs_city_m4) # binomial: nothing sig
car::Anova(weev_stn_urbsubs_city_m4_ME) # binomial: nothing sig
car::Anova(weev_stn_urbsubs_city_m11) # quantitative: transect marg sig
car::Anova(weev_stn_urbsubs_city_m11_ME.2) #quant main effects: transect marg sig

AIC(weev_stn_urbsubs_city_m11, weev_stn_urbsubs_city_m11_ME.2) # main effects has sig lower AIC

# 
# # ANy variation among families or populations?
# m.1 <- lmer(log(scar_div_Juneheight) ~ (1|Population/Family),
#             data = weevil_both %>%
#               filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#             REML = T)
# ranova(m.1)
# # no, is singular
# 
# 
# m.2 <- lmer(log(scar_div_Juneheight) ~ (1|Population/Family) + Transect_ID,
#             data = weevil_both %>%
#               filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#             REML = F)
# car::Anova(m.2)
# # not among transects either
# 
# 
# m.3 <- lmer(log(scar_div_Juneheight) ~ (1|Population/Family) + Transect_ID,
#               data = weevil_both %>%
#               filter(scar_div_Juneheight_binary == 1 & Urb_Rur == "Urban"),
#             REML = T)
# car::Anova(m.3)
# # not sig in this or m.2
# 
# 
# sum.1 <- summary(m.1)
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_Weevildivheight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Weevildivheight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# write.table(car::Anova(m.2), here::here("./Figures_Tables/ranova_PVE/2020_Weevildivheight_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

#### Urb_score
```{r}
car::Anova(weev_stn_urbsubs_usc_m4) # binomial: not sig
car::Anova(weev_stn_usc_usc_m10) # quantitative: not sig
car::Anova(weev_stn_usc_usc_m10_ME.2)

AIC(weev_stn_usc_usc_m10, weev_stn_usc_usc_m10_ME.2) # ME better but <2 AIC away
```


### Export ANOVA
```{r}
# anova_table_flx(weev_stn_gr_city_m3)
# anova_table_flx(weev_stn_gr_city_m11)
# anova_table_flx(weev_stn_gr_usc_m3)
# anova_table_flx(weev_stn_gr_usc_m12)
# 
# anova_table_flx(weev_stn_urbsubs_city_m4)
# anova_table_flx(weev_stn_urbsubs_city_m4_ME)
# anova_table_flx(weev_stn_urbsubs_city_m11)
# anova_table_flx(weev_stn_urbsubs_city_m11_ME.2)
# 
# anova_table_flx(weev_stn_urbsubs_usc_m4)
# anova_table_flx(weev_stn_urbsubs_usc_m4_ME)
# anova_table_flx(weev_stn_usc_usc_m10)
# anova_table_flx(weev_stn_usc_usc_m10_ME.2)
# 
# 
# AIC_compare.city_dist_transf_binomial(weev_stn_urbsubs_city_m4,
#                       weev_stn_urbsubs_city_m4_ME)
# 
# AIC_compare.city_dist_transf_quantitative(weev_stn_urbsubs_city_m11,
#                       weev_stn_urbsubs_city_m11_ME.2)
# 
# AIC_compare.urb_score_transf_binomial(weev_stn_urbsubs_usc_m4,
#                       weev_stn_urbsubs_usc_m4_ME)
# 
# AIC_compare.urb_score_transf_quantitative(weev_stn_usc_usc_m10,
#                       weev_stn_usc_usc_m10_ME.2) 

```

## Weevil scars: NOT standardized by June height
### lmer
```{r}
# GRADIENT / CITY_DIST-----

# weev_gr_city_m1 <- lmer(Scar_length_cm ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both,
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_city_m1, type = "diag") # right-skewed
# 
# weev_gr_city_m2 <- lmer(sqrt(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both, REML = F,
#       control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_city_m2, type = "diag") # sqrt, cube root, log still look bad... try binomial, then removing zeroes and going from there


# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

# recode plants as having height or not
weevil_both$Scar_length_cm_binary <- weevil_both$Scar_length_cm
weevil_both$Scar_length_cm_binary[weevil_both$Scar_length_cm_binary > 0] <- 1

weev_gr_city_m3 <- glmer((Scar_length_cm_binary) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = weevil_both,
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(weev_gr_city_m3)
plot(res)
# looks great! 
summary(weev_gr_city_m3)

car::Anova(weev_gr_city_m3) # not sig- so, whether the plant was attacked by weevils not associated with urbanization


# weev_gr_city_m4 <- lmer(Scar_length_cm ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_city_m4, type='diag') #very right-skewed... try sqrt
# 
# weev_gr_city_m5 <- lmer(sqrt(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_city_m5, type='diag') # still r-skew... try cube rt
# 
# weev_gr_city_m6 <- lmer((Scar_length_cm)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_city_m6, type='diag') # still r-skew... try log
# 
# weev_gr_city_m7 <- lmer(log(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_city_m7, type='diag') # much better  still singular though. Take out block
# 
# weev_gr_city_m8 <- lmer(log(Scar_length_cm) ~ (1|Population/Family) + City_dist,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out Fam
# 
# weev_gr_city_m9 <- lmer(log(Scar_length_cm) ~ (1|Block) + (1|Population) + City_dist,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out block
# 
# weev_gr_city_m10 <- lmer(log(Scar_length_cm) ~ (1|Population) + City_dist,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 

# try glmmTMB
weev_gr_city_m11 <- glmmTMB(log(Scar_length_cm) ~ (1|Population/Family) + (1|Block) + City_dist,
  data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"), 
  family = gaussian) # it works! use this




# GRADIENT / URB SCORE-----

# weev_gr_usc_m1 <- lmer(Scar_length_cm ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both, REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_usc_m1, type = "diag") # right-skewed
# 
# weev_gr_usc_m2 <- lmer((Scar_length_cm)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both, REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_usc_m2, type = "diag") # sqrt, cube root, log still look bad... try binomial, then removing zeroes and going from there


# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS
weev_gr_usc_m3 <- glmer((Scar_length_cm_binary) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = weevil_both,
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(weev_gr_usc_m3)
plot(res)
# looks great! 
summary(weev_gr_usc_m3)

car::Anova(weev_gr_usc_m3) # not sig- so, whether the plant was attacked by weevils not associated with urbanization


# weev_gr_usc_m4 <- lmer(Scar_length_cm ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_usc_m4, type='diag') #very right-skewed... try sqrt
# 
# weev_gr_usc_m5 <- lmer(sqrt(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_usc_m5, type='diag') # still r-skew... try cube rt
# 
# weev_gr_usc_m6 <- lmer((Scar_length_cm)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_usc_m6, type='diag') # still r-skew... try log
# 
# weev_gr_usc_m7 <- lmer(log(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_gr_usc_m7, type='diag') # much better but qqplot suspicious... good enough, I guess still singular though. Take out block
# 
# weev_gr_usc_m8 <- lmer(log(Scar_length_cm) ~ (1|Population/Family) + Urb_score,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out /Fam
# 
# weev_gr_usc_m9 <- lmer(log(Scar_length_cm) ~ (1|Block) + (1|Population) + Urb_score,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out block
# 
# weev_gr_usc_m10 <- lmer(log(Scar_length_cm) ~ (1|Population) + Urb_score,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 

# try glmmTMB
weev_gr_usc_m10 <- glmmTMB(log(Scar_length_cm) ~ (1|Population/Family) + (1|Block) + Urb_score,
  data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"), 
  family = gaussian) # it works! use this


# URB SUBTRANSECTS / CITY_DIST-----

# weev_urbsubs_city_m1 <- lmer(Scar_length_cm ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(weev_urbsubs_city_m1, type = "diag") # right-skewed
# 
# weev_urbsubs_city_m2 <- lmer(sqrt(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_city_m2, type = "diag") # still very right-skewed...
# 
# weev_urbsubs_city_m3 <- lmer((Scar_length_cm)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_city_m3, type = "diag") # still very right-skewed... should take out zeroes and look at binomial, then quantatitative

# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS
weev_urbsubs_city_m4 <- glmer((Scar_length_cm_binary) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = weevil_both %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(weev_urbsubs_city_m4)
plot(res)
# looks great! 

car::Anova(weev_urbsubs_city_m4) # not sig- so, whether the plant was attacked by weevils not associated with urbanization nor urban subtr


# main effects
weev_urbsubs_city_m4_ME <- glmer((Scar_length_cm_binary) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = weevil_both %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

# weev_urbsubs_city_m4 <- lmer(Scar_length_cm ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_city_m4, type='diag') #very right-skewed... try sqrt
# 
# weev_urbsubs_city_m5 <- lmer(sqrt(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_city_m5, type='diag') #still right-skewed... though better... try cube root
# 
# weev_urbsubs_city_m6 <- lmer((Scar_length_cm)^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_city_m6, type='diag') # looks pretty good! try log just in case
# 
# 
# weev_urbsubs_city_m7 <- lmer(log(Scar_length_cm + 0.1) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_city_m7, type='diag') # looks the same as cube root but maybe a little better? a bit of kurtosis thoughstill singular though. Take out block
# 
# weev_urbsubs_city_m8 <- lmer(log(Scar_length_cm) ~ (1|Population/Family) + City_dist* Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out Fam
# 
# weev_urbsubs_city_m9 <- lmer(log(Scar_length_cm) ~ (1|Block) +  (1|Population) + City_dist* Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out block too
# 
# weev_urbsubs_city_m10 <- lmer(log(Scar_length_cm) ~  (1|Population) + City_dist* Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 

# try glmmTMB
weev_urbsubs_city_m11 <- glmmTMB(log(Scar_length_cm + 0.1) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
  family = gaussian) # it works! use this



# main effects
weev_urbsubs_city_m11_ME <- glmmTMB(log(Scar_length_cm + 0.1) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
  family = gaussian) # it works! use this



# URB SUBTRANSECTS / URB SCORE-----

# weev_urbsubs_usc_m1 <- lmer(Scar_length_cm ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(weev_urbsubs_usc_m1, type = "diag") # right-skewed
# 
# weev_urbsubs_usc_m2 <- lmer(sqrt(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_usc_m2, type = "diag") # still very right-skewed...
# 
# weev_urbsubs_usc_m3 <- lmer((Scar_length_cm)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Urb_Rur == "Urban"),
#   REML = F,
#     control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_usc_m3, type = "diag") # still very right-skewed... should take out zeroes and look at binomial, then quantatitative

# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS
weev_urbsubs_usc_m4 <- glmer((Scar_length_cm_binary) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = weevil_both %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(weev_urbsubs_usc_m4)
plot(res)
# looks great! 

car::Anova(weev_urbsubs_usc_m4) # not sig- so, whether the plant was attacked by weevils not associated with urbanization nor urban subtr


# main effects
weev_urbsubs_usc_m4_ME <- glmer((Scar_length_cm_binary) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = weevil_both %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

# weev_urbsubs_usc_m4 <- lmer(Scar_length_cm ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_usc_m4, type='diag') #very right-skewed... try sqrt
# 
# weev_urbsubs_usc_m5 <- lmer(sqrt(Scar_length_cm) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_usc_m5, type='diag') #still right-skewed... though better... try cube root
# 
# weev_urbsubs_usc_m6 <- lmer((Scar_length_cm)^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_usc_m6, type='diag') # looks pretty good... try log
# 
# 
# weev_urbsubs_usc_m7 <- lmer(log(Scar_length_cm + 0.1) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(weev_urbsubs_usc_m7, type='diag') # looks the same as cube root but maybe a little better? some kurtosis though still singular  Take out block
# 
# weev_urbsubs_usc_m8 <- lmer(log(Scar_length_cm) ~ (1|Population/Family) + Urb_score* Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out Fam
# 
# weev_urbsubs_usc_m9 <- lmer(log(Scar_length_cm) ~ (1|Block) +  (1|Population) + Urb_score* Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... take out block too
# 
# weev_urbsubs_usc_m10 <- lmer(log(Scar_length_cm) ~  (1|Population) + Urb_score* Transect_ID,
#   data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 

# try glmmTMB
weev_urbsubs_usc_m11 <- glmmTMB(log(Scar_length_cm + 0.1) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
  family = gaussian) # it works! use this



# main effects
weev_urbsubs_usc_m11_ME <- glmmTMB(log(Scar_length_cm + 0.1) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
  family = gaussian) # it works! use this

```

### Entire gradient: *NOt sig for either
#### City_dist
```{r}
car::Anova(weev_gr_city_m3) # binomial: not sig
car::Anova(weev_gr_city_m11) # quantitative: not sig

# 
# 
# # ANy variation within families or populations?
# m.1 <- lmer(log(Scar_length_cm) ~ (1|Population/Family),
#             data = weevil_both %>% filter(Scar_length_cm_binary == 1),
#             REML = T)
# 
# ranova(m.1)
# # No for both
# 
# 
# sum.1 <- summary(m.1)
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_Weevil_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Weevil_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```


#### Urb_score
```{r}
car::Anova(weev_gr_usc_m3) # binomial: not sig
car::Anova(weev_gr_usc_m10) # quantitative: not sig

```


### Urban subtransects: *Transect sig for city_dist AND urb_score
#### City_dist
```{r}
car::Anova(weev_urbsubs_city_m4) # binomial: not sig
car::Anova(weev_urbsubs_city_m4_ME) # binomial: not sig
car::Anova(weev_urbsubs_city_m11) # quantitative: transect sig
car::Anova(weev_urbsubs_city_m11_ME) # quantitative main effects: transect sig

AIC(weev_urbsubs_city_m11, weev_urbsubs_city_m11_ME)# main effects lower AIC (less than 2)

# 
# 
# # ANy variation among families or populations?
# m.1 <- lmer(log(Scar_length_cm) ~ (1|Population/Family),
#               data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#             REML = T)
# ranova(m.1)
# # no
# 
# m.2 <- lmer(log(Scar_length_cm) ~ (1|Population/Family) + Transect_ID,
#               data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
# 
#             REML = F)
# car::Anova(m.2)
# # YES among transects 
# 
# 
# m.3 <- lmer(log(Scar_length_cm) ~ (1|Population/Family) + Transect_ID,
#               data = weevil_both %>% filter(Scar_length_cm_binary == 1 & Urb_Rur == "Urban"),
#             REML = T)
# car::Anova(m.3)
# # YES among transects
# 
# 
# sum.1 <- summary(m.1)
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_Weevil_urban_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Weevil_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# write.table(car::Anova(m.2), here::here("./Figures_Tables/ranova_PVE/2020_Weevil_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)

```

#### Urb_score
```{r}
car::Anova(weev_urbsubs_usc_m4) # binomial: not sig
car::Anova(weev_urbsubs_usc_m4_ME) # binomial: not sig
car::Anova(weev_urbsubs_usc_m11) # quantitative: transect sig
car::Anova(weev_urbsubs_usc_m11_ME) # quantitative main effects: transect sig

AIC(weev_urbsubs_usc_m11, weev_urbsubs_usc_m11_ME)# main effects lower AIC (less than 2)


```

### Export ANOVA
```{r}
# anova_table_flx(weev_gr_city_m3)
# anova_table_flx(weev_gr_city_m11)
# anova_table_flx(weev_gr_usc_m3)
# anova_table_flx(weev_gr_usc_m10)
# 
# anova_table_flx(weev_urbsubs_city_m4)
# anova_table_flx(weev_urbsubs_city_m4_ME) 
# anova_table_flx(weev_urbsubs_city_m11)
# anova_table_flx(weev_urbsubs_city_m11_ME)
# anova_table_flx(weev_urbsubs_usc_m4)
# anova_table_flx(weev_urbsubs_usc_m4_ME)
# anova_table_flx(weev_urbsubs_usc_m11)
# anova_table_flx(weev_urbsubs_usc_m11_ME)
# 
# 
# AIC_compare.city_dist_transf_binomial(weev_urbsubs_city_m4,
#                       weev_urbsubs_city_m4_ME)
# 
# AIC_compare.city_dist_transf_quantitative(weev_urbsubs_city_m11,
#                       weev_urbsubs_city_m11_ME)
# 
# AIC_compare.urb_score_transf_binomial(weev_urbsubs_usc_m4,
#                       weev_urbsubs_usc_m4_ME)
# 
# AIC_compare.urb_score_transf_quantitative(weev_urbsubs_usc_m11,
#                       weev_urbsubs_usc_m11_ME) 

```

## Herbivory
### July
#### glmer: diagnostics
```{r}
# Gradient / city_dist----------

# herb2020_gr_dist_m1 <- glmer(Herbivory.July_mean ~ (1|Block)  + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020,
#   family = binomial,
#   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# res <- simulateResiduals(herb2020_gr_dist_m1)
# plot(res)
# # major errors... try beta distribution
# 
# 
# herb2020_gr_dist_m2 <- glmmTMB(Herbivory.July_mean  ~ (1|Block) +  (1|Population/Family) + City_dist,
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# # Error in eval(family$initialize) : y values must be 0 < y < 1
# # recode: 0s as 0.00001 & 1 as 0.999999

herbivory_both_2020$Herbivory.July_mean_recode <- herbivory_both_2020$Herbivory.July_mean
herbivory_both_2020$Herbivory.July_mean_recode[herbivory_both_2020$Herbivory.July_mean == 1] <- 0.999999
herbivory_both_2020$Herbivory.July_mean_recode[herbivory_both_2020$Herbivory.July_mean == 0] <- 0.000001


# herb2020_gr_dist_m3 <- glmmTMB(Herbivory.July_mean_recode  ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020_gr_dist_m3)
# plot(res)
# # IT WORKS
# 
# hist(herbivory_both_2020$Herbivory.July_mean_recode, breaks = 30)
# summary(herb2020_gr_dist_m3)
# testDispersion(herb2020_gr_dist_m3)
# testZeroInflation(herb2020_gr_dist_m3)
# 
# # address overdispersion through an individual-level random effect
# herbivory_both_2020$ID <- seq.int(nrow(herbivory_both_2020))
# 
# herb2020_gr_dist_m4 <- glmmTMB(Herbivory.July_mean_recode  ~ (1|Block) + (1|Population/Family) + City_dist + (1|ID),
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020_gr_dist_m4)
# plot(res)
# # better but still not optimal
# 
# testDispersion(herb2020_gr_dist_m4) # is it underdispersed now?
# testZeroInflation(herb2020_gr_dist_m4)
# 
# # try binomial and then quantitative?



# recode plants as having height or not
herbivory_both_2020$Herbivory.July_mean_binary <- herbivory_both_2020$Herbivory.July_mean
herbivory_both_2020$Herbivory.July_mean_binary[herbivory_both_2020$Herbivory.July_mean_binary > 0] <- 1

herb2020_gr_dist_m5 <- glmer((Herbivory.July_mean_binary) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = herbivory_both_2020,
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herb2020_gr_dist_m5)
plot(res)
# looks great! 
summary(herb2020_gr_dist_m5)

car::Anova(herb2020_gr_dist_m5) # not sig


# herb2020_gr_dist_m6 <- lmer(Herbivory.July_mean ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_gr_dist_m6, type='diag') #very right-skewed... try cube root
# 
# herb2020_gr_dist_m7 <- lmer(Herbivory.July_mean^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_gr_dist_m7, type='diag') # still right-skewed... try log

herb2020_gr_dist_m8 <- lmer(log(Herbivory.July_mean) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(herb2020_gr_dist_m8, type='diag') # looks great!

car::Anova(herb2020_gr_dist_m8) # not sig




# Gradient / urb_score----------

# herb2020_gr_usc_m1 <-  glmer(Herbivory.July_mean ~ (1|Block)  + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020,
#   family = binomial,
#   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# res <- simulateResiduals(herb2020_gr_usc_m1)
# plot(res)
# # major errors... try beta distribution
# 
# 
# herb2020_gr_usc_m2 <- glmmTMB(Herbivory.July_mean  ~ (1|Block) +  (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# # Error in eval(family$initialize) : y values must be 0 < y < 1
# # recode: 0s as 0.00001 & 1 as 0.999999
# 
# 
# herb2020_gr_usc_m3 <- glmmTMB(Herbivory.July_mean_recode  ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020_gr_usc_m3)
# plot(res)
# # IT WORKS
# 
# hist(herbivory_both_2020$Herbivory.July_mean_recode, breaks = 30)
# summary(herb2020_gr_usc_m3)
# testDispersion(herb2020_gr_usc_m3)
# testZeroInflation(herb2020_gr_usc_m3)
# 
# # address overdispersion through an individual-level random effect
# herb2020_gr_usc_m4 <- glmmTMB(Herbivory.July_mean_recode  ~ (1|Block) + (1|Population/Family) + Urb_score + (1|ID),
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020_gr_usc_m4)
# plot(res)
# # better but still not optimal
# 
# testDispersion(herb2020_gr_usc_m4) # is it underdispersed now?
# testZeroInflation(herb2020_gr_usc_m4)
# 
# # try binomial and then quantitative?



# recode plants as having height or not
herb2020_gr_usc_m5 <- glmer((Herbivory.July_mean_binary) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = herbivory_both_2020,
  family = "binomial"(link="logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herb2020_gr_usc_m5)
plot(res)
# looks great! 
summary(herb2020_gr_usc_m5)

car::Anova(herb2020_gr_usc_m5) # not sig


# herb2020_gr_usc_m6 <- lmer(Herbivory.July_mean ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_gr_usc_m6, type='diag') #very right-skewed... try cube root
# 
# herb2020_gr_usc_m7 <- lmer(Herbivory.July_mean^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_gr_usc_m7, type='diag') # still right-skewed... try log

herb2020_gr_usc_m8 <- lmer(log(Herbivory.July_mean) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(herb2020_gr_usc_m8, type='diag') # looks great!

car::Anova(herb2020_gr_usc_m8) # not sig






# Urb sites / city_dist----------

# herb2020_urb_dist_m1 <- glmer(Herbivory.July_mean ~ (1|Block)  + (1|Population/Family) + City_dist * Transect_ID,
#     data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#     family = binomial,
#   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# res <- simulateResiduals(herb2020_urb_dist_m1)
# plot(res)
# # major errors... try beta distribution
# 
# 
# herb2020_urb_dist_m2 <- glmmTMB(Herbivory.July_mean  ~ (1|Block) +  (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# # Error in eval(family$initialize) : y values must be 0 < y < 1
# # recode: 0s as 0.00001 & 1 as 0.999999
# 
# 
# herb2020_urb_dist_m3 <- glmmTMB(Herbivory.July_mean_recode  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020_urb_dist_m3)
# plot(res)
# # IT WORKS
# 
# summary(herb2020_urb_dist_m3)
# testDispersion(herb2020_urb_dist_m3)
# testZeroInflation(herb2020_urb_dist_m3)
# 
# # address overdispersion through an individual-level random effect
# 
# herb2020_urb_dist_m4 <- glmmTMB(Herbivory.July_mean_recode  ~ (1|Block) + (1|Population/Family) + City_dist + (1|ID),
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020_urb_dist_m4)
# plot(res)
# # better but still not optimal
# 
# testDispersion(herb2020_urb_dist_m4) # is it underdispersed now?
# testZeroInflation(herb2020_urb_dist_m4)
# 
# # try binomial and then quantitative?


herb2020_urb_dist_m5 <- glmer((Herbivory.July_mean_binary) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link="logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herb2020_urb_dist_m5)
plot(res)
# looks great! 
summary(herb2020_urb_dist_m5)

car::Anova(herb2020_urb_dist_m5) # city_dist sig


# main effects
herb2020_urb_dist_m5_ME <- glmer((Herbivory.July_mean_binary) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link="logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

# herb2020_urb_dist_m6 <- lmer(Herbivory.July_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_urb_dist_m6, type='diag') #very right-skewed... try cube root
# 
# herb2020_urb_dist_m7 <- lmer(Herbivory.July_mean^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_urb_dist_m7, type='diag') # still right-skewed... try log

# herb2020_urb_dist_m8 <- lmer(log(Herbivory.July_mean) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_urb_dist_m8, type='diag') # looks great! but stil singular... try glmmTMB

herb2020_urb_dist_m8 <- glmmTMB(log(Herbivory.July_mean) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
  family = gaussian)
sjPlot::plot_model(herb2020_urb_dist_m8, type='diag') # looks great!

car::Anova(herb2020_urb_dist_m8) # interaction not sig

# main effects
herb2020_urb_dist_m8_ME <- glmmTMB(log(Herbivory.July_mean) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
  family = gaussian)



# Urb sites / urb_score----------

# herb2020_urb_usc_m1 <- glmer(Herbivory.July_mean ~ (1|Block)  + (1|Population/Family) + Urb_score * Transect_ID,
#     data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#     family = binomial,
#   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# res <- simulateResiduals(herb2020_urb_usc_m1)
# plot(res)
# # major errors... try beta distribution
# 
# 
# herb2020_urb_usc_m2 <- glmmTMB(Herbivory.July_mean  ~ (1|Block) +  (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# # Error in eval(family$initialize) : y values must be 0 < y < 1
# # recode: 0s as 0.00001 & 1 as 0.999999
# 
# 
# herb2020_urb_usc_m3 <- glmmTMB(Herbivory.July_mean_recode  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020_urb_usc_m3)
# plot(res)
# # IT WORKS
# 
# summary(herb2020_urb_usc_m3)
# testDispersion(herb2020_urb_usc_m3)
# testZeroInflation(herb2020_urb_usc_m3)
# 
# # address overdispersion through an individual-level random effect
# 
# herb2020_urb_usc_m4 <- glmmTMB(Herbivory.July_mean_recode  ~ (1|Block) + (1|Population/Family) + Urb_score + (1|ID),
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020_urb_usc_m4)
# plot(res)
# # better but still not optimal
# 
# testDispersion(herb2020_urb_usc_m4) # is it underdispersed now?
# testZeroInflation(herb2020_urb_usc_m4)
# 
# # try binomial and then quantitative?


herb2020_urb_usc_m5 <- glmer((Herbivory.July_mean_binary) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link="logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herb2020_urb_usc_m5)
plot(res)
# looks great! 
summary(herb2020_urb_usc_m5)

car::Anova(herb2020_urb_usc_m5) # Urb_score marg sig


# main effects
herb2020_urb_usc_m5_ME <- glmer((Herbivory.July_mean_binary) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link="logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

# herb2020_urb_usc_m6 <- lmer(Herbivory.July_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_urb_usc_m6, type='diag') #very right-skewed... try cube root
# 
# herb2020_urb_usc_m7 <- lmer(Herbivory.July_mean^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020_urb_usc_m7, type='diag') # still right-skewed... try log

herb2020_urb_usc_m8 <- lmer(log(Herbivory.July_mean) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(herb2020_urb_usc_m8, type='diag') # looks great!

car::Anova(herb2020_urb_usc_m8) # nothing sig

# main effects
herb2020_urb_usc_m8_ME <- lmer(log(Herbivory.July_mean) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))


```

#### Entire gradient: *Not sig for either
##### City_dist
```{r}
car::Anova(herb2020_gr_dist_m5) # binomial: not sig
car::Anova(herb2020_gr_dist_m8) # quantitative: not sig



# 
# # ANy variation within families or populations?
# m.1 <- lmer(log(Herbivory.July_mean) ~ (1|Population/Family),
#             data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1),
#             REML = T,
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# ranova(m.1)
# # No for both
# 
# 
# sum.1 <- summary(m.1)
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_HerbivoryJuly_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_HerbivoryJuly_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

##### Urb_score
```{r}
car::Anova(herb2020_gr_usc_m5) # binomial: not sig
car::Anova(herb2020_gr_usc_m8) # quantitative: not sig

```


#### Urban subtransects: *Sig for city_dist (binomial and quantitative), marg sig for binomial (urb_score)
##### City_dist
```{r}
car::Anova(herb2020_urb_dist_m5) # binomial: city_dist sig
car::Anova(herb2020_urb_dist_m5_ME) # binomial: city_dist sig
car::Anova(herb2020_urb_dist_m8) # quantitative: city_dist sig
car::Anova(herb2020_urb_dist_m8_ME) # quantitative main effects: city_dist sig

AIC(herb2020_urb_dist_m5, herb2020_urb_dist_m5_ME) # very close
AIC(herb2020_urb_dist_m8, herb2020_urb_dist_m8_ME) # main effects has lower AIC ... but the interaxn is sig so ME model isn't relevant

# 
# 
# # ANy variation among families or populations?
# m.1 <- lmer(log(Herbivory.July_mean) ~  (1|Population/Family) + City_dist ,
#   data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)),
#   REML = T)
# 
# ranova(m.1)
# # no
# 
# m.2 <- lmer(log(Herbivory.July_mean) ~ (1|Population/Family) + Transect_ID,
#               data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Urb_Rur == "Urban"),
# 
#             REML = F)
# car::Anova(m.2)
# # not among transects either
# 
# 
# m.3 <- lmer(log(Herbivory.July_mean) ~ (1|Population/Family) + Transect_ID,
#               data = herbivory_both_2020 %>% filter(Herbivory.July_mean_binary == 1 & Urb_Rur == "Urban"),
#             REML = T)
# car::Anova(m.3)
# # also not sig among transects
# 
# 
# sum.1 <- summary(m.1)
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_HerbivoryJuly_urban_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_HerbivoryJuly_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# write.table(car::Anova(m.2), here::here("./Figures_Tables/ranova_PVE/2020_HerbivoryJuly_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

##### Urb_score
```{r}
car::Anova(herb2020_urb_usc_m5) # binomial: urb_score marg sig
car::Anova(herb2020_urb_usc_m5_ME) # binomial: urb_score marg sig
car::Anova(herb2020_urb_usc_m8) # quantitative: nothing sig
car::Anova(herb2020_urb_usc_m8_ME) # quantitative main effects: not sig

AIC(herb2020_urb_usc_m5, herb2020_urb_usc_m5_ME) # very close
AIC(herb2020_urb_usc_m8, herb2020_urb_usc_m8_ME)
# main effects has lower AIC
```


#### Export ANOVA
```{r}
# anova_table_flx(herb2020_gr_dist_m5)
# anova_table_flx(herb2020_gr_dist_m8)
# anova_table_flx(herb2020_gr_usc_m5)
# anova_table_flx(herb2020_gr_usc_m8)
# 
# anova_table_flx(herb2020_urb_dist_m5)
# anova_table_flx(herb2020_urb_dist_m5_ME)
# anova_table_flx(herb2020_urb_dist_m8)
# anova_table_flx(herb2020_urb_dist_m8_ME)
# anova_table_flx(herb2020_urb_usc_m5)
# anova_table_flx(herb2020_urb_usc_m5_ME)
# anova_table_flx(herb2020_urb_usc_m8)
# anova_table_flx(herb2020_urb_usc_m8_ME)
# 
# AIC_compare.city_dist_transf_binomial(herb2020_urb_dist_m5,
#                       herb2020_urb_dist_m5_ME)
# 
# AIC_compare.city_dist_transf_quantitative(herb2020_urb_dist_m8,
#                       herb2020_urb_dist_m8_ME)
#     
# AIC_compare.urb_score_transf_binomial(herb2020_urb_usc_m5,
#                       herb2020_urb_usc_m5_ME)
# 
# AIC_compare.urb_score_transf_quantitative(herb2020_urb_usc_m8,
#                                           herb2020_urb_usc_m8_ME)
```


### Sept
#### glmer: diagnostics
```{r}
# Gradient / city_dist----------

# herb2020.S_gr_dist_m1 <- glmer(Herbivory.Sept_mean ~ (1|Block)  + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020,
#   family = binomial,
#   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# res <- simulateResiduals(herb2020.S_gr_dist_m1)
# plot(res)
# # major errors... try beta distribution
# 
# 
# herb2020.S_gr_dist_m2 <- glmmTMB(Herbivory.Sept_mean  ~ (1|Block) +  (1|Population/Family) + City_dist,
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# # Error in eval(family$initialize) : y values must be 0 < y < 1
# # recode: 0s as 0.00001 & 1 as 0.999999

herbivory_both_2020$Herbivory.Sept_mean_recode <- herbivory_both_2020$Herbivory.Sept_mean
herbivory_both_2020$Herbivory.Sept_mean_recode[herbivory_both_2020$Herbivory.Sept_mean == 1] <- 0.999999
herbivory_both_2020$Herbivory.Sept_mean_recode[herbivory_both_2020$Herbivory.Sept_mean == 0] <- 0.000001



# herb2020.S_gr_dist_m3 <- glmmTMB(Herbivory.Sept_mean_recode  ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020.S_gr_dist_m3)
# plot(res)
# # IT WORKS
# 
# hist(herbivory_both_2020$Herbivory.Sept_mean_recode, breaks = 30)
# summary(herb2020.S_gr_dist_m3)
# testDispersion(herb2020.S_gr_dist_m3)
# testZeroInflation(herb2020.S_gr_dist_m3)
# 
# # address overdispersion through an individual-level random effect
# 
# herb2020.S_gr_dist_m4 <- glmmTMB(Herbivory.Sept_mean_recode  ~ (1|Block) + (1|Population/Family) + City_dist + (1|ID),
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020.S_gr_dist_m4)
# plot(res)
# # better but still not optimal
# 
# 
# # try binomial and then quantitative?

# recode plants as having height or not
herbivory_both_2020$Herbivory.Sept_mean_binary <- herbivory_both_2020$Herbivory.Sept_mean
herbivory_both_2020$Herbivory.Sept_mean_binary[herbivory_both_2020$Herbivory.Sept_mean_binary > 0] <- 1

herb2020.S_gr_dist_m5 <- glmer((Herbivory.Sept_mean_binary) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = herbivory_both_2020,
  family = "binomial"(link="logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herb2020.S_gr_dist_m5)
plot(res)
# looks great! 
summary(herb2020.S_gr_dist_m5)

car::Anova(herb2020.S_gr_dist_m5) # marg sig


# herb2020.S_gr_dist_m6 <- lmer(Herbivory.Sept_mean ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_gr_dist_m6, type='diag') #very right-skewed... try cube root
# 
# herb2020.S_gr_dist_m7 <- lmer(Herbivory.Sept_mean^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_gr_dist_m7, type='diag') # still right-skewed... try log
# 
# herb2020.S_gr_dist_m8 <- lmer(log(Herbivory.Sept_mean) ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_gr_dist_m8, type='diag') # looks good but still singular... try removing block
# 
# herb2020.S_gr_dist_m9 <- lmer(log(Herbivory.Sept_mean) ~  (1|Population/Family) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... remove Fam instead
# 
# herb2020.S_gr_dist_m10 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population) + (1|Block) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... remove block
# 
# herb2020.S_gr_dist_m11 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 

# try glmmTMB
herb2020.S_gr_dist_m12 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population) + City_dist,
  data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
  family = gaussian) # it works! use this

# test1 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population/Family) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   family = gaussian) # singular
# 
# test1 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population) + (1|Block) + City_dist,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   family = gaussian) # singular




# Gradient / urb_score----------

# herb2020.S_gr_usc_m1 <-  glmer(Herbivory.Sept_mean ~ (1|Block)  + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020,
#   family = binomial,
#   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# res <- simulateResiduals(herb2020.S_gr_usc_m1)
# plot(res)
# # major errors... try beta distribution
# 
# 
# herb2020.S_gr_usc_m2 <- glmmTMB(Herbivory.Sept_mean  ~ (1|Block) +  (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# # Error in eval(family$initialize) : y values must be 0 < y < 1
# # recode: 0s as 0.00001 & 1 as 0.999999
# 
# 
# herb2020.S_gr_usc_m3 <- glmmTMB(Herbivory.Sept_mean_recode  ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020.S_gr_usc_m3)
# plot(res)
# # IT WORKS
# 
# hist(herbivory_both_2020$Herbivory.Sept_mean_recode, breaks = 30)
# summary(herb2020.S_gr_usc_m3)
# testDispersion(herb2020.S_gr_usc_m3)
# testZeroInflation(herb2020.S_gr_usc_m3)
# 
# # address overdispersion through an individual-level random effect
# herb2020.S_gr_usc_m4 <- glmmTMB(Herbivory.Sept_mean_recode  ~ (1|Block) + (1|Population/Family) + Urb_score + (1|ID),
#   data = herbivory_both_2020,
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020.S_gr_usc_m4)
# plot(res)
# # better but still not optimal
# 
# 
# # try binomial and then quantitative?



# recode plants as having height or not
herb2020.S_gr_usc_m5 <- glmer((Herbivory.Sept_mean_binary) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = herbivory_both_2020,
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herb2020.S_gr_usc_m5)
plot(res)
# looks great! 
summary(herb2020.S_gr_usc_m5)

car::Anova(herb2020.S_gr_usc_m5) # not sig


# herb2020.S_gr_usc_m6 <- lmer(Herbivory.Sept_mean ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_gr_usc_m6, type='diag') #very right-skewed... try cube root
# 
# herb2020.S_gr_usc_m7 <- lmer(Herbivory.Sept_mean^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_gr_usc_m7, type='diag') # still right-skewed... try log
# 
# herb2020.S_gr_usc_m8 <- lmer(log(Herbivory.Sept_mean) ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_gr_usc_m8, type='diag') # looks great! but still singular... try removing block
# 
# herb2020.S_gr_usc_m9 <- lmer(log(Herbivory.Sept_mean) ~  (1|Population/Family) + Urb_score,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... remove  Fam instead
# 
# herb2020.S_gr_usc_m10 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population) + (1|Block) + Urb_score,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... remove block
# 
# herb2020.S_gr_usc_m11 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population) + Urb_score,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 

# try glmmTMB
test1 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population) + Urb_score,
  data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
  family = gaussian) # it works!

test1 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population/Family) + Urb_score,
  data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
  family = gaussian) # it works!

herb2020.S_gr_usc_m12 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population) + (1|Block) + Urb_score,
  data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
  family = gaussian) # it works! use this



# Urb sites / city_dist----------

# herb2020.S_urb_dist_m1 <- glmer(Herbivory.Sept_mean ~ (1|Block)  + (1|Population/Family) + City_dist * Transect_ID,
#     data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#     family = binomial,
#   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# res <- simulateResiduals(herb2020.S_urb_dist_m1)
# plot(res)
# # major errors... try beta distribution
# 
# 
# herb2020.S_urb_dist_m2 <- glmmTMB(Herbivory.Sept_mean  ~ (1|Block) +  (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# # Error in eval(family$initialize) : y values must be 0 < y < 1
# # recode: 0s as 0.00001 & 1 as 0.999999
# 
# 
# herb2020.S_urb_dist_m3 <- glmmTMB(Herbivory.Sept_mean_recode  ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020.S_urb_dist_m3)
# plot(res)
# # IT WORKS
# 
# summary(herb2020.S_urb_dist_m3)
# testDispersion(herb2020.S_urb_dist_m3)
# testZeroInflation(herb2020.S_urb_dist_m3)
# 
# # address overdispersion through an individual-level random effect
# 
# herb2020.S_urb_dist_m4 <- glmmTMB(Herbivory.Sept_mean_recode  ~ (1|Block) + (1|Population/Family) + City_dist + (1|ID),
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020.S_urb_dist_m4)
# plot(res)
# # better but still not optimal
# 
# testDispersion(herb2020.S_urb_dist_m4) # is it underdispersed now?
# testZeroInflation(herb2020.S_urb_dist_m4)
# 
# # try binomial and then quantitative?


herb2020.S_urb_dist_m5 <- glmer((Herbivory.Sept_mean_binary) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herb2020.S_urb_dist_m5)
plot(res)
# looks great! but there's an outlier?
testOutliers(herb2020.S_urb_dist_m5) # no
summary(herb2020.S_urb_dist_m5)

car::Anova(herb2020.S_urb_dist_m5) # nothing sig

# main effects:
herb2020.S_urb_dist_m5_ME <- glmer((Herbivory.Sept_mean_binary) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))


# herb2020.S_urb_dist_m6 <- lmer(Herbivory.Sept_mean ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_urb_dist_m6, type='diag') #very right-skewed... try cube root
# 
# herb2020.S_urb_dist_m7 <- lmer(Herbivory.Sept_mean^(1/3) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_urb_dist_m7, type='diag') # still right-skewed... try log
# 
# herb2020.S_urb_dist_m8 <- lmer(log(Herbivory.Sept_mean) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_urb_dist_m8, type='diag') # looks good but still singular... try removing block
# 
# herb2020.S_urb_dist_m9 <- lmer(log(Herbivory.Sept_mean) ~  (1|Population/Family) + City_dist * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... try removing Fam instead
# 
# herb2020.S_urb_dist_m10 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population) + (1|Block) + City_dist* Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... remove block
# 
# herb2020.S_urb_dist_m11 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population) + City_dist* Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 

# try glmmTMB
# test1 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population) + City_dist* Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   family = gaussian) # it works!

herb2020.S_urb_dist_m12 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population/Family) + City_dist* Transect_ID,
  data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
  family = gaussian) # it works! use this

# test1 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population) + (1|Block) + City_dist* Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   family = gaussian) # singular


# main effects
herb2020.S_urb_dist_m12_ME <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population/Family) + City_dist + Transect_ID,
  data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
  family = gaussian)



# Urb sites / urb_score----------

# herb2020.S_urb_usc_m1 <- glmer(Herbivory.Sept_mean ~ (1|Block)  + (1|Population/Family) + Urb_score * Transect_ID,
#     data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#     family = binomial,
#   control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# res <- simulateResiduals(herb2020.S_urb_usc_m1)
# plot(res)
# # major errors... try beta distribution
# 
# 
# herb2020.S_urb_usc_m2 <- glmmTMB(Herbivory.Sept_mean  ~ (1|Block) +  (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# # Error in eval(family$initialize) : y values must be 0 < y < 1
# # recode: 0s as 0.00001 & 1 as 0.999999
# 
# 
# herb2020.S_urb_usc_m3 <- glmmTMB(Herbivory.Sept_mean_recode  ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020.S_urb_usc_m3)
# plot(res)
# # IT WORKS
# 
# summary(herb2020.S_urb_usc_m3)
# testDispersion(herb2020.S_urb_usc_m3)
# testZeroInflation(herb2020.S_urb_usc_m3)
# 
# # address overdispersion through an individual-level random effect
# 
# herb2020.S_urb_usc_m4 <- glmmTMB(Herbivory.Sept_mean_recode  ~ (1|Block) + (1|Population/Family) + Urb_score + (1|ID),
#   data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
#   family = beta_family(link="logit"))
# res <- simulateResiduals(herb2020.S_urb_usc_m4)
# plot(res)
# # better but still not optimal
# 
# testDispersion(herb2020.S_urb_usc_m4) # is it underdispersed now?
# testZeroInflation(herb2020.S_urb_usc_m4)
# 
# # try binomial and then quantitative?


herb2020.S_urb_usc_m5 <- glmer((Herbivory.Sept_mean_binary) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(herb2020.S_urb_usc_m5)
plot(res)
# looks great! 
summary(herb2020.S_urb_usc_m5)

car::Anova(herb2020.S_urb_usc_m5) # nothing sig


# main effects
herb2020.S_urb_usc_m5_ME <- glmer((Herbivory.Sept_mean_binary) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = herbivory_both_2020 %>% dplyr::filter(., Transect_ID != "Rural"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

# herb2020.S_urb_usc_m6 <- lmer(Herbivory.Sept_mean ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_urb_usc_m6, type='diag') #very right-skewed... try cube root
# 
# herb2020.S_urb_usc_m7 <- lmer(Herbivory.Sept_mean^(1/3) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_urb_usc_m7, type='diag') # still right-skewed... try log
# 
# herb2020.S_urb_usc_m8 <- lmer(log(Herbivory.Sept_mean) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(herb2020.S_urb_usc_m8, type='diag') # looks great  but still singular... try removing block
# 
# herb2020.S_urb_usc_m9 <- lmer(log(Herbivory.Sept_mean) ~  (1|Population/Family) + Urb_score * Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... try removing Fam instead
# 
# herb2020.S_urb_usc_m10 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population) + (1|Block) + Urb_score* Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... remove block
# 
# herb2020.S_urb_usc_m11 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population) + Urb_score* Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5))) # still singular... 

# try glmmTMB
# test1 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population) + Urb_score* Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   family = gaussian) # it works!

herb2020.S_urb_usc_m12 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population/Family) + Urb_score* Transect_ID,
  data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
  family = gaussian) # it works! use this
# 
# test1 <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population) + (1|Block) + Urb_score* Transect_ID,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   family = gaussian) # singular



# main effects
herb2020.S_urb_usc_m12_ME <- glmmTMB(log(Herbivory.Sept_mean) ~ (1|Population/Family) + Urb_score + Transect_ID,
  data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
  family = gaussian) 


```
#### Entire gradient: *Marg sig for city_dist (nothing for urb_score)
##### City_dist
```{r}
car::Anova(herb2020.S_gr_dist_m5) # binomial: marginally sig
car::Anova(herb2020.S_gr_dist_m12) # quantitative: not sig

# 
# # ANy variation within families or populations?
# m.1 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population/Family),
#             data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1),
#             REML = T,
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# ranova(m.1)
# # No for both
# 
# 
# sum.1 <- summary(m.1)
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# # even when I use glmmTMB model, I still get tiny variances- on par with the singular model.
# ## print(VarCorr(herb2020.S_gr_dist_m12),comp="Variance") 
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_HerbivorySept_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_HerbivorySept_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

##### Urb_score
```{r}
car::Anova(herb2020.S_gr_usc_m5) # binomial: not sig
car::Anova(herb2020.S_gr_usc_m12) # quantitative: not sig

```


#### Urban subtransects: *Nothing sig for either
##### City_dist
```{r}
car::Anova(herb2020.S_urb_dist_m5) # binomial: nothing sig
car::Anova(herb2020.S_urb_dist_m5_ME) # binomial: nothing sig
car::Anova(herb2020.S_urb_dist_m12) # quantitative: nothing sig
car::Anova(herb2020.S_urb_dist_m12_ME) # quantitative main effects: not sig

AIC(herb2020.S_urb_dist_m12, herb2020.S_urb_dist_m12_ME)
# main effects has lower AIC
# 
# 
# 
# # ANy variation among families or populations?
# m.1 <- lmer(log(Herbivory.Sept_mean) ~  (1|Population/Family) + City_dist ,
#   data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Transect_ID != "Rural"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)),
#   REML = T)
# 
# ranova(m.1)
# # no
# 
# m.2 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population/Family) + Transect_ID,
#               data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Urb_Rur == "Urban"),
# 
#             REML = F)
# car::Anova(m.2)
# # not among transects either
# 
# 
# m.3 <- lmer(log(Herbivory.Sept_mean) ~ (1|Population/Family) + Transect_ID,
#               data = herbivory_both_2020 %>% filter(Herbivory.Sept_mean_binary == 1 & Urb_Rur == "Urban"),
#             REML = T)
# car::Anova(m.3)
# # also not sig among transects
# 
# 
# sum.1 <- summary(m.1)
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_HerbivorySept_urban_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_HerbivorySept_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# write.table(car::Anova(m.2), here::here("./Figures_Tables/ranova_PVE/2020_HerbivorySept_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

##### Urb_score
```{r}
car::Anova(herb2020.S_urb_usc_m5) # binomial: ntohing sig
car::Anova(herb2020.S_urb_usc_m5_ME)# binomial: ntohing sig
car::Anova(herb2020.S_urb_usc_m12) # quantitative: nothing sig
car::Anova(herb2020.S_urb_usc_m12_ME) # quantitative main effects: not sig

AIC(herb2020.S_urb_usc_m12, herb2020.S_urb_usc_m12_ME)
# main effects has lower AIC
```



#### Export ANOVA
```{r}
# anova_table_flx(herb2020.S_gr_dist_m5)
# anova_table_flx(herb2020.S_gr_dist_m12)
# anova_table_flx(herb2020.S_gr_usc_m5)
# anova_table_flx(herb2020.S_gr_usc_m12)
# 
# anova_table_flx(herb2020.S_urb_dist_m5)
# anova_table_flx(herb2020.S_urb_dist_m5_ME)
# anova_table_flx(herb2020.S_urb_dist_m12)
# anova_table_flx(herb2020.S_urb_dist_m12_ME)
# anova_table_flx(herb2020.S_urb_usc_m5)
# anova_table_flx(herb2020.S_urb_usc_m5_ME)
# anova_table_flx(herb2020.S_urb_usc_m12)
# anova_table_flx(herb2020.S_urb_usc_m12_ME)
# 
# AIC_compare.city_dist_transf_binomial(herb2020.S_urb_dist_m5,
#                       herb2020.S_urb_dist_m5_ME)
# 
# AIC_compare.city_dist_transf_quantitative(herb2020.S_urb_dist_m12,
#                       herb2020.S_urb_dist_m12_ME)
#     
# AIC_compare.urb_score_transf_binomial(herb2020.S_urb_usc_m5,
#                       herb2020.S_urb_usc_m5_ME)
# 
# AIC_compare.urb_score_transf_quantitative(herb2020.S_urb_usc_m12,
#                                           herb2020.S_urb_usc_m12_ME)

```


## Relative Growth Rate
### lmer: diagnostics
```{r}
# GRADIENT / CITY_DIST-----

# rgr_gr_city_m1 <- lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(rgr_gr_city_m1, type = "diag") # is singular, looks normal except for left tail (but otherwise looks fine... I think it's kurtotic)... try taking out block
# 
# diagnostic(resid(rgr_gr_city_m1)) # very kurtotic
# 
# rgr_gr_city_m2 <- lmer(rel_growth_rate ~  (1|Population/Family) + City_dist,
#   data = heights_both_2020, REML = F) # still singular... take out Fam
# 
# rgr_gr_city_m3 <- lmer(rel_growth_rate ~ (1|Block) +(1|Population) + City_dist,
#   data = heights_both_2020, REML = F)#  singular. take out block
# 
# rgr_gr_city_m4 <- lmer(rel_growth_rate ~ (1|Population) + City_dist,
#   data = heights_both_2020, REML = F)#  singular...
# 
# # try glmmtmb
# test1 <- glmmTMB(rel_growth_rate ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020,
#   family = gaussian) # singular. take out block
# 
# test1 <- glmmTMB(rel_growth_rate ~ (1|Population/Family) + City_dist,
#   data = heights_both_2020,
#   family = gaussian) # singular. take out Family
# 
# rgr_gr_city_m5 <- glmmTMB(rel_growth_rate ~ (1|Population) + City_dist,
#   data = heights_both_2020,
#   family = gaussian) # singular...

# try binomial, then removing zeroes and going from there


# TAKING OUT PLANTS W/ZERO SCAR LENGTH & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

# recode plants as having height or not
heights_both_2020$rel_growth_rate_binary <- heights_both_2020$rel_growth_rate
heights_both_2020$rel_growth_rate_binary[heights_both_2020$rel_growth_rate > 0] <- 1
heights_both_2020$rel_growth_rate_binary[heights_both_2020$rel_growth_rate <= 0] <- 0


rgr_gr_city_m6 <- glmer((rel_growth_rate_binary) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_both_2020,
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(rgr_gr_city_m6)
plot(res)
# looks great! 
summary(rgr_gr_city_m6)

car::Anova(rgr_gr_city_m6) # not sig


# rgr_gr_city_m7 <- lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(rgr_gr_city_m7, type='diag') #very right-skewed but otherwise aligns well with normal curve... try sqrt

rgr_gr_city_m8 <- lmer(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(rgr_gr_city_m8, type='diag') # looks great!






# GRADIENT / URB SCORE-----

# rgr_gr_usc_m1 <- lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(rgr_gr_usc_m1, type = "diag") # is singular, looks normal except for left tail (but otherwise looks fine... I think it's kurtotic)... take out block
# 
# rgr_gr_usc_m2 <- lmer(rel_growth_rate ~  (1|Population/Family) + Urb_score,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(rgr_gr_usc_m2, type = "diag") # still singular... take out Pop/Fam
# 
# rgr_gr_usc_m3 <- lmer(rel_growth_rate ~ (1|Block) + Urb_score,
#   data = heights_both_2020, REML = F)
# sjPlot::plot_model(rgr_gr_usc_m3, type = "diag") # not singular. looks normal except for left tail (but otherwise looks fine... I think it's kurtotic)..
# 
# diagnostic(resid(rgr_gr_usc_m3)) # high kurtosis


# try binomial, then removing zeroes and going from there

# TAKING OUT PLANTS W/negative RGR & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

rgr_gr_usc_m6 <- glmer((rel_growth_rate_binary) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_both_2020,
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(rgr_gr_usc_m6)
plot(res)
# looks great! 
summary(rgr_gr_usc_m6)

car::Anova(rgr_gr_usc_m6) # not sig


# rgr_gr_usc_m7 <- lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(rgr_gr_usc_m7, type='diag') #very right-skewed but otherwise aligns well with normal curve... try sqrt

rgr_gr_usc_m8 <- lmer(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1),
  control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
sjPlot::plot_model(rgr_gr_usc_m8, type='diag') # looks great!




# URB SUBTRANSECTS / CITY_DIST-----

# rgr_urbsubs_city_m1 <- lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(rgr_urbsubs_city_m1, type = "diag") # is singular, looks normal except for left tail (but otherwise looks fine... I think it's kurtotic)... take out block
# 
# rgr_urbsubs_city_m2 <- lmer(rel_growth_rate ~  (1|Population/Family) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F) # is singular,  take out Pop/Fam
# 
# rgr_urbsubs_city_m3 <- lmer(rel_growth_rate ~ (1|Block) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F)  # is singular... take out block and pop/fam
# 
# rgr_urbsubs_city_m4 <- lm(rel_growth_rate ~  City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"))
# sjPlot::plot_model(rgr_urbsubs_city_m4, type = "diag")
# 
# diagnostic(resid(rgr_urbsubs_city_m4)) # high kurtosis


# try binomial, then removing zeroes and going from there

# TAKING OUT PLANTS W/negative RGR & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

rgr_urbsubs_city_m5 <- glmer((rel_growth_rate_binary) ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban" ),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(rgr_urbsubs_city_m5)
plot(res)
# looks great! 
summary(rgr_urbsubs_city_m5)

car::Anova(rgr_urbsubs_city_m5) # city_dist marg sig

# main effects:
rgr_urbsubs_city_m5_ME <- glmer((rel_growth_rate_binary) ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban" ),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
car::Anova(rgr_urbsubs_city_m5_ME) # city_dist marg sig

# 
# rgr_urbsubs_city_m6 <- lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) +  City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(rgr_urbsubs_city_m6, type='diag') # singular... but first align it w/normal curve. do sqrt 
# 
# rgr_urbsubs_city_m7 <- lmer(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population/Family) +  City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(rgr_urbsubs_city_m7, type='diag') # meets expectations but still singular... try glmmTMB

rgr_urbsubs_city_m8 <- glmmTMB(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population/Family) +  City_dist * Transect_ID,
  data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
  family = gaussian) # it works! use this


# main effects
# rgr_urbsubs_city_m8_ME <- glmmTMB(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population/Family) +  City_dist + Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
#   family = gaussian) # singular... take out block

rgr_urbsubs_city_m8_ME.1 <- glmmTMB(sqrt(rel_growth_rate) ~ (1|Population/Family) +  City_dist + Transect_ID,
  data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
  family = gaussian) # it works. put back block and take out fam and see how it compares to full model
# 
# rgr_urbsubs_city_m8_ME.2 <- glmmTMB(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population) +  City_dist + Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
#   family = gaussian)
# 
# car::Anova(rgr_urbsubs_city_m8)
# car::Anova(rgr_urbsubs_city_m8_ME.1) # identical to model below!
# car::Anova(rgr_urbsubs_city_m8_ME.2)



# URB SUBTRANSECTS / URB SCORE-----

# rgr_urbsubs_usc_m1 <- lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(rgr_urbsubs_usc_m1, type = "diag") # is singular, looks normal except for left tail (but otherwise looks fine... I think it's kurtotic)... take out block
# 
# rgr_urbsubs_usc_m2 <- lmer(rel_growth_rate ~  (1|Population/Family) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F) # is singular,  take out Pop/Fam
# 
# rgr_urbsubs_usc_m3 <- lmer(rel_growth_rate ~ (1|Block) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   REML = F)  # is singular... take out block and pop/fam
# 
# rgr_urbsubs_usc_m4 <- lm(rel_growth_rate ~  Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"))
# sjPlot::plot_model(rgr_urbsubs_usc_m4, type = "diag") 
# 
# diagnostic(resid(rgr_urbsubs_usc_m4)) # high kurtosis


# try binomial, then removing zeroes and going from there

# TAKING OUT PLANTS W/negative RGR & FITTING A BINOMIAL MODEL
## THEN I'LL USE >0 DATA AND LOOK AT QUANTITATIVE MEASUREMENTS

rgr_urbsubs_usc_m5 <- glmer((rel_growth_rate_binary) ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban" ),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

res <- simulateResiduals(rgr_urbsubs_usc_m5)
plot(res)
# looks great! 
summary(rgr_urbsubs_usc_m5)

car::Anova(rgr_urbsubs_usc_m5) # nothing sig

# main effects:
rgr_urbsubs_usc_m5_ME <- glmer((rel_growth_rate_binary) ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = "binomial"(link = "logit"),
  nAGQ = 0,
  control=glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))


# rgr_urbsubs_usc_m6 <- lmer(rel_growth_rate ~ (1|Block) + (1|Population/Family) +  Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(rgr_urbsubs_usc_m6, type='diag') #very right-skewed but otherwise aligns well with normal curve... try sqrt (also singular)
# 
# rgr_urbsubs_usc_m7 <- lmer(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population/Family) +  Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 & Urb_Rur == "Urban"),
#   control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# sjPlot::plot_model(rgr_urbsubs_usc_m7, type='diag') # looks great! now address singularity... try glmmTMB

rgr_urbsubs_usc_m8 <- glmmTMB(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population/Family) +  Urb_score * Transect_ID,
  data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 & Urb_Rur == "Urban"),
  family = gaussian) # not singular! Use this


# main effects
# rgr_urbsubs_usc_m8_ME <- glmmTMB(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population/Family) +  Urb_score + Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 & Urb_Rur == "Urban"),
#   family = gaussian) # singular... remove block

rgr_urbsubs_usc_m8_ME.1 <- glmmTMB(sqrt(rel_growth_rate) ~ (1|Population/Family) +  Urb_score + Transect_ID,
  data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
  family = gaussian) # it works. put back block and take out fam and see how it compares to full model

# rgr_urbsubs_usc_m8_ME.2 <- glmmTMB(sqrt(rel_growth_rate) ~ (1|Block) + (1|Population) +  Urb_score + Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
#   family = gaussian) # it works
# 
# car::Anova(rgr_urbsubs_usc_m8_ME)
# car::Anova(rgr_urbsubs_usc_m8_ME.1) # identical to model below!
# car::Anova(rgr_urbsubs_usc_m8_ME.2)



```

### Entire gradient: *Not sig for either
#### City_dist
```{r}
car::Anova(rgr_gr_city_m6) # not sig
car::Anova(rgr_gr_city_m8) # not sig
# 
# 
# # ANy variation within families or populations?
# m.1 <- lmer(sqrt(rel_growth_rate) ~ (1|Population/Family),
#             data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1),
#             control=lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)),
#             REML = T)
# 
# 
# ranova(m.1)
# # nope
# sum.1 <- summary(m.1)
# 
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_growthrate_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_growthrate_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

#### Urb_score
```{r}
car::Anova(rgr_gr_usc_m6) #not sig
car::Anova(rgr_gr_usc_m8) #not sig

```


### Urban subtransects: *Marg sig for city_dist (quant) & urb_score (quant)
#### City_dist
```{r}
car::Anova(rgr_urbsubs_city_m5) # binomial: nothing sig
car::Anova(rgr_urbsubs_city_m5_ME) # binomial: nothing sig
car::Anova(rgr_urbsubs_city_m8) # quantitative: transect sig & city_dist marg sig
car::Anova(rgr_urbsubs_city_m8_ME.1) # quantitative: transect marg sig & city_dist marg sig

AIC(rgr_urbsubs_city_m5, rgr_urbsubs_city_m5_ME) # ME model lower AIC
AIC(rgr_urbsubs_city_m8, rgr_urbsubs_city_m8_ME.1) # ME model lower AIC
summary(rgr_urbsubs_city_m8_ME.1)



# # ANy variation among families or populations?
# m.1 <- lmer(sqrt(rel_growth_rate) ~  (1|Population/Family) + City_dist ,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 & Urb_Rur == "Urban"),
#   REML = T)
# 
# ranova(m.1)
# # no
# 
# m.2 <- lmer(sqrt(rel_growth_rate) ~ (1|Population/Family) + Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 & Urb_Rur == "Urban"),
#             REML = F)
# car::Anova(m.2)
# # not among transects either
# 
# 
# m.3 <- lmer(sqrt(rel_growth_rate) ~ (1|Population/Family) + Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
#   REML = T)
# car::Anova(m.3)
# # also not sig among transects
# 
# 
# sum.1 <- summary(m.1)
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_growthrate_urban_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_growthrate_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# write.table(car::Anova(m.2), here::here("./Figures_Tables/ranova_PVE/2020_growthrate_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

#### Urb_score
```{r}
car::Anova(rgr_urbsubs_usc_m5) # binomial: nothing sig
car::Anova(rgr_urbsubs_usc_m5_ME) # binomial: nothing sig
car::Anova(rgr_urbsubs_usc_m8) # quantitative: interaxn marg sig
car::Anova(rgr_urbsubs_usc_m8_ME.1) # quantitative: nothing sig

AIC(rgr_urbsubs_usc_m8, rgr_urbsubs_usc_m8_ME.1) # ME model lower AIC but not significant difference
summary(rgr_urbsubs_usc_m8)
```


### Export ANOVA
```{r}
# anova_table_flx(rgr_gr_city_m6)
# anova_table_flx(rgr_gr_city_m8)
# anova_table_flx(rgr_gr_usc_m6)
# anova_table_flx(rgr_gr_usc_m8)
# 
# anova_table_flx(rgr_urbsubs_city_m5)
# anova_table_flx(rgr_urbsubs_city_m5_ME)
# anova_table_flx(rgr_urbsubs_city_m8)
# anova_table_flx(rgr_urbsubs_city_m8_ME.1)
# anova_table_flx(rgr_urbsubs_usc_m5)
# anova_table_flx(rgr_urbsubs_usc_m5_ME)
# anova_table_flx(rgr_urbsubs_usc_m8)
# anova_table_flx(rgr_urbsubs_usc_m8_ME.1)
# 
# AIC_compare.city_dist_transf_binomial(rgr_urbsubs_city_m5 ,
#                        rgr_urbsubs_city_m5_ME)
#     
# AIC_compare.city_dist_transf_quantitative( rgr_urbsubs_city_m8,
#                        rgr_urbsubs_city_m8_ME.1) 
# 
# AIC_compare.urb_score_transf_binomial(rgr_urbsubs_usc_m5 ,
#                        rgr_urbsubs_usc_m5_ME)
#     
# AIC_compare.urb_score_transf_quantitative( rgr_urbsubs_usc_m8,
#                        rgr_urbsubs_usc_m8_ME.1) 

```


## Number of Ramets
### June ramets
#### glmer: diagnostics
```{r}
# GRADIENT / CITY_DIST-----

# rametsJ_gr_city_m1 <- glmer(Ramets_June ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsJ_gr_city_m1)
# plot(res)
# # convergence warning and dispersion significant...
# testOverdispersion(rametsJ_gr_city_m1) # add ID as random effect
# address overdispersion through an individual-level random effect
heights_both_2020$ID <- seq.int(nrow(heights_both_2020))

rametsJ_gr_city_m2 <- glmer(Ramets_June ~ (1|Block) + (1|Population/Family) + City_dist + (1|ID),
  data = heights_both_2020,
  family = poisson,
  control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))
res <- simulateResiduals(rametsJ_gr_city_m2)
plot(res)
# looks good!



# GRADIENT / URB SCORE-----

# rametsJ_gr_usc_m1 <- glmer(Ramets_June ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsJ_gr_usc_m1)
# plot(res)
# # dispersion significant...
# testOverdispersion(rametsJ_gr_usc_m1) # add ID as random effect


rametsJ_gr_usc_m2 <- glmer(Ramets_June ~ (1|Block) + (1|Population/Family) + Urb_score + (1|ID),
  data = heights_both_2020,
  family = poisson,
  control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))
res <- simulateResiduals(rametsJ_gr_usc_m2)
plot(res)
# looks good! says there's an outlier but I think it's fine



# URB SUBTRANSECTS / CITY_DIST-----

rametsJ_urbsubs_city_m1 <- glmer(Ramets_June ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = poisson,
  control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))
res <- simulateResiduals(rametsJ_urbsubs_city_m1)
plot(res)
# says there's an outlier but I think it's fine


# main effects
rametsJ_urbsubs_city_m1_ME <- glmer(Ramets_June ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = poisson,
  control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))



# URB SUBTRANSECTS / URB SCORE-----

# rametsJ_urbsubs_urbsubs_m1 <- glmer(Ramets_June ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsJ_urbsubs_urbsubs_m1)
# plot(res) # looks good but is singular... take out block
# 
# rametsJ_urbsubs_urbsubs_m2 <- glmer(Ramets_June ~ (1|Population/Family) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # still singular... take out Fam
# 
# rametsJ_urbsubs_urbsubs_m3 <- glmer(Ramets_June ~  (1|Population) + (1|Block) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsJ_urbsubs_urbsubs_m3)
# plot(res) # # dispersion significant...
# testOverdispersion(rametsJ_urbsubs_urbsubs_m3) # add ID as random effect
# 
# rametsJ_urbsubs_urbsubs_m4 <- glmer(Ramets_June ~ (1|Block) +(1|Population/Family) + (1|ID) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsJ_urbsubs_urbsubs_m4)
# plot(res)# looks good but still singular... take out block
# 
# rametsJ_urbsubs_urbsubs_m5 <- glmer(Ramets_June ~ (1|Population/Family) + (1|ID) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... take out Family
# 
# rametsJ_urbsubs_urbsubs_m6 <- glmer(Ramets_June ~ (1|Population) + (1|ID) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular...

# try glmmTMB
rametsJ_urbsubs_urbsubs_m7 <- glmmTMB(Ramets_June ~ (1|Block) +(1|Population/Family) + (1|ID) + Urb_score * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = poisson) # it works! use this



# main effects
rametsJ_urbsubs_urbsubs_m7_ME <- glmmTMB(Ramets_June ~ (1|Block) +(1|Population/Family) + (1|ID) + Urb_score + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = poisson) # it works! use this


```

#### Entire gradient: *Nothing sig for either
##### City_dist
```{r}
car::Anova(rametsJ_gr_city_m2) # not sig

# 
# # ANy variation within families or populations?
# 
# ##### TACTIC 1: try bootstrapping #####
# # NOT PERFECT b/c can't nest family within pop but trying a few ways to get at the correct answer.
# # https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html#test-of-random-parameter
# library(pbkrtest) # Parametric Bootstrap, Kenward-Roger and Satterthwaite Based
Methods for Test in Mixed Models
# library(pbnm)
# 
# 
# # JUST POPULATION
# gmm <-  glmer(Ramets_June ~ City_dist + (1|Population), # can't leave in Family... doesn't work
#   family = poisson,
#               data = heights_both_2020,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# 
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1 <-  glmer(Ramets_June ~ City_dist + (1|Population/Family), 
#   family = poisson,
#               data = heights_both_2020,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# 
# # POP:FAMILY
# gmm2 <-  glmer(Ramets_June ~ City_dist + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#   family = poisson,
#               data = heights_both_2020,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# 
# # UNIQUE FAMILIES
# heights_both_2020$Family_unique <- paste(heights_both_2020$Population, heights_both_2020$Family)
# gmm3 <-  glmer(Ramets_June ~ City_dist + (1|Family_unique),
#   family = poisson,
#               data = heights_both_2020,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4 <-  glmer(Ramets_June ~ City_dist + (1|Population:Family) + (1|Population),
#   family = poisson,
#               data = heights_both_2020,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# 
# 
# # REDUCED MODEL
# gmmDG1 <- glm(Ramets_June ~ City_dist,
#   family = poisson,
#               data = heights_both_2020)
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1 <- pbnm(gmm,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) %T>%
#   summary() %>%
#   print()   # p = 0.396 ... no var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4 <- pbnm(gmm4,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop <- summary(pbgmmDg4) %T>%
#   print() # p =  0.159... no var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2 <- pbnm(gmm2,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam <- summary(pbgmmDg2) %T>%
#   print() # p = 0.441 ... little var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3 <- pbnm(gmm3,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) %T>%
#   summary() %>%
#   print() # p = 0.441 ... little var among families, period
# 
# 
# 
# ##### use anova to test significance of terms (this isn't what we want, though): #####
# ## test Pop/Fam
# anova(gmm1, gmmDG1) # p = 0.0001594 ***
# 
# ## test Pop/Fam but expanded
# anova(gmm4, gmmDG1) # p = 0.0001594 ***      # SAME AS ABOVE
# 
# ## test Pop
# anova(gmm, gmmDG1) # p = 0.024*
# 
# ## test Fam
# anova(gmm3, gmmDG1) # p =  3.155e-05 ***
# 
# ## test pop:fam
# anova(gmm2, gmmDG1) # p =  3.155e-05 ***    # SAME AS ABOVE
# 
# 
# 
# #--------- FINAL RESULTS: ----------#
# # Bootstrapping:
# # - Pop:    NOT SIGNIFICANT
# # - Family: NOT SIGNIFICANT
# # anova:
# # - Pop:    SIGNIFICANT
# # - Family: SIGNIFICANT
# 
# # --- DO THE 2 METHODS MATCH? ---#
# #       [ ]    NO
# #             
# 
# 
# 
# ##### old code #####
# 
# sum.1 <- summary(gmm4)
# 
# variances1 <- print(VarCorr(gmm4),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# # export percent variance explained
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Ramets_June_glmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# 
# # export ranova
# sink(here::here("./Figures_Tables/ranova_PVE/2020_Ramets_June_glmer_ranova.csv"))
# print("POPULATION", sep="\n\n")
# print(ranova_pop, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam, sep="\n\n")
#   cat("\n")
# if (ranova_pop[1] <= 0.05){
#   print ('There is variance among populations')}
# if (ranova_pop[1] > 0.05){
#   print ("There is not much variance among populations")}
# if (ranova_fam[1] <= 0.05){
#   print ("There is variance among families")}
# if (ranova_fam[1] > 0.05){
#   print ("There is not much variance among families")}
# sink()


```

##### Urb_score
```{r}
car::Anova(rametsJ_gr_usc_m2) # not sig

```


#### Urban subtransects: *Nothing sig for city_dist; urb_score sig and transect marg sig
##### City_dist
```{r}
car::Anova(rametsJ_urbsubs_city_m1) # not sig
car::Anova(rametsJ_urbsubs_city_m1_ME) # not sig

AIC(rametsJ_urbsubs_city_m1, rametsJ_urbsubs_city_m1_ME) # ME has lower aic but <2

# 
# # ANy variation within families or populations?
# 
# ##### TACTIC 1: try bootstrapping #####
# # NOT PERFECT b/c can't nest family within pop but trying a few ways to get at the correct answer.
# # https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html#test-of-random-parameter
# 
# 
# ### MODEL 1: CITY_DIST ###
# ##########################
# 
# # JUST POPULATION
# gmm <-  glmer(Ramets_June ~ City_dist + (1|Population), # can't leave in Family... doesn't work
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1 <-  glmer(Ramets_June ~ City_dist + (1|Population/Family), 
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # POP:FAMILY
# gmm2 <-  glmer(Ramets_June ~ City_dist + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#   family = poisson,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # UNIQUE FAMILIES
# heights_both_2020$Family_unique <- paste(heights_both_2020$Population, heights_both_2020$Family)
# gmm3 <-  glmer(Ramets_June ~ City_dist + (1|Family_unique),
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4 <-  glmer(Ramets_June ~ City_dist + (1|Population:Family) + (1|Population),
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# 
# # REDUCED MODEL 1
# gmmDG1 <- glm(Ramets_June ~ City_dist,
#                 data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson)
# 
# 
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1 <- pbnm(gmm,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg1) # p = 0.375...  little var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4 <- pbnm(gmm4,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop <- summary(pbgmmDg4) %T>%
#   print() # p = 0.098... (some?) var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2 <- pbnm(gmm2,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam <- summary(pbgmmDg2) %T>%
#   print() # p = 0.441... little var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3 <- pbnm(gmm3,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg3) # p = 0.44... little var among families, period
# 
# 
# 
# ### MODEL 2: TRANSECT_ID ###
# ##########################
# 
# # JUST POPULATION
# gmm.2 <-  glmer(Ramets_June ~ Transect_ID + (1|Population), # can't leave in Family... doesn't work
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1.2 <-  glmer(Ramets_June ~ Transect_ID + (1|Population/Family), 
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # POP:FAMILY
# gmm2.2 <-  glmer(Ramets_June ~ Transect_ID + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # UNIQUE FAMILIES
# gmm3.2 <-  glmer(Ramets_June ~ Transect_ID + (1|Family_unique),
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4.2 <-  glmer(Ramets_June ~ Transect_ID + (1|Population:Family) + (1|Population),
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"))
# 
# # REDUCED MODEL 2
# gmmDG1.2 <- glm(Ramets_June ~ Transect_ID,
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"))
# 
# 
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1.2 <- pbnm(gmm.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg1.2) # p = 0.023...  var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4.2 <- pbnm(gmm4.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop.2 <- summary(pbgmmDg4.2) %T>%
#   print() # p = 0.026... var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2.2 <- pbnm(gmm2.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam.2 <- summary(pbgmmDg2.2) %T>%
#   print() # p = 0.001...  var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3.2 <- pbnm(gmm3.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg3.2) # p = 0.001.. var among families
# 
# 
# 
# 
# sum.1 <- summary(gmm4)
# 
# variances1 <- print(VarCorr(gmm4),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# # export percent variance explained
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_RametsJune_urban_glmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# 
# # export ranova
# sink(here::here("./Figures_Tables/ranova_PVE/2020_RametsJune_urban_glmer_ranova.csv"))
# print("POPULATION", sep="\n\n")
# print(ranova_pop, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam, sep="\n\n")
#   cat("\n")
# if (ranova_pop[1] <= 0.05){
#   print ('There is variance among populations')}
# if (ranova_pop[1] > 0.05){
#   print ("There is not much variance among populations")}
# if (ranova_fam[1] <= 0.05){
#   print ("There is variance among families")}
# if (ranova_fam[1] > 0.05){
#   print ("There is not much variance among families")}
#   
# cat("\n")
# cat("\n")
# 
# print("POPULATION", sep="\n\n")
# print(ranova_pop.2, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam.2, sep="\n\n")
#   cat("\n")
# if (ranova_pop.2[1] <= 0.05){
#   print ('Variance among populations differs by urban subtransect')}
# if (ranova_pop.2[1] > 0.05){
#   print ("Variance among populations does not differ by urban subtransect")}
# if (ranova_fam.2[1] <= 0.05){
#   print ("Variance among families differs by urban subtransect")}
# if (ranova_fam.2[1] > 0.05){
#   print ("Variance among families does not differ by urban subtransect")}
# sink()

```

##### Urb_score
```{r}
car::Anova(rametsJ_urbsubs_urbsubs_m7)    # urb_score sig and transect marg sig
car::Anova(rametsJ_urbsubs_urbsubs_m7_ME) # urb_score sig and transect marg sig

AIC(rametsJ_urbsubs_urbsubs_m7, rametsJ_urbsubs_urbsubs_m7_ME) # ME has slightly lower aic but <2

```


#### Export ANOVA
```{r}
# anova_table_flx(rametsJ_gr_city_m2)
# anova_table_flx(rametsJ_gr_usc_m2)
# anova_table_flx(rametsJ_urbsubs_city_m1)
# anova_table_flx(rametsJ_urbsubs_city_m1_ME)
# anova_table_flx(rametsJ_urbsubs_urbsubs_m7)
# anova_table_flx(rametsJ_urbsubs_urbsubs_m7_ME)
# 
# AIC_compare.city_dist(rametsJ_urbsubs_city_m1,
#                       rametsJ_urbsubs_city_m1_ME)
#     
# AIC_compare.urb_score(rametsJ_urbsubs_urbsubs_m7,
#                       rametsJ_urbsubs_urbsubs_m7_ME) 

```
### Sept ramets
#### glmer: diagnostics
```{r}
# GRADIENT / CITY_DIST-----

# rametsS_gr_city_m1 <- glmer(Ramets_Sept ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsS_gr_city_m1)
# plot(res) # looks good but singular... take out block
# 
# rametsS_gr_city_m2 <- glmer(Ramets_Sept ~  (1|Population/Family) + City_dist,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... take out fam
# 
# rametsS_gr_city_m3 <- glmer(Ramets_Sept ~ (1|Block) +  (1|Population) + City_dist,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... take out block
# 
# rametsS_gr_city_m4 <- glmer(Ramets_Sept ~ (1|Population) + City_dist,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... 

# try glmmTMB
# test1 <- glmmTMB(Ramets_Sept ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = heights_both_2020,
#   family = poisson) # singular... take out block

rametsS_gr_city_m5 <- glmmTMB(Ramets_Sept ~  (1|Population/Family) + City_dist,
  data = heights_both_2020,
  family = poisson) # it works! use this

# test1 <- glmmTMB(Ramets_Sept ~ (1|Block) + (1|Population) + City_dist,
#   data = heights_both_2020,
#   family = poisson) # it works!
# 
# car::Anova(rametsS_gr_city_m5) # both are identical
# car::Anova(test1)



# GRADIENT / URB SCORE-----

# rametsS_gr_usc_m1 <- glmer(Ramets_Sept ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsS_gr_usc_m1)
# plot(res)
# # looks good! though singular... take out block
# 
# rametsS_gr_usc_m2 <- glmer(Ramets_Sept ~  (1|Population/Family) + Urb_score,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... take out fam
# 
# rametsS_gr_usc_m3 <- glmer(Ramets_Sept ~ (1|Block) + (1|Population) +  Urb_score,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... take out block
# 
# rametsS_gr_usc_m4 <- glmer(Ramets_Sept ~  (1|Population) +  Urb_score,
#   data = heights_both_2020,
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular...

# try glmmTMB
rametsS_gr_usc_m5 <- glmmTMB(Ramets_Sept ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = heights_both_2020,
  family = poisson) # it works! use this



# URB SUBTRANSECTS / CITY_DIST-----

# rametsS_urbsubs_city_m1 <- glmer(Ramets_Sept ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsS_urbsubs_city_m1)
# plot(res) # looks good though singular... take out block
# 
# rametsS_urbsubs_city_m2 <- glmer(Ramets_Sept ~  (1|Population/Family) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... take out fam
# 
# rametsS_urbsubs_city_m3 <- glmer(Ramets_Sept ~ (1|Block) + (1|Population) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) #  singular... take out block
# 
# rametsS_urbsubs_city_m4 <- glm(Ramets_Sept ~ (1|Population) + City_dist * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson) # this works!

# try glmmTMB
rametsS_urbsubs_city_m5 <- glmmTMB(Ramets_Sept ~ (1|Block) + (1|Population/Family) +  City_dist * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = poisson) # it works! use this


# main effects
rametsS_urbsubs_city_m5_ME <- glmmTMB(Ramets_Sept ~ (1|Block) + (1|Population/Family) +  City_dist + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = poisson) # it works! use this



# URB SUBTRANSECTS / URB SCORE-----

# rametsS_urbsubs_urbsubs_m1 <- glmer(Ramets_Sept ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# res <- simulateResiduals(rametsS_urbsubs_urbsubs_m1)
# plot(res)
# # looks good but singular... take out block
# 
# rametsS_urbsubs_usc_m2 <- glmer(Ramets_Sept ~  (1|Population/Family) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... take out fam
# 
# rametsS_urbsubs_usc_m3 <- glmer(Ramets_Sept ~ (1|Block) + (1|Population) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular... take out block
# 
# rametsS_urbsubs_usc_m4 <- glmer(Ramets_Sept ~  (1|Population) + Urb_score * Transect_ID,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5))) # singular...

# try glmmTMB
rametsS_urbsubs_usc_m5 <- glmmTMB(Ramets_Sept ~ (1|Block) + (1|Population/Family) +  Urb_score * Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = poisson) # it works! use this




# main effects
rametsS_urbsubs_usc_m5_ME <- glmmTMB(Ramets_Sept ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
  family = poisson) # it works! use this

```

#### Entire gradient: *Sig for city_dist, not for urb_score
##### City_dist
```{r}
car::Anova(rametsS_gr_city_m5) # sig


# 
# # ANy variation within families or populations?
# 
# ##### TACTIC 1: try bootstrapping #####
# # NOT PERFECT b/c can't nest family within pop but trying a few ways to get at the correct answer.
# # https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html#test-of-random-parameter
# library(pbkrtest) # Parametric Bootstrap, Kenward-Roger and Satterthwaite Based
Methods for Test in Mixed Models
# library(pbnm)
# 
# # can't handle glmmTMB so switching back to glmer
# 
# # JUST POPULATION
# gmm <-  glmer(Ramets_Sept ~ City_dist + (1|Population), # can't leave in Family... doesn't work
#   family = poisson,
#               data = heights_both_2020)
# 
# 
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1 <-  glmer(Ramets_Sept ~ City_dist + (1|Population/Family), 
#   family = poisson,
#               data = heights_both_2020,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# 
# # POP:FAMILY
# gmm2 <-  glmer(Ramets_Sept ~ City_dist + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#   family = poisson,
#               data = heights_both_2020,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# 
# # UNIQUE FAMILIES
# # heights_both_2020$Family_unique <- paste(heights_both_2020$Population, heights_both_2020$Family)
# gmm3 <-  glmer(Ramets_Sept ~ City_dist + (1|Family_unique),
#   family = poisson,
#               data = heights_both_2020,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4 <-  glmer(Ramets_Sept ~ City_dist + (1|Population:Family) + (1|Population),
#   family = poisson,
#               data = heights_both_2020)
# 
# 
# 
# # REDUCED MODEL
# gmmDG1 <- glm(Ramets_Sept ~ City_dist,
#   family = poisson,
#               data = heights_both_2020)
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1 <- pbnm(gmm,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# pbgmmDg1  %>%
#   summary() %>%
#   print()   # p = 1  ... no var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4 <- pbnm(gmm4,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop <- summary(pbgmmDg4) %T>%
#   print() # p =  0.738  ... no var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2 <- pbnm(gmm2,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam <- summary(pbgmmDg2) %T>%
#   print() # p = 1  ... little var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3 <- pbnm(gmm3,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835)
# pbgmmDg3 %>%
#   summary() %>%
#   print() # p = 1  ... little var among families, period
# 
# 
# 
# ##### use anova to test significance of terms (this isn't what we want, though): #####
# ## test Pop/Fam
# anova(gmm1, gmmDG1) # p =  1
# 
# ## test Pop/Fam but expanded
# anova(gmm4, gmmDG1) # p =   1    # SAME AS ABOVE
# 
# ## test Pop
# anova(gmm, gmmDG1) # p =  1
# 
# ## test Fam
# anova(gmm3, gmmDG1) # p =   1
# 
# ## test pop:fam
# anova(gmm2, gmmDG1) # p =   1    # SAME AS ABOVE
# 
# 
# 
# #--------- FINAL RESULTS: ----------#
# # Bootstrapping:
# # - Pop:    NOT SIGNIFICANT
# # - Family: NOT SIGNIFICANT
# # anova:
# # - Pop:    NOT SIGNIFICANT
# # - Family: NOT SIGNIFICANT
# 
# # --- DO THE 2 METHODS MATCH? ---#
# #       [X]    YES
# #             
# 
# 
# 
# ##### old code #####
# 
# sum.1 <- summary(gmm4)
# 
# variances1 <- print(VarCorr(gmm4),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# # export percent variance explained
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Ramets_Sept_glmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# 
# # export ranova
# sink(here::here("./Figures_Tables/ranova_PVE/2020_Ramets_Sept_glmer_ranova.csv"))
# print("POPULATION", sep="\n\n")
# print(ranova_pop, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam, sep="\n\n")
#   cat("\n")
# # if (ranova_pop[1] <= 0.05){
# #   print ('There is variance among populations')}
# # if (ranova_pop[1] > 0.05){
#   print ("There is not much variance among populations") #}
# # if (ranova_fam[1] <= 0.05){
# #   print ("There is variance among families")}
# # if (ranova_fam[1] > 0.05){
#   print ("There is not much variance among families") #}
# sink()

```

##### Urb_score
```{r}
car::Anova(rametsS_gr_usc_m5) # not sig

```

#### Urban subtransects: *Sig for city_dist, not for urb_score
##### City_dist
```{r}
car::Anova(rametsS_urbsubs_city_m5) # city_dist sig
car::Anova(rametsS_urbsubs_city_m5_ME) # city_dist sig

AIC(rametsS_urbsubs_city_m5, rametsS_urbsubs_city_m5_ME) # <2 away from e.o. though ME is lower

# 
# # ANy variation among families or populations?
# 
# ##### TACTIC 1: try bootstrapping #####
# # NOT PERFECT b/c can't nest family within pop but trying a few ways to get at the correct answer.
# # https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html#test-of-random-parameter
# 
# 
# ### MODEL 1: CITY_DIST ###
# ##########################
# 
# # JUST POPULATION
# gmm <-  glmer(Ramets_Sept ~ City_dist + (1|Population), # can't leave in Family... doesn't work
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1 <-  glmer(Ramets_Sept ~ City_dist + (1|Population/Family), 
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban") ,
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # POP:FAMILY
# gmm2 <-  glmer(Ramets_Sept ~ City_dist + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#   family = poisson,
#   data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # UNIQUE FAMILIES
# heights_both_2020$Family_unique <- paste(heights_both_2020$Population, heights_both_2020$Family)
# gmm3 <-  glmer(Ramets_Sept ~ City_dist + (1|Family_unique),
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4 <-  glmer(Ramets_Sept ~ City_dist + (1|Population:Family) + (1|Population),
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# 
# # REDUCED MODEL 1
# gmmDG1 <- glm(Ramets_Sept ~ City_dist,
#                 data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   family = poisson)
# 
# 
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1 <- pbnm(gmm,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg1) # p = 1 ...  no var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4 <- pbnm(gmm4,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop <- summary(pbgmmDg4) %T>%
#   print() # p = 1 ... no var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2 <- pbnm(gmm2,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam <- summary(pbgmmDg2) %T>%
#   print() # p = 1 ... no var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3 <- pbnm(gmm3,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg3) # p = 1 ... no var among families
# 
# 
# 
# ### MODEL 2: TRANSECT_ID ###
# ##########################
# 
# # JUST POPULATION
# gmm.2 <-  glmer(Ramets_Sept ~ Transect_ID + (1|Population), # can't leave in Family... doesn't work
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1.2 <-  glmer(Ramets_Sept ~ Transect_ID + (1|Population/Family), 
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # POP:FAMILY
# gmm2.2 <-  glmer(Ramets_Sept ~ Transect_ID + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # UNIQUE FAMILIES
# gmm3.2 <-  glmer(Ramets_Sept ~ Transect_ID + (1|Family_unique),
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"),
#   control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4.2 <-  glmer(Ramets_Sept ~ Transect_ID + (1|Population:Family) + (1|Population),
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"))
# 
# # REDUCED MODEL 2
# gmmDG1.2 <- glm(Ramets_Sept ~ Transect_ID,
#   family = poisson,
#     data = heights_both_2020 %>% filter(Urb_Rur == "Urban"))
# 
# 
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1.2 <- pbnm(gmm.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg1.2) # p = 1 ...  no var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4.2 <- pbnm(gmm4.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop.2 <- summary(pbgmmDg4.2) %T>%
#   print() # p = 1 ... no var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2.2 <- pbnm(gmm2.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam.2 <- summary(pbgmmDg2.2) %T>%
#   print() # p = 0.488...  little var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3.2 <- pbnm(gmm3.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg3.2) # p = 0.487... little var among families
# 
# 
# 
# 
# sum.1 <- summary(gmm4)
# 
# variances1 <- print(VarCorr(gmm4),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# # export percent variance explained
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_RametsSept_urban_glmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# 
# # export ranova
# sink(here::here("./Figures_Tables/ranova_PVE/2020_RametsSept_urban_glmer_ranova.csv"))
# print("POPULATION", sep="\n\n")
# print(ranova_pop, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam, sep="\n\n")
#   cat("\n")
# # if (ranova_pop[1] <= 0.05){
# #   print ('There is variance among populations')}
# # if (ranova_pop[1] > 0.05){
#   print ("There is not much variance among populations") #}
# if (ranova_fam[1] <= 0.05){
#   print ("There is variance among families")}
# if (ranova_fam[1] > 0.05){
#   print ("There is not much variance among families")}
#   
# cat("\n")
# cat("\n")
# 
# print("POPULATION", sep="\n\n")
# print(ranova_pop.2, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam.2, sep="\n\n")
#   cat("\n")
# # if (ranova_pop.2[1] <= 0.05){
# #   print ('Variance among populations differs by urban subtransect')}
# # if (ranova_pop.2[1] > 0.05){
#   print ("Variance among populations does not differ by urban subtransect") #}
# if (ranova_fam.2[1] <= 0.05){
#   print ("Variance among families differs by urban subtransect")}
# if (ranova_fam.2[1] > 0.05){
#   print ("Variance among families does not differ by urban subtransect")}
# sink()
```


##### Urb_score
```{r}
car::Anova(rametsS_urbsubs_usc_m5) # nothing sig
car::Anova(rametsS_urbsubs_usc_m5_ME) # nothing sig

AIC(rametsS_urbsubs_usc_m5, rametsS_urbsubs_usc_m5_ME) # <2 away from e.o. though ME is lower
```

#### Export ANOVA
```{r}
# anova_table_flx(rametsS_gr_city_m5)
# anova_table_flx(rametsS_gr_usc_m5)
# anova_table_flx(rametsS_urbsubs_city_m5)
# anova_table_flx(rametsS_urbsubs_city_m5_ME)
# anova_table_flx(rametsS_urbsubs_usc_m5)
# anova_table_flx(rametsS_urbsubs_usc_m5_ME)
# 
# AIC_compare.city_dist(rametsS_urbsubs_city_m5,
#                       rametsS_urbsubs_city_m5_ME)
#     
# AIC_compare.urb_score(rametsS_urbsubs_usc_m5,
#                       rametsS_urbsubs_usc_m5_ME) 

```

## Survival
### glmer: diagnostics
```{r}
# GRADIENT / CITY_DIST-----
surv20_gr_city_m1 <- glmer(dead_2020 ~ (1|Block) + (1|Population/Family) + City_dist,
  data = survival_2020,
  family = binomial(link = "logit"),
  nAGQ = 0)
res <- simulateResiduals(surv20_gr_city_m1)
plot(res)
# looks good!


# GRADIENT / URB SCORE-----
surv20_gr_usc_m1 <- glmer(dead_2020 ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = survival_2020,
  family = binomial(link = "logit"),
  nAGQ = 0,
    control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))
res <- simulateResiduals(surv20_gr_usc_m1)
plot(res)
# looks good!

# URB SUBTRANSECTS / CITY_DIST-----
surv20_urbsubs_city_m1 <- glmer(dead_2020 ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
  data = survival_2020 %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ = 0,
    control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))
res <- simulateResiduals(surv20_urbsubs_city_m1)
plot(res)
# looks good!

# main effects
surv20_urbsubs_city_m1_ME <- glmer(dead_2020 ~ (1|Block) + (1|Population/Family) + City_dist + Transect_ID,
  data = survival_2020 %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ = 0,
    control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))


# URB SUBTRANSECTS / URB SCORE-----
surv20_urbsubs_usc_m1 <- glmer(dead_2020 ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
  data = survival_2020 %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ = 0,
    control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))
res <- simulateResiduals(surv20_urbsubs_usc_m1)
plot(res)
# looks good!

# main effects
surv20_urbsubs_usc_m1_ME <- glmer(dead_2020 ~ (1|Block) + (1|Population/Family) + Urb_score + Transect_ID,
  data = survival_2020 %>% filter(Urb_Rur == "Urban"),
  family = binomial(link = "logit"),
  nAGQ = 0,
    control=glmerControl(optimizer="bobyqa",
                            optCtrl=list(maxfun=2e5)))


```

### Entire gradient: *Nothing sig for either
#### City_dist
```{r}
car::Anova(surv20_gr_city_m1) # not sig



# 
# # ANy variation within families or populations?
# 
# ##### TACTIC 1: try bootstrapping #####
# # NOT PERFECT b/c can't nest family within pop but trying a few ways to get at the correct answer.
# # https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html#test-of-random-parameter
# library(pbkrtest) # Parametric Bootstrap, Kenward-Roger and Satterthwaite Based
Methods for Test in Mixed Models
# library(pbnm)
# 
# # can't handle glmmTMB so switching back to glmer
# 
# # JUST POPULATION
# gmm <-  glmer(dead_2020 ~ City_dist + (1|Population), # can't leave in Family... doesn't work
#   family = binomial(link = "logit"),
#   nAGQ = 0,
#   data = survival_2020)
# 
# 
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1 <-  glmer(dead_2020 ~ City_dist + (1|Population/Family), 
#   family = binomial(link = "logit"),
#   nAGQ = 0,
#   data = survival_2020)
# 
# 
# # POP:FAMILY
# gmm2 <-  glmer(dead_2020 ~ City_dist + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#   family = binomial(link = "logit"),
#   nAGQ = 0,
#   data = survival_2020)
# 
# 
# # UNIQUE FAMILIES
# survival_2020$Family_unique <- paste(survival_2020$Population, survival_2020$Family)
# gmm3 <-  glmer(dead_2020 ~ City_dist + (1|Family_unique),
#   family = binomial(link = "logit"),
#   nAGQ = 0,
#   data = survival_2020)
# 
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4 <-  glmer(dead_2020 ~ City_dist + (1|Population:Family) + (1|Population),
#   family = binomial(link = "logit"),
#   nAGQ = 0,
#   data = survival_2020)
# 
# 
# 
# # REDUCED MODEL
# gmmDG1 <- glm(dead_2020 ~ City_dist,
#   family = binomial(link = "logit"),
#   data = survival_2020)
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1 <- pbnm(gmm,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# pbgmmDg1  %>%
#   summary() %>%
#   print()   # p = 0.063  ... MARG SIG- questionable var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4 <- pbnm(gmm4,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop <- summary(pbgmmDg4) %T>%
#   print() # p =  0.098  ... MARG SIG- questionable var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2 <- pbnm(gmm2,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam <- summary(pbgmmDg2) %T>%
#   print() # p = 0.237  ... little var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3 <- pbnm(gmm3,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835)
# pbgmmDg3 %>%
#   summary() %>%
#   print() # p = 0.237  ... little var among families, period
# 
# 
# 
# ##### use anova to test significance of terms (this isn't what we want, though): #####
# ## test Pop/Fam
# anova(gmm1, gmmDG1) # p =  0.51
# 
# ## test Pop/Fam but expanded
# anova(gmm4, gmmDG1) # p =   0.51    # SAME AS ABOVE
# 
# ## test Pop
# anova(gmm, gmmDG1) # p =  0.2462
# 
# ## test Fam
# anova(gmm3, gmmDG1) # p =   0.7278
# 
# ## test pop:fam
# anova(gmm2, gmmDG1) # p =  0.7278    # SAME AS ABOVE
# 
# 
# 
# #--------- FINAL RESULTS: ----------#
# # Bootstrapping:
# # - Pop:    MARGINALLY SIGNIFICANT
# # - Family: NOT SIGNIFICANT
# # anova:
# # - Pop:    NOT SIGNIFICANT
# # - Family: NOT SIGNIFICANT
# 
# # --- DO THE 2 METHODS MATCH? ---#
# #       [...]    Mostly
# #             
# 
# 
# 
# ##### old code #####
# 
# sum.1 <- summary(gmm4)
# 
# variances1 <- print(VarCorr(gmm4),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# # export percent variance explained
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Survival_glmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# 
# # export ranova
# sink(here::here("./Figures_Tables/ranova_PVE/2020_Survival_glmer_ranova.csv"))
# print("POPULATION", sep="\n\n")
# print(ranova_pop, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam, sep="\n\n")
#   cat("\n")
# if (ranova_pop[1] <= 0.05){
#   print ('There is variance among populations')}
# if (ranova_pop[1] > 0.05){
#   print ("There is not much variance among populations") }
# if (ranova_fam[1] <= 0.05){
#   print ("There is variance among families")}
# if (ranova_fam[1] > 0.05){
#   print ("There is not much variance among families") }
# sink()

```

#### Urb_score
```{r}
car::Anova(surv20_gr_usc_m1) # not sig
```


### Urban subtransects: *Nothing sig for either
#### City_dist
```{r}
car::Anova(surv20_urbsubs_city_m1) # not sig
car::Anova(surv20_urbsubs_city_m1_ME) # not sig
AIC(surv20_urbsubs_city_m1, surv20_urbsubs_city_m1_ME)
# AIC <2 apart; both "best models" though just main effects lower AIC

# 
# # ANy variation among families or populations?
# 
# ##### TACTIC 1: try bootstrapping #####
# # NOT PERFECT b/c can't nest family within pop but trying a few ways to get at the correct answer.
# # https://www.ssc.wisc.edu/sscc/pubs/MM/MM_TestEffects.html#test-of-random-parameter
# 
# 
# ### MODEL 1: CITY_DIST ###
# ##########################
# 
# # JUST POPULATION
# gmm <-  glmer(dead_2020 ~ City_dist + (1|Population), # can't leave in Family... doesn't work
#   data = survival_2020 %>% filter(Urb_Rur == "Urban"),
#   family = binomial(link = "logit"),
#   nAGQ = 0,
#     control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1 <-  glmer(dead_2020 ~ City_dist + (1|Population/Family), 
#   data = survival_2020 %>% filter(Urb_Rur == "Urban"),
#   family = binomial(link = "logit"),
#   nAGQ = 0,
#     control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # POP:FAMILY
# gmm2 <-  glmer(dead_2020 ~ City_dist + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#   data = survival_2020 %>% filter(Urb_Rur == "Urban"),
#   family = binomial(link = "logit"),
#   nAGQ = 0,
#     control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # UNIQUE FAMILIES
# survival_2020$Family_unique <- paste(survival_2020$Population, survival_2020$Family)
# gmm3 <-  glmer(dead_2020 ~ City_dist + (1|Family_unique),
#   data = survival_2020 %>% filter(Urb_Rur == "Urban"),
#   family = binomial(link = "logit"),
#   nAGQ = 0,
#     control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4 <-  glmer(dead_2020 ~ City_dist + (1|Population:Family) + (1|Population),
#   data = survival_2020 %>% filter(Urb_Rur == "Urban"),
#   family = binomial(link = "logit"),
#   nAGQ = 0,
#     control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# 
# # REDUCED MODEL 1
# gmmDG1 <- glm(dead_2020 ~ City_dist,
#   data = survival_2020 %>% filter(Urb_Rur == "Urban"),
#   family = binomial(link = "logit"))
# 
# 
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1 <- pbnm(gmm,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg1) # p = 0.383 ...  little var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4 <- pbnm(gmm4,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop <- summary(pbgmmDg4) %T>%
#   print() # p = 0.785 ... little var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2 <- pbnm(gmm2,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam <- summary(pbgmmDg2) %T>%
#   print() # p = 0.413 ... little var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3 <- pbnm(gmm3,gmmDG1,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg3) # p = 0.431 ... little var among families
# 
# 
# 
# ### MODEL 2: TRANSECT_ID ###
# ##########################
# 
# # JUST POPULATION
# gmm.2 <-  glmer(dead_2020 ~ Transect_ID + (1|Population), # can't leave in Family... doesn't work
#   data = survival_2020 %>% filter(Urb_Rur == "Urban"),
#   family = binomial(link = "logit"),
#   nAGQ = 0,
#     control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # IDEAL MODEL (DOESN'T WORK w/glmer THOUGH)
# gmm1.2 <-  glmer(dead_2020 ~ Transect_ID + (1|Population/Family), 
#   data = survival_2020 %>% filter(Urb_Rur == "Urban"),
#   family = binomial(link = "logit"),
#   nAGQ = 0,
#     control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # POP:FAMILY
# gmm2.2 <-  glmer(dead_2020 ~ Transect_ID + (1|Population:Family), # can't leave in Family as nested but CAN as crossed
#   data = survival_2020 %>% filter(Urb_Rur == "Urban"),
#   family = binomial(link = "logit"),
#   nAGQ = 0,
#     control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # UNIQUE FAMILIES
# gmm3.2 <-  glmer(dead_2020 ~ Transect_ID + (1|Family_unique),
#   data = survival_2020 %>% filter(Urb_Rur == "Urban"),
#   family = binomial(link = "logit"),
#   nAGQ = 0,
#     control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # EQUIVALENT TO FAM NESTED W/IN POP
# gmm4.2 <-  glmer(dead_2020 ~ Transect_ID + (1|Population:Family) + (1|Population),
#   data = survival_2020 %>% filter(Urb_Rur == "Urban"),
#   family = binomial(link = "logit"),
#   nAGQ = 0,
#     control=glmerControl(optimizer="bobyqa",
#                             optCtrl=list(maxfun=2e5)))
# 
# # REDUCED MODEL 2
# gmmDG1.2 <- glm(dead_2020 ~ Transect_ID,
#   data = survival_2020 %>% filter(Urb_Rur == "Urban"),
#   family = binomial(link = "logit"))
# 
# 
# 
# ### RESULTS ###
# # POPULATION (so, results are about populations)
# pbgmmDg1.2 <- pbnm(gmm.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg1.2) # p = 0.722 ...  little var among pops
# 
# # EQUIVALENT TO FAM NESTED W/IN POP (so, results are about populations)
# pbgmmDg4.2 <- pbnm(gmm4.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_pop.2 <- summary(pbgmmDg4.2) %T>%
#   print() # p = 0.564... little var among pops accounting for fams
# 
# # POP:FAMILY (so, results are about families)- accounts for fams being in same pop
# pbgmmDg2.2 <- pbnm(gmm2.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# ranova_fam.2 <- summary(pbgmmDg2.2) %T>%
#   print() # p = 0.47...  little var among families crossed w/ pops
# 
# # UNIQUE FAMILIES (so, results are about families)
# pbgmmDg3.2 <- pbnm(gmm3.2,gmmDG1.2,nsim=1000,tasks=10,cores=2,seed=3400835) 
# summary(pbgmmDg3.2) # p = 0.463... little var among families
# 
# 
# 
# 
# sum.1 <- summary(gmm4)
# 
# variances1 <- print(VarCorr(gmm4),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# # export percent variance explained
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_Survival_urban_glmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# 
# # export ranova
# sink(here::here("./Figures_Tables/ranova_PVE/2020_Survival_urban_glmer_ranova.csv"))
# print("POPULATION", sep="\n\n")
# print(ranova_pop, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam, sep="\n\n")
#   cat("\n")
# if (ranova_pop[1] <= 0.05){
#   print ('There is variance among populations')}
# if (ranova_pop[1] > 0.05){
#   print ("There is not much variance among populations") }
# if (ranova_fam[1] <= 0.05){
#   print ("There is variance among families")}
# if (ranova_fam[1] > 0.05){
#   print ("There is not much variance among families")}
#   
# cat("\n")
# cat("\n")
# 
# print("POPULATION", sep="\n\n")
# print(ranova_pop.2, sep="\n\n")
#   cat("\n")
# print("FAMILY", sep="\n\n")
# print(ranova_fam.2, sep="\n\n")
#   cat("\n")
# if (ranova_pop.2[1] <= 0.05){
#   print ('Variance among populations differs by urban subtransect')}
# if (ranova_pop.2[1] > 0.05){
#   print ("Variance among populations does not differ by urban subtransect") }
# if (ranova_fam.2[1] <= 0.05){
#   print ("Variance among families differs by urban subtransect")}
# if (ranova_fam.2[1] > 0.05){
#   print ("Variance among families does not differ by urban subtransect")}
# sink()
```

#### Urb_score
```{r}
car::Anova(surv20_urbsubs_usc_m1) # not sig
car::Anova(surv20_urbsubs_usc_m1_ME) # not sig
AIC(surv20_urbsubs_usc_m1, surv20_urbsubs_usc_m1_ME)
# AIC <2 apart; both "best models" though just main effects lower AIC
```

### Export ANOVA
```{r}
# anova_table_flx(surv20_gr_city_m1)
# anova_table_flx(surv20_gr_usc_m1)
# anova_table_flx(surv20_urbsubs_city_m1)
# anova_table_flx(surv20_urbsubs_city_m1_ME)
# anova_table_flx(surv20_urbsubs_usc_m1)
# anova_table_flx(surv20_urbsubs_usc_m1_ME)
# 
# AIC_compare.city_dist(surv20_urbsubs_city_m1,
#                       surv20_urbsubs_city_m1_ME)
#     
# AIC_compare.urb_score(surv20_urbsubs_usc_m1,
#                       surv20_urbsubs_usc_m1_ME) 


# test1 <- car::Anova(surv20_urbsubs_city_m1) %>%
#   tidy() %>%
#   as.data.frame() %>%
#   dplyr::mutate(.,
#                 Response = as.character(formula(surv20_urbsubs_city_m1)[[2]]),
#                 .before = term) %>%
#   dplyr::mutate(Sites = case_when( str_detect(as.character(formula(surv20_urbsubs_city_m1)[3]), "Transect_ID") == TRUE ~ "Urban Only",
#  str_detect(as.character(formula(surv20_urbsubs_city_m1)[3]), "Transect_ID") == FALSE ~ "All"),
#                 .before = term) %>%
#   dplyr::mutate(Significance = case_when(p.value <= 0.1 ~ "Marginal",
#                                          p.value <= 0.05 ~ "*", 
#                                 p.value < 0.01 ~ "**",
#                                 p.value < 0.001 ~ "***")) %>%
#   dplyr::mutate(., AIC = AIC(surv20_gr_city_m1)) %>%
#   dplyr::select(., -df) %>%
#   dplyr::rename(., Chi_sq = statistic,
#                 Predictor = term,
#                 p = p.value) %>%
#   dplyr::mutate_if(.,
#             is.character,
#             str_replace_all,
#             pattern = c("City_dist"),
#             replacement = c("Distance to City Center")) %>%
#     dplyr::mutate_if(.,
#             is.character,
#             str_replace_all,
#             pattern = c("Urb_score"),
#             replacement = c("Urbanization Score")) %>%
#     dplyr::mutate_if(.,
#             is.character,
#             str_replace_all,
#             pattern = c("Transect_ID"),
#             replacement = c("Subtransect")) %>%
#   mutate_if(is.numeric, round, 3)
# 
# 

```


## SLA
### lmer: diagnostics
```{r}
# GRADIENT / CITY_DIST-----

# sla_gr_city_m1 <- lmer(SLA ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = sla_ldmc,
#   REML = F)
# sjPlot::plot_model(sla_gr_city_m1, type = "diag") # is singular, looks normal except for long right tail
# 
# diagnostic(resid(sla_gr_city_m1)) # very kurtotic and skewed
# 
# sla_gr_city_m2 <- lmer(SLA ~ (1|Population/Family) + City_dist,
#   data = sla_ldmc,
#   REML = F) # still singular... take out Fam
# 
# sla_gr_city_m3 <- lmer(SLA ~ (1|Population) + City_dist,
#   data = sla_ldmc,
#   REML = F) # still singular... take out block
 

# # try glmmtmb
# sla_gr_city_m1 <- glmmTMB(SLA ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = sla_ldmc,
#   family = gaussian) # NOT singular!
# sjPlot::plot_model(sla_gr_city_m1, type='diag') #very right-skewed... try sqrt


sla_gr_city_m1 <- glmmTMB(sqrt(SLA) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = sla_ldmc,
  family = gaussian) # NOT singular!
sjPlot::plot_model(sla_gr_city_m1, type='diag') # looks good enough

hist(sla_ldmc$SLA)
boxplot.stats(sla_ldmc$SLA)$out


# GRADIENT / URB SCORE-----

# sla_gr_usc_m1 <- lmer(SLA ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = sla_ldmc,
#   REML = F)
# sjPlot::plot_model(sla_gr_city_m1, type = "diag") # is singular, looks normal except for long right tail
# 
# diagnostic(resid(sla_gr_usc_m1)) # very kurtotic and skewed
# 
# sla_gr_usc_m1 <- lmer(SLA ~ (1|Population/Family) + Urb_score,
#   data = sla_ldmc,
#   REML = F) # still singular... take out Fam
# 
# sla_gr_usc_m1 <- lmer(SLA ~ (1|Population) + Urb_score,
#   data = sla_ldmc,
#   REML = F) # still singular... take out block
 

# # try glmmtmb
# sla_gr_usc_m1 <- glmmTMB(SLA ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = sla_ldmc,
#   family = gaussian) # NOT singular!
# sjPlot::plot_model(sla_gr_usc_m1, type='diag') #very right-skewed... try sqrt


sla_gr_usc_m1 <- glmmTMB(sqrt(SLA) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = sla_ldmc,
  family = gaussian) # NOT singular!
sjPlot::plot_model(sla_gr_usc_m1, type='diag') # looks good enough





# URB SUBTRANSECTS / CITY_DIST-----

# SLA_urbsubs_city_m1 <- lmer(SLA ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(SLA_urbsubs_city_m1, type = "diag") # is singular, looks normal except for right tail (but otherwise looks fine... I think it's kurtotic)... take out block
# 
# SLA_urbsubs_city_m2 <- lmer(SLA ~  (1|Population/Family) + City_dist * Transect_ID,
#   data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
#   REML = F) # is singular,  take out Fam
# 
# SLA_urbsubs_city_m3 <- lmer(SLA ~ (1|Population) + City_dist * Transect_ID,
#   data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
#   REML = F)  # NOT singular... try glmmTMB though
# 
# 
# SLA_urbsubs_city_m1 <- glmmTMB(SLA ~ (1|Block) + (1|Population/Family) +  City_dist * Transect_ID,
#   data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
#   family = gaussian) # it works! use this
# sjPlot::plot_model(SLA_urbsubs_city_m1, type = "diag") # is singular, looks normal except for right tail (but otherwise looks fine... I think it's kurtotic)... try sqrt transf

SLA_urbsubs_city_m1 <- glmmTMB(sqrt(SLA) ~ (1|Block) + (1|Population/Family) +  City_dist * Transect_ID,
  data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
  family = gaussian) # it works! use this
sjPlot::plot_model(SLA_urbsubs_city_m1, type = "diag") # good enough


# main effects
SLA_urbsubs_city_m1_ME <- glmmTMB(sqrt(SLA) ~ (1|Block) + (1|Population/Family) +  City_dist + Transect_ID,
  data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
  family = gaussian) 



# URB SUBTRANSECTS / URB SCORE-----

# SLA_urbsubs_usc_m1 <- lmer(SLA ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(SLA_urbsubs_usc_m1, type = "diag") # is singular, looks normal except for right tail (but otherwise looks fine... I think it's kurtotic)... take out block
# 
# SLA_urbsubs_usc_m2 <- lmer(SLA ~  (1|Population/Family) + Urb_score * Transect_ID,
#   data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
#   REML = F) # is singular,  take out Fam
# 
# SLA_urbsubs_usc_m3 <- lmer(SLA ~ (1|Population) + Urb_score * Transect_ID,
#   data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
#   REML = F)  # NOT singular... try glmmTMB though
# 
# 
# SLA_urbsubs_usc_m1 <- glmmTMB(SLA ~ (1|Block) + (1|Population/Family) +  Urb_score * Transect_ID,
#   data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
#   family = gaussian) # it works! use this
# sjPlot::plot_model(SLA_urbsubs_usc_m1, type = "diag") # is singular, looks normal except for right tail (but otherwise looks fine... I think it's kurtotic)... try sqrt transf

SLA_urbsubs_usc_m1 <- glmmTMB(sqrt(SLA) ~ (1|Population/Family) +  Urb_score * Transect_ID,
  data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
  family = gaussian) # convergence issue... take out block
sjPlot::plot_model(SLA_urbsubs_usc_m1, type = "diag") # good enough


# main effects
SLA_urbsubs_usc_m1_ME <- glmmTMB(sqrt(SLA) ~ (1|Block) + (1|Population/Family) +  Urb_score + Transect_ID,
  data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
  family = gaussian) # fine with block included


```

### Entire gradient: *Not sig for either
#### City_dist
```{r}
car::Anova(sla_gr_city_m1) # not sig


# ANy variation within families or populations?
# m.1 <- glmmTMB(sqrt(SLA) ~ (1|Population/Family),
#             data = sla_ldmc,
#             REML = T)
# 
# 
# ranova(m.1)
# # nope
# sum.1 <- summary(m.1)
# 
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_growthrate_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_growthrate_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

#### Urb_score
```{r}
car::Anova(sla_gr_usc_m1) #not sig

```


### Urban subtransects: *Not sig for city_dist, transect sig for urb_score
#### City_dist
```{r}
car::Anova(SLA_urbsubs_city_m1) #  Not sig
car::Anova(SLA_urbsubs_city_m1_ME) #  Not sig

AIC(SLA_urbsubs_city_m1, SLA_urbsubs_city_m1_ME) # ME model lower AIC (only by 1)
summary(SLA_urbsubs_city_m1_ME)



# # ANy variation among families or populations?
# m.1 <- lmer(sqrt(rel_growth_rate) ~  (1|Population/Family) + City_dist ,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 & Urb_Rur == "Urban"),
#   REML = T)
# 
# ranova(m.1)
# # no
# 
# m.2 <- lmer(sqrt(rel_growth_rate) ~ (1|Population/Family) + Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 & Urb_Rur == "Urban"),
#             REML = F)
# car::Anova(m.2)
# # not among transects either
# 
# 
# m.3 <- lmer(sqrt(rel_growth_rate) ~ (1|Population/Family) + Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
#   REML = T)
# car::Anova(m.3)
# # also not sig among transects
# 
# 
# sum.1 <- summary(m.1)
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_growthrate_urban_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_growthrate_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# write.table(car::Anova(m.2), here::here("./Figures_Tables/ranova_PVE/2020_growthrate_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

#### Urb_score
```{r}
car::Anova(SLA_urbsubs_usc_m1) #  transect sig
car::Anova(SLA_urbsubs_usc_m1_ME) #  transect marg sig

AIC(SLA_urbsubs_usc_m1, SLA_urbsubs_usc_m1_ME) # ME model lower AIC
summary(SLA_urbsubs_usc_m1_ME)
```


### Export ANOVA
```{r}
# anova_table_flx(rgr_gr_city_m6)
# anova_table_flx(rgr_gr_city_m8)
# anova_table_flx(rgr_gr_usc_m6)
# anova_table_flx(rgr_gr_usc_m8)
# 
# anova_table_flx(rgr_urbsubs_city_m5)
# anova_table_flx(rgr_urbsubs_city_m5_ME)
# anova_table_flx(rgr_urbsubs_city_m8)
# anova_table_flx(rgr_urbsubs_city_m8_ME.1)
# anova_table_flx(rgr_urbsubs_usc_m5)
# anova_table_flx(rgr_urbsubs_usc_m5_ME)
# anova_table_flx(rgr_urbsubs_usc_m8)
# anova_table_flx(rgr_urbsubs_usc_m8_ME.1)
# 
# AIC_compare.city_dist_transf_binomial(rgr_urbsubs_city_m5 ,
#                        rgr_urbsubs_city_m5_ME)
#     
# AIC_compare.city_dist_transf_quantitative( rgr_urbsubs_city_m8,
#                        rgr_urbsubs_city_m8_ME.1) 
# 
# AIC_compare.urb_score_transf_binomial(rgr_urbsubs_usc_m5 ,
#                        rgr_urbsubs_usc_m5_ME)
#     
# AIC_compare.urb_score_transf_quantitative( rgr_urbsubs_usc_m8,
#                        rgr_urbsubs_usc_m8_ME.1) 

```


## LDMC- NOT DONE AT ALL
### lmer: diagnostics
```{r}
# GRADIENT / CITY_DIST-----

ldmc_gr_city_m1 <- lmer(LDMC ~ (1|Block) + (1|Population/Family) + City_dist,
  data = sla_ldmc %>% filter(LDMC < 1),
  REML = F)
sjPlot::plot_model(ldmc_gr_city_m1, type = "diag") # is singular, looks normal except for long right tail
# 
# diagnostic(resid(sla_gr_city_m1)) # very kurtotic and skewed
# 
# sla_gr_city_m2 <- lmer(SLA ~ (1|Population/Family) + City_dist,
#   data = sla_ldmc,
#   REML = F) # still singular... take out Fam
# 
# sla_gr_city_m3 <- lmer(SLA ~ (1|Population) + City_dist,
#   data = sla_ldmc,
#   REML = F) # still singular... take out block
 

# # try glmmtmb
# sla_gr_city_m1 <- glmmTMB(SLA ~ (1|Block) + (1|Population/Family) + City_dist,
#   data = sla_ldmc,
#   family = gaussian) # NOT singular!
# sjPlot::plot_model(sla_gr_city_m1, type='diag') #very right-skewed... try sqrt


sla_gr_city_m1 <- glmmTMB(sqrt(SLA) ~ (1|Block) + (1|Population/Family) + City_dist,
  data = sla_ldmc,
  family = gaussian) # NOT singular!
sjPlot::plot_model(sla_gr_city_m1, type='diag') # looks good enough




# GRADIENT / URB SCORE-----

# sla_gr_usc_m1 <- lmer(SLA ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = sla_ldmc,
#   REML = F)
# sjPlot::plot_model(sla_gr_city_m1, type = "diag") # is singular, looks normal except for long right tail
# 
# diagnostic(resid(sla_gr_usc_m1)) # very kurtotic and skewed
# 
# sla_gr_usc_m1 <- lmer(SLA ~ (1|Population/Family) + Urb_score,
#   data = sla_ldmc,
#   REML = F) # still singular... take out Fam
# 
# sla_gr_usc_m1 <- lmer(SLA ~ (1|Population) + Urb_score,
#   data = sla_ldmc,
#   REML = F) # still singular... take out block
 

# # try glmmtmb
# sla_gr_usc_m1 <- glmmTMB(SLA ~ (1|Block) + (1|Population/Family) + Urb_score,
#   data = sla_ldmc,
#   family = gaussian) # NOT singular!
# sjPlot::plot_model(sla_gr_usc_m1, type='diag') #very right-skewed... try sqrt


sla_gr_usc_m1 <- glmmTMB(sqrt(SLA) ~ (1|Block) + (1|Population/Family) + Urb_score,
  data = sla_ldmc,
  family = gaussian) # NOT singular!
sjPlot::plot_model(sla_gr_usc_m1, type='diag') # looks good enough





# URB SUBTRANSECTS / CITY_DIST-----

# SLA_urbsubs_city_m1 <- lmer(SLA ~ (1|Block) + (1|Population/Family) + City_dist * Transect_ID,
#   data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(SLA_urbsubs_city_m1, type = "diag") # is singular, looks normal except for right tail (but otherwise looks fine... I think it's kurtotic)... take out block
# 
# SLA_urbsubs_city_m2 <- lmer(SLA ~  (1|Population/Family) + City_dist * Transect_ID,
#   data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
#   REML = F) # is singular,  take out Fam
# 
# SLA_urbsubs_city_m3 <- lmer(SLA ~ (1|Population) + City_dist * Transect_ID,
#   data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
#   REML = F)  # NOT singular... try glmmTMB though
# 
# 
# SLA_urbsubs_city_m1 <- glmmTMB(SLA ~ (1|Block) + (1|Population/Family) +  City_dist * Transect_ID,
#   data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
#   family = gaussian) # it works! use this
# sjPlot::plot_model(SLA_urbsubs_city_m1, type = "diag") # is singular, looks normal except for right tail (but otherwise looks fine... I think it's kurtotic)... try sqrt transf

SLA_urbsubs_city_m1 <- glmmTMB(sqrt(SLA) ~ (1|Block) + (1|Population/Family) +  City_dist * Transect_ID,
  data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
  family = gaussian) # it works! use this
sjPlot::plot_model(SLA_urbsubs_city_m1, type = "diag") # good enough


# main effects
SLA_urbsubs_city_m1_ME <- glmmTMB(sqrt(SLA) ~ (1|Block) + (1|Population/Family) +  City_dist + Transect_ID,
  data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
  family = gaussian) 



# URB SUBTRANSECTS / URB SCORE-----

# SLA_urbsubs_usc_m1 <- lmer(SLA ~ (1|Block) + (1|Population/Family) + Urb_score * Transect_ID,
#   data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
#   REML = F)
# sjPlot::plot_model(SLA_urbsubs_usc_m1, type = "diag") # is singular, looks normal except for right tail (but otherwise looks fine... I think it's kurtotic)... take out block
# 
# SLA_urbsubs_usc_m2 <- lmer(SLA ~  (1|Population/Family) + Urb_score * Transect_ID,
#   data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
#   REML = F) # is singular,  take out Fam
# 
# SLA_urbsubs_usc_m3 <- lmer(SLA ~ (1|Population) + Urb_score * Transect_ID,
#   data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
#   REML = F)  # NOT singular... try glmmTMB though
# 
# 
# SLA_urbsubs_usc_m1 <- glmmTMB(SLA ~ (1|Block) + (1|Population/Family) +  Urb_score * Transect_ID,
#   data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
#   family = gaussian) # it works! use this
# sjPlot::plot_model(SLA_urbsubs_usc_m1, type = "diag") # is singular, looks normal except for right tail (but otherwise looks fine... I think it's kurtotic)... try sqrt transf

SLA_urbsubs_usc_m1 <- glmmTMB(sqrt(SLA) ~ (1|Population/Family) +  Urb_score * Transect_ID,
  data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
  family = gaussian) # convergence issue... take out block
sjPlot::plot_model(SLA_urbsubs_usc_m1, type = "diag") # good enough


# main effects
SLA_urbsubs_usc_m1_ME <- glmmTMB(sqrt(SLA) ~ (1|Block) + (1|Population/Family) +  Urb_score + Transect_ID,
  data = sla_ldmc %>% filter(Urb_Rur == "Urban"),
  family = gaussian) # fine with block included


```

### Entire gradient: *Not sig for either
#### City_dist
```{r}
car::Anova(sla_gr_city_m1) # not sig


# ANy variation within families or populations?
# m.1 <- glmmTMB(sqrt(SLA) ~ (1|Population/Family),
#             data = sla_ldmc,
#             REML = T)
# 
# 
# ranova(m.1)
# # nope
# sum.1 <- summary(m.1)
# 
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_growthrate_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_growthrate_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

#### Urb_score
```{r}
car::Anova(sla_gr_usc_m1) #not sig

```


### Urban subtransects: *Not sig for city_dist, Marg sig for urb_score
#### City_dist
```{r}
car::Anova(SLA_urbsubs_city_m1) #  not sig
car::Anova(SLA_urbsubs_city_m1_ME) #  not sig

AIC(SLA_urbsubs_city_m1, SLA_urbsubs_city_m1_ME) # ME model lower AIC (only by 1)
summary(SLA_urbsubs_city_m1_ME)



# # ANy variation among families or populations?
# m.1 <- lmer(sqrt(rel_growth_rate) ~  (1|Population/Family) + City_dist ,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 & Urb_Rur == "Urban"),
#   REML = T)
# 
# ranova(m.1)
# # no
# 
# m.2 <- lmer(sqrt(rel_growth_rate) ~ (1|Population/Family) + Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 & Urb_Rur == "Urban"),
#             REML = F)
# car::Anova(m.2)
# # not among transects either
# 
# 
# m.3 <- lmer(sqrt(rel_growth_rate) ~ (1|Population/Family) + Transect_ID,
#   data = heights_both_2020 %>% filter(rel_growth_rate_binary == 1 &Urb_Rur == "Urban"),
#   REML = T)
# car::Anova(m.3)
# # also not sig among transects
# 
# 
# sum.1 <- summary(m.1)
# 
# variances1 <- print(VarCorr(m.1),comp="Variance") %>%
#   as.data.frame() %>%
#   dplyr::mutate(., PVE = vcov / sum(vcov)) %>%
#   dplyr::select(., c(grp, vcov, PVE)) %>%
#   dplyr::rename(., Group = grp,
#                 Variance = vcov)
# 
# 
# write.table(ranova(m.1), here::here("./Figures_Tables/ranova_PVE/2020_growthrate_urban_lmer_PVE.csv"), col.names=TRUE, sep=",")
# write.table(variances1, here::here("./Figures_Tables/ranova_PVE/2020_growthrate_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
# write.table(car::Anova(m.2), here::here("./Figures_Tables/ranova_PVE/2020_growthrate_urban_lmer_PVE.csv"), col.names=TRUE, sep=",", append=TRUE)
```

#### Urb_score
```{r}
car::Anova(SLA_urbsubs_usc_m1) #  transect sig
car::Anova(SLA_urbsubs_usc_m1_ME) #  transect marg sig

AIC(SLA_urbsubs_usc_m1, SLA_urbsubs_usc_m1_ME) # ME model lower AIC
summary(SLA_urbsubs_usc_m1_ME)
```


### Export ANOVA
```{r}
# anova_table_flx(rgr_gr_city_m6)
# anova_table_flx(rgr_gr_city_m8)
# anova_table_flx(rgr_gr_usc_m6)
# anova_table_flx(rgr_gr_usc_m8)
# 
# anova_table_flx(rgr_urbsubs_city_m5)
# anova_table_flx(rgr_urbsubs_city_m5_ME)
# anova_table_flx(rgr_urbsubs_city_m8)
# anova_table_flx(rgr_urbsubs_city_m8_ME.1)
# anova_table_flx(rgr_urbsubs_usc_m5)
# anova_table_flx(rgr_urbsubs_usc_m5_ME)
# anova_table_flx(rgr_urbsubs_usc_m8)
# anova_table_flx(rgr_urbsubs_usc_m8_ME.1)
# 
# AIC_compare.city_dist_transf_binomial(rgr_urbsubs_city_m5 ,
#                        rgr_urbsubs_city_m5_ME)
#     
# AIC_compare.city_dist_transf_quantitative( rgr_urbsubs_city_m8,
#                        rgr_urbsubs_city_m8_ME.1) 
# 
# AIC_compare.urb_score_transf_binomial(rgr_urbsubs_usc_m5 ,
#                        rgr_urbsubs_usc_m5_ME)
#     
# AIC_compare.urb_score_transf_quantitative( rgr_urbsubs_usc_m8,
#                        rgr_urbsubs_usc_m8_ME.1) 

```



## Latex
```{r}

```
## Cardenolide concentration
```{r}

```

## Export all models & model formulas as a key
```{r}
# list of all models-----
model_list <- list(
  
  flowering_gr_city_m1, # flowering success models
flowering_gr_urb_m1,
flowering_urbsubs_city_m1,
flowering_urbsubs_city_m1_ME,
flowering_urbsubs_usc_m1,
flowering_urbsubs_usc_m1_ME,
  
  Height_Jun20_gr_city_m5, # June height models
Height_Jun20_gr_usc_m2,
Height_Jun20_urbsubs_city_m2,
Height_Jun20_urbsubs_city_m2_ME,
Height_Jun20_urbsubs_usc_m2,
Height_Jun20_urbsubs_usc_m2_ME,
  
    Height_Sept20_gr_city_m2, # Sept height models
Height_Sept20_gr_usc_m5,
Height_Sept20_urbsubs_city_m5,
Height_Sept20_urbsubs_city_m5_ME,
Height_Sept20_urbsubs_usc_m2,
Height_Sept20_urbsubs_usc_m2_ME,
  
    weev_stn_gr_city_m3, # weevil damage (standardized) models
weev_stn_gr_city_m11,
weev_stn_gr_usc_m3,
weev_stn_gr_usc_m12,
weev_stn_urbsubs_city_m4,
weev_stn_urbsubs_city_m4_ME,
weev_stn_urbsubs_city_m11,
weev_stn_urbsubs_city_m11_ME.2,
weev_stn_urbsubs_usc_m4,
weev_stn_urbsubs_usc_m4_ME,
weev_stn_usc_usc_m10,
weev_stn_usc_usc_m10_ME.2,
  
    weev_gr_city_m3, # weevil damage models
weev_gr_city_m11,
weev_gr_usc_m3,
weev_gr_usc_m10,
weev_urbsubs_city_m4,
weev_urbsubs_city_m4_ME, 
weev_urbsubs_city_m11,
weev_urbsubs_city_m11_ME,
weev_urbsubs_usc_m4,
weev_urbsubs_usc_m4_ME,
weev_urbsubs_usc_m11,
weev_urbsubs_usc_m11_ME,
  
  herb2020_gr_dist_m5, # July herbivory models
herb2020_gr_dist_m8,
herb2020_gr_usc_m5,
herb2020_gr_usc_m8,
herb2020_urb_dist_m5,
herb2020_urb_dist_m5_ME,
herb2020_urb_dist_m8,
herb2020_urb_dist_m8_ME,
herb2020_urb_usc_m5,
herb2020_urb_usc_m5_ME,
herb2020_urb_usc_m8,
herb2020_urb_usc_m8_ME,
  
  herb2020.S_gr_dist_m5, # Sept herbivory models
herb2020.S_gr_dist_m12,
herb2020.S_gr_usc_m5,
herb2020.S_gr_usc_m12,
herb2020.S_urb_dist_m5,
herb2020.S_urb_dist_m5_ME,
herb2020.S_urb_dist_m12,
herb2020.S_urb_dist_m12_ME,
herb2020.S_urb_usc_m5,
herb2020.S_urb_usc_m5_ME,
herb2020.S_urb_usc_m12,
herb2020.S_urb_usc_m12_ME,

  rgr_gr_city_m6, # relative growth rate models
rgr_gr_city_m8,
rgr_gr_usc_m6,
rgr_gr_usc_m8,
rgr_urbsubs_city_m5,
rgr_urbsubs_city_m5_ME,
rgr_urbsubs_city_m8,
rgr_urbsubs_city_m8_ME.1,
rgr_urbsubs_usc_m5,
rgr_urbsubs_usc_m5_ME,
rgr_urbsubs_usc_m8,
rgr_urbsubs_usc_m8_ME.1,
  
  rametsJ_gr_city_m2, # June ramets models
rametsJ_gr_usc_m2,
rametsJ_urbsubs_city_m1,
rametsJ_urbsubs_city_m1_ME,
rametsJ_urbsubs_urbsubs_m7,
rametsJ_urbsubs_urbsubs_m7_ME,
  
  rametsS_gr_city_m5, # Sept ramets models
rametsS_gr_usc_m5,
rametsS_urbsubs_city_m5,
rametsS_urbsubs_city_m5_ME,
rametsS_urbsubs_usc_m5,
rametsS_urbsubs_usc_m5_ME,

  surv20_gr_city_m1, # survival models
surv20_gr_usc_m1,
surv20_urbsubs_city_m1,
surv20_urbsubs_city_m1_ME,
surv20_urbsubs_usc_m1,
surv20_urbsubs_usc_m1_ME
  
)

# list of all models, in quotes-----
all_models_2020 <- qq(
  flowering_gr_city_m1, # flowering success models
flowering_gr_urb_m1,
flowering_urbsubs_city_m1,
flowering_urbsubs_city_m1_ME,
flowering_urbsubs_usc_m1,
flowering_urbsubs_usc_m1_ME,
  
  Height_Jun20_gr_city_m5, # June height models
Height_Jun20_gr_usc_m2,
Height_Jun20_urbsubs_city_m2,
Height_Jun20_urbsubs_city_m2_ME,
Height_Jun20_urbsubs_usc_m2,
Height_Jun20_urbsubs_usc_m2_ME,
  
    Height_Sept20_gr_city_m2, # Sept height models
Height_Sept20_gr_usc_m5,
Height_Sept20_urbsubs_city_m5,
Height_Sept20_urbsubs_city_m5_ME,
Height_Sept20_urbsubs_usc_m2,
Height_Sept20_urbsubs_usc_m2_ME,
  
    weev_stn_gr_city_m3, # weevil damage (standardized) models
weev_stn_gr_city_m11,
weev_stn_gr_usc_m3,
weev_stn_gr_usc_m12,
weev_stn_urbsubs_city_m4,
weev_stn_urbsubs_city_m4_ME,
weev_stn_urbsubs_city_m11,
weev_stn_urbsubs_city_m11_ME.2,
weev_stn_urbsubs_usc_m4,
weev_stn_urbsubs_usc_m4_ME,
weev_stn_usc_usc_m10,
weev_stn_usc_usc_m10_ME.2,
  
    weev_gr_city_m3, # weevil damage models
weev_gr_city_m11,
weev_gr_usc_m3,
weev_gr_usc_m10,
weev_urbsubs_city_m4,
weev_urbsubs_city_m4_ME, 
weev_urbsubs_city_m11,
weev_urbsubs_city_m11_ME,
weev_urbsubs_usc_m4,
weev_urbsubs_usc_m4_ME,
weev_urbsubs_usc_m11,
weev_urbsubs_usc_m11_ME,
  
  herb2020_gr_dist_m5, # July herbivory models
herb2020_gr_dist_m8,
herb2020_gr_usc_m5,
herb2020_gr_usc_m8,
herb2020_urb_dist_m5,
herb2020_urb_dist_m5_ME,
herb2020_urb_dist_m8,
herb2020_urb_dist_m8_ME,
herb2020_urb_usc_m5,
herb2020_urb_usc_m5_ME,
herb2020_urb_usc_m8,
herb2020_urb_usc_m8_ME,
  
  herb2020.S_gr_dist_m5, # Sept herbivory models
herb2020.S_gr_dist_m12,
herb2020.S_gr_usc_m5,
herb2020.S_gr_usc_m12,
herb2020.S_urb_dist_m5,
herb2020.S_urb_dist_m5_ME,
herb2020.S_urb_dist_m12,
herb2020.S_urb_dist_m12_ME,
herb2020.S_urb_usc_m5,
herb2020.S_urb_usc_m5_ME,
herb2020.S_urb_usc_m12,
herb2020.S_urb_usc_m12_ME,

  rgr_gr_city_m6, # relative growth rate models
rgr_gr_city_m8,
rgr_gr_usc_m6,
rgr_gr_usc_m8,
rgr_urbsubs_city_m5,
rgr_urbsubs_city_m5_ME,
rgr_urbsubs_city_m8,
rgr_urbsubs_city_m8_ME.1,
rgr_urbsubs_usc_m5,
rgr_urbsubs_usc_m5_ME,
rgr_urbsubs_usc_m8,
rgr_urbsubs_usc_m8_ME.1,
  
  rametsJ_gr_city_m2, # June ramets models
rametsJ_gr_usc_m2,
rametsJ_urbsubs_city_m1,
rametsJ_urbsubs_city_m1_ME,
rametsJ_urbsubs_urbsubs_m7,
rametsJ_urbsubs_urbsubs_m7_ME,
  
  rametsS_gr_city_m5, # Sept ramets models
rametsS_gr_usc_m5,
rametsS_urbsubs_city_m5,
rametsS_urbsubs_city_m5_ME,
rametsS_urbsubs_usc_m5,
rametsS_urbsubs_usc_m5_ME,

  surv20_gr_city_m1, # survival models
surv20_gr_usc_m1,
surv20_urbsubs_city_m1,
surv20_urbsubs_city_m1_ME,
surv20_urbsubs_usc_m1,
surv20_urbsubs_usc_m1_ME)


# get model formulas --> export -----

# make list of model summaries
# summaries <- lapply(model_list, summary)
# summaries_table1 <- sjPlot::tab_model(model_list,
#                                       auto.label = FALSE,
#                                       show.ci = FALSE)



all_models_2020_formulas <- lapply(model_list, formula) %>%
  lapply(., toString) %>%
  as.character()

# get df with model name and formula
modsum_1 <- data.frame(Model_Name1 = all_models_2020, 
       Formula = all_models_2020_formulas)
       # sapply(list1, r.squaredGLMM()[1]))

# get df with model family and formula 
modsum_2 <- tibble(Model_Name1 = all_models_2020,
                   col2 = lapply(model_list, family),
               Family = sub("\\,.*", "", col2)) %>%
   dplyr::select(-col2) %>%
  mutate(Family = str_remove(Family, "list"))
 
# modsum_2 <- tibble(lapply(list1, family)) %>%
#   t() %>%
#   as.data.frame() %>%
#   dplyr::select(., c(V7, V15)) %>%
#   unlist() %>%
#     as.data.frame()




# merge the two dfs
modsum_merge2 <- inner_join(modsum_1, modsum_2, by = "Model_Name1") 
# %>%
#   write.csv(here::here("./Figures_Tables/ANOVA_tables_images/Model_List.csv"))
# 
# # Get R-sq values here
# capture.output(lapply(model_list, r.squaredGLMM), file = here::here("./Figures_Tables/ANOVA_tables_images/Model_R_squared_values.csv"))


# library(jtools)
# export_summs(model_list, digits = 3, to.file = "xlsx", file.name = here::here("./Figures_Tables/ANOVA_tables_images/R_sq_2020.xlsx"))




# these models have at least one significant effect:-----
model_list_sig <- modsum_merge2[c(7,13,
                                 # 25, # full model with a significantly higher AIC than its reduced version, So get rid of it
        26,37,38,41,42,47,48,49,50,51,52,55,71,72,74,77,83,84,85,87,88),] %>%
  dplyr::pull(., Model_Name1)




# these models had city_dist as a significant main effect:
model_list_sig.citydist <- modsum_merge2[c(7,13,47:50,55,71,72,74,85,87:88),] %>%
  dplyr::pull(., Model_Name1)

# these models had Urb_score as a significant main effect:
model_list_sig.urbscore <- modsum_merge2[c(51:52, 83:84),] %>%
  dplyr::pull(., Model_Name1)

# these models had Transect_ID as a significant main effect:
model_list_sig.transect <- modsum_merge2[c(26, 37:38, 41:42, 74, 83:84),] %>%
  dplyr::pull(., Model_Name1) # got rid of 25

# this model had its interaction as the significant main effect:
model_list_sig.interaxn <- model_list_sig[77]



# Export table w/model summaries-----
tidy_sb <- function(model){
  
  return(
    car::Anova(model) %>%
      tidy() %>%
      as.data.frame() %>%
      dplyr::mutate(Response = as.character(formula(model)[2]),
                    .before = term) %>%
      # dplyr::mutate(Model = paste(n(model)),
      #               .before = term) %>%
      dplyr::mutate(Sites = case_when(
        str_detect(as.character(formula(model)[3]), "Transect_ID") == TRUE ~ "Urban Only",
        str_detect(as.character(formula(model)[3]), "Transect_ID") == FALSE ~ "All"),
                    .before = term) %>%
      dplyr::mutate(Significance = case_when(p.value < 0.001 ~ "***",
                                             p.value < 0.01 ~ "**",
                                             p.value <= 0.05 ~ "*", 
                                             p.value <= 0.1 ~ "Marginal")) %>%
      dplyr::mutate(., AIC = AIC(model)) %>%
      dplyr::select(., -df) %>%
      dplyr::rename(., Chi_sq = statistic,
                    Predictor = term,
                    p = p.value) %>%
      dplyr::mutate_if(.,
                is.character,
                str_replace_all,
                pattern = c("City_dist"),
                replacement = c("Distance to City Center")) %>%
        dplyr::mutate_if(.,
                is.character,
                str_replace_all,
                pattern = c("Urb_score"),
                replacement = c("Urbanization Score")) %>%
        dplyr::mutate_if(.,
                is.character,
                str_replace_all,
                pattern = c("Transect_ID"),
                replacement = c("Subtransect")) %>%
      mutate_if(is.numeric, round, 3))
  }


test1 <- do.call(rbind, lapply(model_list, tidy_sb))
test2 <- test1 %>%
      dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("Flowered2020"),
            replacement = c("Flowering Success")) %>%
  dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("sqrt(Total_Height_June)"),
            replacement = c("Height (June)")) %>%
  dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("sqrt(Total_Height_Sept)"),
            replacement = c("Height (Sept)")) %>%
  dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = "(Herbivory.July_mean_binary)",
            replacement = "Herbivory (July) (Binary)") %>%
  dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("(Herbivory.Sept_mean_binary)"),
            replacement = c("Herbivory (Sept) (Binary)")) %>%
  dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("(rel_growth_rate_binary)"),
            replacement = c("Relative growth rate (Binary)")) %>%
  dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("(scar_div_Juneheight_binary)"),
            replacement = c("Weevil scar length (per cm height) (Binary)")) %>%
  dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("(scar_length_cm_binary)"),
            replacement = c("Weevil scar length (Binary)")) %>%
  dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("dead_2020"),
            replacement = c("Survival")) %>%
  dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("log(Herbivory.July_mean)"),
            replacement = c("Herbivory (July)")) %>%
  dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("log(Herbivory.Sept_mean)"),
            replacement = c("Herbivory (Sept)")) %>%
  dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("log(scar_div_Juneheight)"),
            replacement = c("Weevil scar length (per cm height)")) %>%
  dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("log(Scar_length_cm + 0.1)"),
            replacement = c("Weevil scar length")) %>%
  dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("Ramets_June"),
            replacement = c("No. Ramets (June)")) %>%
  dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("Ramets_Sept"),
            replacement = c("No. Ramets (Sept)")) %>%
  dplyr::mutate_if(.,
            is.character,
            str_replace_all,
            pattern = c("sqrt(rel_growth_rate)"),
            replacement = c("Relative growth rate")) 

test2.q1 <- test2 %>% filter(Sites == "All")
test2.q2 <- test2 %>% filter(Sites == "Urban Only") %>%
  dcast(.,  Response + Chi_sq + p + Predictor ~ Predictor , value.var = "AIC")


write.csv(test1,  here::here("./Figures_Tables/ANOVA_tables_images/model_summaries.csv"))
```

## Find change in var estimates along gradient/across subtransects
### Change along gradient: Entire gradient models
```{r}

# code outside of function -----
intercept1 <- fixef(rametsS_gr_city_m5)$cond[1] %>%
  as.numeric() # gives intercept for city_dist = 0.71385548
slope1 <- fixef(rametsS_gr_city_m5)$cond[2] %>%
  as.numeric() # gives slope for city_dist = 0.002606745
urban_terminus = 3.5 # km; most urban pop is close to this distance
rural_terminus = 67 # km; most rural pop is close to this distance
midpoint = 35.25 # km; midpoint of urban and rural terminii
# y = mx + b

# y(urban terminus)
urban_estimate <- slope1 * urban_terminus + intercept1  %T>%
  print()
paste(noquote(c("There are an average of", round(urban_estimate, 3), "ramets/plant in Sept at the urban terminus")), collapse = ' ')

# y(rural terminus)
rural_estimate <- slope1 * rural_terminus + intercept1 %T>%
  print()
paste(noquote(c("There are an average of", round(rural_estimate, 3), "ramets/plant in Sept at the rural terminus")), collapse = ' ')

# AVG NUM. OF RAMETS FROM URBAN TO RURAL TERMINUS:
avg_diff <- (  urban_estimate - rural_estimate )  /     (0.5*       (  urban_estimate + rural_estimate  )  ) %T>%
  print()

# % CHANGE
percent_change <- (((rural_estimate - urban_estimate) / urban_estimate) * 100) %T>%
  print()
paste(noquote(c("On average, the most rural plants produced", round(percent_change, 1), "% more ramets/plant in Sept than the most urban plants")), collapse = ' ')



# Function -----
Perc_change_gradient <- function(city_dist_model){

  urban_terminus = 3.5 # km; most urban pop is close to this distance
  rural_terminus = 67 # km; most rural pop is close to this distance
  midpoint = 35.25 # km; midpoint of urban and rural terminii

  intercept1 <- fixef(city_dist_model)$cond[1] %>%
  as.numeric() # gives intercept for city_dist
  
  slope1 <- fixef(city_dist_model)$cond[2] %>%
  as.numeric() # gives slope for city_dist
  
  response_var <- names(city_dist_model$modelInfo$respCol) %>%
    str_remove(., "[()]")
      

# y(urban terminus)
  urban_estimate <- slope1 * urban_terminus + intercept1 #  %T>%
  # print()
  
  print(paste(noquote(c("There are an average of", round(urban_estimate, 3), response_var, "per plant at the urban terminus")), collapse = ' '))

# y(rural terminus)
   rural_estimate <- slope1 * rural_terminus + intercept1 # %T>%
  # print()
  
  print(paste(noquote(c("There are an average of", round(rural_estimate, 3), response_var, "per plant at the rural terminus")), collapse = ' '))

# AVG NUM. OF RAMETS FROM URBAN TO RURAL TERMINUS:
  avg_diff <- abs( urban_estimate - rural_estimate )  / (0.5* (    urban_estimate + rural_estimate  )  ) # %T>%
  # print()

# % CHANGE
  percent_change <- (((rural_estimate - urban_estimate) / abs(urban_estimate)) * 100) # %T>%
  # print()
  
  print(paste(noquote(c("On average, the most rural plants produced", round(percent_change, 1), "% more", response_var, " per plant than the most urban plants")), collapse = ' '))

}

## for the models that don't work with the original function, try this:
Perc_change_gradient.2 <- function(city_dist_model){

  urban_terminus = 3.5 # km; most urban pop is close to this distance
  rural_terminus = 67 # km; most rural pop is close to this distance
  midpoint = 35.25 # km; midpoint of urban and rural terminii

  intercept1 <- fixef(city_dist_model)[1] %>%
  as.numeric() # gives intercept for city_dist
  
  slope1 <- fixef(city_dist_model)[2] %>%
  as.numeric() # gives slope for city_dist
  
  response_var <- names(city_dist_model@frame)[1] 
      

# y(urban terminus)
  urban_estimate <- slope1 * urban_terminus + intercept1 #  %T>%
  # print()
  
  print(paste(noquote(c("There are an average of", round(urban_estimate, 3), response_var, "per plant at the urban terminus")), collapse = ' '))

# y(rural terminus)
   rural_estimate <- slope1 * rural_terminus + intercept1 # %T>%
  # print()
  
  print(paste(noquote(c("There are an average of", round(rural_estimate, 3), response_var, "per plant at the rural terminus")), collapse = ' '))

# AVG NUM. OF RAMETS FROM URBAN TO RURAL TERMINUS:
  avg_diff <- abs( urban_estimate - rural_estimate )  / (0.5* (    urban_estimate + rural_estimate  )  ) # %T>%
  # print()

# % CHANGE
  percent_change <- (((rural_estimate - urban_estimate) / abs(urban_estimate)) * 100) # %T>%
  # print()
  
  print(paste(noquote(c("On average, the most rural plants produced", round(percent_change, 1), "% more", response_var, " per plant than the most urban plants")), collapse = ' '))

}

## can't get these automated functions to work so I'll do this manually...
# lapply(as.name(model_list_sig), Perc_change_gradient)
# 
# for (model in model_list_sig) {
#   Perc_change_gradient(as.numeric(model))
# }


Perc_change_gradient  (  Height_Jun20_gr_city_m5          )
Perc_change_gradient.2(  Height_Sept20_gr_city_m2         )
Perc_change_gradient  (  rametsS_gr_city_m5               )

# these are binary so this type of analysis doesn't make sense...
# Perc_change_gradient.2(  herb2020.S_gr_dist_m5            )
```

### Change along gradient: Just urban sites models
```{r}
# Function -----
Perc_change_gradient.urbansites <- function(city_dist_model){

  urban_terminus = 3.5 # km; most urban pop is close to this distance
  rural_terminus =  32 # km; most rural pop is close to this distance

  intercept1 <- fixef(city_dist_model)$cond[1] %>%
  as.numeric() # gives intercept for city_dist
  
  slope1 <- fixef(city_dist_model)$cond[2] %>%
  as.numeric() # gives slope for city_dist
  
  response_var <- names(city_dist_model$modelInfo$respCol) %>%
    str_remove(., "[()]")
      

# y(urban terminus)
  urban_estimate <- slope1 * urban_terminus + intercept1 #  %T>%
  # print()
  
  print(paste(noquote(c("There are an average of", round(urban_estimate, 3), response_var, "per plant at the urban terminus")), collapse = ' '))

# y(rural terminus)
   rural_estimate <- slope1 * rural_terminus + intercept1 # %T>%
  # print()
  
  print(paste(noquote(c("There are an average of", round(rural_estimate, 3), response_var, "per plant at the rural terminus")), collapse = ' '))

# AVG NUM. OF RAMETS FROM URBAN TO RURAL TERMINUS:
  avg_diff <- abs( urban_estimate - rural_estimate )  / (0.5* (    urban_estimate + rural_estimate  )  ) # %T>%
  # print()

# % CHANGE
  percent_change <- (((rural_estimate - urban_estimate) / abs(urban_estimate)) * 100) # %T>%
  # print()
  
  print(paste(noquote(c("On average, the most rural plants produced", round(percent_change, 1), "% more", response_var, " per plant than the most urban plants")), collapse = ' '))
  
  # AVG NUM. OF RAMETS FROM RURAL TO URBAN TERMINUS:
  avg_diff.1 <- abs( rural_estimate - urban_estimate )  / (0.5* (    urban_estimate + rural_estimate  )  ) # %T>%
  # print()

# % CHANGE
  percent_change.1 <- (((urban_estimate - rural_estimate ) / abs(rural_estimate)) * 100) # %T>%
  # print()
  
  print(paste(noquote(c("On average, the most urban plants produced", round(percent_change.1, 1), "% more", response_var, " per plant than the most rural plants")), collapse = ' '))

}

## for the models that don't work with the original function, try this:
Perc_change_gradient.2.urbansites <- function(city_dist_model){

  urban_terminus = 3.5 # km; most urban pop is close to this distance
  rural_terminus =  32 # km; most rural pop is close to this distance

  intercept1 <- fixef(city_dist_model)[1] %>%
  as.numeric() # gives intercept for city_dist
  
  slope1 <- fixef(city_dist_model)[2] %>%
  as.numeric() # gives slope for city_dist
  
  response_var <- names(city_dist_model@frame)[1] 
      

# y(urban terminus)
  urban_estimate <- slope1 * urban_terminus + intercept1 #  %T>%
  # print()
  
  print(paste(noquote(c("There are an average of", round(urban_estimate, 3), response_var, "per plant at the urban terminus")), collapse = ' '))

# y(rural terminus)
   rural_estimate <- slope1 * rural_terminus + intercept1 # %T>%
  # print()
  
  print(paste(noquote(c("There are an average of", round(rural_estimate, 3), response_var, "per plant at the rural terminus")), collapse = ' '))

# AVG NUM. OF RAMETS FROM URBAN TO RURAL TERMINUS:
  avg_diff <- abs( urban_estimate - rural_estimate )  / (0.5* (    urban_estimate + rural_estimate  )  ) # %T>%
  # print()

# % CHANGE
  percent_change <- (((rural_estimate - urban_estimate) / abs(urban_estimate)) * 100) # %T>%
  # print()
  
  print(paste(noquote(c("On average, the most rural plants produced", round(percent_change, 1), "% more", response_var, " per plant than the most urban plants")), collapse = ' '))
  
  # AVG NUM. OF RAMETS FROM RURAL TO URBAN TERMINUS:
  avg_diff.1 <- abs( rural_estimate - urban_estimate )  / (0.5* (    urban_estimate + rural_estimate  )  ) # %T>%
  # print()

# % CHANGE
  percent_change.1 <- (((urban_estimate - rural_estimate ) / abs(rural_estimate)) * 100) # %T>%
  # print()
  
  print(paste(noquote(c("On average, the most urban plants produced", round(percent_change.1, 1), "% more", response_var, " per plant than the most rural plants")), collapse = ' '))
  
}


Perc_change_gradient.urbansites  (  herb2020_urb_dist_m8             )
Perc_change_gradient.urbansites  (  herb2020_urb_dist_m8_ME          )
AIC(herb2020_urb_dist_m8, herb2020_urb_dist_m8_ME) # not sig diff but ME has lower AIC. Use it in report.

Perc_change_gradient.urbansites  (  rgr_urbsubs_city_m8_ME.1         )

Perc_change_gradient.urbansites  (  rametsS_urbsubs_city_m5          )
Perc_change_gradient.urbansites  (  rametsS_urbsubs_city_m5_ME       )
AIC(rametsS_urbsubs_city_m5, rametsS_urbsubs_city_m5_ME) # not sig diff but ME has lower AIC. Use it in report.

# these are binary so this type of analysis doesn't make sense...
# Perc_change_gradient.2.urbansites(  herb2020_urb_dist_m5             )
# Perc_change_gradient.2.urbansites(  herb2020_urb_dist_m5_ME          )
AIC(herb2020_urb_dist_m5, herb2020_urb_dist_m5_ME) # not sig diff but ME has lower AIC. Use it in report.

# Perc_change_gradient.2.urbansites(  rgr_urbsubs_city_m5              )
# Perc_change_gradient.2.urbansites(  rgr_urbsubs_city_m5_ME           )
AIC(rgr_urbsubs_city_m5, rgr_urbsubs_city_m5_ME) # not sig diff but ME has lower AIC. Use it in report. DIDN'T PUT IN COMM MTG REPORT- NOT SURE HOW TO INTEGRATE IT/REPORT IT

```

### Difference between urban subtransects models
```{r}

# code outside of function -----
# summary(weev_urbsubs_city_m11)
# car::Anova(weev_urbsubs_city_m11)
# 
# intercept2 <- (fixef(weev_urbsubs_city_m11)$cond[3] * 100) %>%
#   as.numeric() %T>%
#   print() # gives estimate of difference btwn 2 subs
# paste(noquote(c("On average, plants from the corridor subtransect experienced", round(intercept2, 1), "% more weevil damage than plants from the non-corridor subtransect")), collapse = ' ')


# Function -----
Perc_change_subtransects <- function(urban_model) {
  
    response_var <- names(urban_model$modelInfo$respCol) %>%
    str_remove(., "[()]")
    
    intercept2 <- (fixef(urban_model)$cond[3] * 100) %>%
  as.numeric() # %T>% print() # gives estimate of difference btwn 2 subs
    
    print(paste(noquote(c("On average, plants from the corridor subtransect experienced", round(intercept2, 1), "% more ", response_var, "than plants from the non-corridor subtransect")), collapse = ' '))

}


Perc_change_subtransects(  weev_stn_urbsubs_city_m11_ME.2 ) 

Perc_change_subtransects(  weev_urbsubs_city_m11          )
Perc_change_subtransects(  weev_urbsubs_city_m11_ME       ) 
AIC(weev_urbsubs_city_m11, weev_urbsubs_city_m11_ME ) # not sig diff but ME has lower AIC. Use it in report.

Perc_change_subtransects(  weev_urbsubs_usc_m11           )
Perc_change_subtransects(  weev_urbsubs_usc_m11_ME        )
AIC(weev_urbsubs_usc_m11, weev_urbsubs_usc_m11_ME ) # not sig diff but ME has lower AIC. Use it in report.
## NOT REPORTING THIS IN COMM MTG REPORT- URB SCORE (though very close to city_dist- a good sign)

Perc_change_subtransects(  rametsJ_urbsubs_urbsubs_m7     )
Perc_change_subtransects(  rametsJ_urbsubs_urbsubs_m7_ME  )
AIC(rametsJ_urbsubs_urbsubs_m7, rametsJ_urbsubs_urbsubs_m7_ME ) # not sig diff but ME has lower AIC. Use it in report.
## NOT REPORTING THIS IN COMM MTG REPORT- URB SCORE.

Perc_change_subtransects(  rgr_urbsubs_city_m8_ME.1       )

```

